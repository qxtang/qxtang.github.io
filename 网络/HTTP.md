# HTTP

- 超文本传输协议，是一个客户端和服务器端请求和应答的标准
- 无状态、明文传输
- 处于 TCP/IP 分层模型中的应用层
- 浏览器实现了 http 缓存
- 默认端口 80

## 无状态性

- 每次请求都建立新的连接，数据请求完毕立即断开，短连接（http1.1 开始已经支持长连接）
- 协议对于发送过的请求或响应都不做持久化处理，为了更快地处理大量事务，确保协议的可伸缩性，特意设计得简单一些，保存状态需要引入 cookie 和 session，需要客户端实现 cookie 功能（浏览器），服务器实现 session

## HTTP 报文格式

- http 报文分为三部分：起始行、头部、主体
- 其中起始行和头部字段并成为 请求头 或者 响应头，统称为 Header
- header 和 body 之间必须要有一个空行（CRLF）

### 起始行

- 描述请求或响应的基本信息，形如 `GET /index.html HTTP/1.1`

头部：

- 使用 key-value 形式更详细地说明报文
- 多个键值对之间使用 空行（CRLF） 作为分隔符
- 存放如 cookie、content-type 等

主体：

- 存放数据，明文传输

## 请求类型

- OPTIONS：返回服务器针对特定资源所支持的 HTTP 请求方法
- HEAD：向服务器请求与 GET 请求相一致的响应，响应体不返回。可以在不必传输整个响应内容的情况下，就可以获取包含在响应头中的信息
- GET：向特定的资源发出请求
- POST：向指定资源提交数据进行处理请求
- PUT：向指定资源位置上传其最新内容
- DELETE：请求服务器删除指定资源
- TRACE：回显服务器收到的请求，主要用于测试或诊断

## 状态码

- 1xx 信息，服务器收到请求，需要请求者继续执行操作
- 2xx 成功，操作被成功接收并处理
- 3xx 重定向，需要进一步的操作以完成请求
- 4xx 客户端错误，请求包含语法错误或无法完成请求
- 5xx 服务器错误，服务器在处理请求的过程中发生了错误
- 100 表示目前为止一切正常, 客户端应该继续请求, 如果已完成请求则忽略
- 200 表明请求已经成功 默认情况下状态码为 200 的响应可以被缓存
- 201 表示请求已经被成功处理，并且创建了新的资源。新的资源在应答返回之前已经被创建。
- 202 表示服务器端已经收到请求消息，但是尚未进行处理。但是对于请求的处理确实无保证的，即稍后无法通过 HTTP 协议给客户端发送一个异步请求来告知其请求的处理结果。
- 204 表示目前请求成功，但客户端不需要更新其现有页面。
- 301 永久重定向。说明请求的资源已经被移动到了由 Location 头部指定的 url 上，是固定的不会再改变。搜索引擎会根据该响应修正。
- 302 临时重定向。重定向状态码表明请求的资源被暂时的移动到了由 Location 头部指定的 URL 上。浏览器会重定向到这个 URL，但是搜索引擎不会对该资源的链接进行更新
- 304 Not Modified 说明无需再次传输请求的内容，也就是说可以使用缓存的内容。这通常是在 GET 请求, 或在请求中附带了头部信息：If-None-Match 或 If-Modified-Since
- 307 临时重定向。类似 302，区别在于能够确保请求方法和消息主体不会发生改变。
- 308 永久重定向。类似 301，区别在于能够确保请求方法和消息主体不会发生改变。
- 400 表示由于语法无效，服务器无法理解该请求。客户端不应该在未经修改的情况下重复此请求。
- 401 说明由于缺乏目标资源要求的身份验证凭证，发送的请求未得到满足。
- 403 指的是服务器端有能力处理该请求，但是拒绝授权访问。进入该状态后，不能再继续进行验证。该访问是永久禁止的，并且与应用逻辑密切相关（例如不正确的密码）
- 404 说明服务器端无法找到所请求的资源。
- 405 Method Not Allowed 表明服务器禁止了使用当前 HTTP 方法的请求。需要注意的是，GET 与 HEAD 两个方法不得被禁止，当然也不得返回状态码 405。
- 500 表示所请求的服务器遇到意外的情况并阻止其执行请求，比如服务端代码语法错误
- 502 表示作为网关或代理角色的服务器，从上游服务器（如 tomcat、php-fpm）中接收到的响应是无效的。
- 504 表示网关或者代理的服务器无法在规定的时间内获得想要的响应。比如 代码执行时间超时，或死循环了。

::: tip

301 和 302 区别

- 302 重定向只是暂时的重定向，例如未登陆的用户访问用户中心重定向到登录页面。
- 因为服务器返回 302，所以，搜索搜索引擎认为新的网址是暂时的，搜索引擎会抓取新的内容而保留旧的地址。
- 301 重定向是永久的重定向，搜索引擎在抓取新的内容的同时也将旧的网址替换为了重定向之后的网址

:::

## 常见请求头

- Accept 可接受的响应内容类型
- Cookie
- Content-Type 请求体的 MIME 类型
- Origin
- Referer 来源
- User-Agent
- Cache-Control 强缓存相关
- Expires 强缓存相关
- Last-Modified 协商缓存相关
- Etag 协商缓存相关
- Access-Control-Allow-Origin 指定允许跨域的域名

## http 1.1 新特性

- 默认支持并使用长连接，默认设置 Connection：keep-alive，TCP 连接在发送后将仍然保持打开状态，客户端可以继续通过相同的连接发送请求，节省了为每个请求建立新连接所需的时间，还节约了网络带宽
- 断点续传：在请求头引入了 range 头域，它允许只请求资源的某个部分，即返回码是 206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。
- 身份认证
- 状态管理
- 新增了 host 字段，用来指定服务器的域名
- 新的缓存头部标识：Cache-Control、Expires、Last-Modified、Etag

## http 1.0 缺点

- 文本协议传输，不够安全
- 无法复用链接，完成即断开，重新慢启动和 TCP 3 次握手
- 线头阻塞，导致请求之间互相影响
- header 内容繁多，有时有可能会超过响应内容，并且每次有许多字段都是重复传输
- 基于以上缺点，也出现了许多优化手段：雪碧图、合并脚本和样式表、资源内联、域名分片等优化工作，但是如果 http 协议足够好的话，本可以避免这些额外的操作

## http 2.0 帧（frame）和流（stream）

帧代表着最小的数据单位，每个帧会标识出该帧属于哪个流，流是多个帧组成的数据流

## 2.0 新特性

### 二进制协议

- 在 HTTP/1.1 版中，报文的头信息必须是文本（ASCII 编码），数据体可以是文本，也可以是二进制。
- http2 则是彻底二进制，统称为"帧"
- 帧的概念是它实现多路复用的基础

### 多路复用

- 在 HTTP/1 中，每次请求都会建立一次 HTTP 连接，3 次握手和 4 次挥手，这个过程在一次请求过程中占用了较多时间，即使开启了 Keep-Alive，解决了多次连接的问题，但是依然有两个效率上的问题，一是串行的文件传输，二是连接数过多导致的性能问题
- 仍然复用 TCP 连接，但是在一个连接里，客户端和服务器都可以同时发送多个请求或响应
- 通信双方都可以给对方发送二进制帧，这种二进制帧的双向传输的序列，也叫做流(Stream)。HTTP/2 用流来在一个 TCP 连接上来进行多个数据帧的通信，这就是多路复用的概念
- 多路复用，就是在一个 TCP 连接中可以存在多条流。换句话说，也就是可以发送多个请求，对端可以通过帧中的标识知道属于哪个请求。通过这个技术，可以避免 HTTP 旧版本中的队头阻塞问题，极大的提高传输性能。

### 头部压缩

- 由于 HTTP 1.1 协议不带状态，每次请求都必须附上所有信息
- 请求的很多字段都是重复的，浪费带宽，影响速度
- http2 做了优化：
- 头信息使用 gzip 或 compress 压缩后再发送
- 头信息使用 gzip 或 compress 压缩后再发送

### 数据流

- 因为 HTTP/2 的数据包是不按顺序发送的，同一个连接里面连续的数据包，可能属于不同的请求
- 因此，必须要对数据包做标记，指出它属于哪个请求
- HTTP/2 将每个请求或响应的所有数据包，称为一个数据流。每个数据流都有一个唯一编号
- 数据包发送时，都标记数据流 ID，用来区分它属于哪个数据流

### 服务器推送

- 在 HTTP2 当中，服务器已经不再是完全被动地接收请求，响应请求，它也能新建 stream 来给客户端发送消息，当 TCP 连接建立之后，比如浏览器请求一个 HTML 文件，服务器就可以在返回 HTML 的基础上，将 HTML 中引用到的其他资源文件一起返回给客户端，减少客户端的等待
- HTTP2 下服务器主动推送的是静态资源，和 WebSocket 等是不同的

## 队头阻塞现象

- 由 HTTP 基本的“请求 - 应答”模型所导致
- 因为 HTTP 规定报文必须是“一发一收”，这就形成了一个先进先出的“串行”队列
- 队列里的请求没有优先级，只有入队的先后顺序，排在最前面的请求被最优先处理
- 如果队首的请求因为处理的太慢耽误了时间，那么队列里后面的所有请求也不得不跟着一起等待，结果就是其他的请求承担了不应有的时间成本

::: tip

**解决：**

域名分片，多开几个域名，而这些域名都指向同一个服务器

:::

## 定长与不定长包体

- 响应头设置 Content-Length 指明包体的长度
- 响应头设置 Transfer-Encoding: chunked 表示分块传输数据，Content-Length 字段会被忽略，基于长连接持续推送动态内容

## 范围请求

- 用于处理大文件的传输，允许客户端仅请求一个资源的一部分
- 可以一次性请求多个部分，服务器会以 multipart 文件的形式将其返回
- 客户端设置请求头：range，格式为

  ```txt
  Range: <unit>=<range-start>-
  Range: <unit>=<range-start>-<range-end>
  Range: <unit>=<range-start>-<range-end>, <range-start>-<range-end>
  Range: <unit>=<range-start>-<range-end>, <range-start>-<range-end>, <range-start>-<range-end>

  unit：范围请求所采用的单位，通常是字节（bytes）
  <range-start>：整数，表示在特定单位下，范围的起始值
  <range-end>：整数，表示在特定单位下，范围的结束值。可选，如果不存在，表示此范围一直延伸到文档结束
  ```

  ::: note

  - 0-499 表示从开始到第 499 个字节
  - 500- 表示从第 500 字节到文件终点
  - -100 表示文件的最后 100 个字节
  - 服务器收到请求之后，首先验证范围是否合法，如果越界了那么返回 416 错误码，否则读取相应片段，返回 206 状态码

  :::

- 服务器设置响应头：accept-ranges
- 如果服务器返回的是范围响应，需要使用 206 Partial Content 状态码
- 所请求的范围不合法，服务器会返回 416 Range Not Satisfiable 状态码，表示客户端错误

## 如何处理表单数据的提交

体现在两种不同的 Content-Type 取值:

- application/x-www-form-urlencoded

  - 其中的数据会被编码成以&分隔的键值对
  - 字符以 URL 编码方式编码

- multipart/form-data

  - 每一个表单元素都是独立的资源表述
  - 对于图片等文件的上传，基本采用 `multipart/form-data`

## post 和 get 区别

- GET 和 POST 方法没有实质区别，只是报文格式不同。
- 约定上，get 一般使用 url 传参，post 一般使用 body 传参，实际上 post 也可以 url 传参。
- GET 请求会被浏览器主动缓存下来，GET 没有副作用，点击浏览器后退和刷新按钮时，POST 的数据会被重新提交，GET 可以收藏为书签，GET 参数可被浏览器历史保存。
- GET 的参数长度受到浏览器限制，http 协议上并没有限制。POST 无限制。
- 数据类型 GET 只允许传 ASCII 字符，POST 没有限制，允许传二进制数据。
- POST 并不比 GET 安全，只有 https 才是安全的。
- get 请求传参长度的误区：
  误区：我们经常说 get 请求参数的大小存在限制，而 post 请求的参数大小是无限制的。 实际上 HTTP 协议从未规定 GET/POST 的请求长度限制是多少。对 get 请求参数的限制是来源与浏览器或 web 服务器，浏览器或 web 服务器限制了 url 的长度。为了明确这个概念，我们必须再次强调下面几点:
- HTTP 协议 未规定 GET 和 POST 的长度限制
- GET 的最大长度显示是因为 浏览器和 web 服务器限制了 URI 的长度
- 不同的浏览器和 WEB 服务器，限制的最大长度不一样
- 从 TCP 的角度，GET 请求会把请求报文一次性发出去，而 POST 会分为两个 TCP 数据包，首先发 header 部分，如果服务器响应 100(continue)， 然后发 body 部分。(火狐浏览器除外，它的 POST 请求只发一个 TCP 包)

<https://segmentfault.com/a/1190000018129846>  
<https://juejin.im/post/59fc04ecf265da4317697f26>

## http1.x 如何实现长连接(Keep-Alive)

- http1.1 默认开启长连接，不需要设置标头
- http1.1 规定了默认保持长连接，数据传输完成了保持 TCP 连接不断开，等待在同域名下继续用这个通道传输数据。如果需要关闭，需要客户端发送 Connection：close 首部字段
- <https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Connection_management_in_HTTP_1.x>

### 长连接优点

- 较少的 CPU 和内存的使⽤（由于同时打开的连接的减少了）
- 降低拥塞控制（TCP 连接减少了）
- 减少了后续请求的延迟（⽆需再进⾏握⼿）

### 长连接缺点

- 减少了后续请求的延迟（⽆需再进⾏握⼿）

## http1.x 的长连接和 socket 的长连接区别

- HTTP1.1 通过使用 Connection:keep-alive 进行长连接，HTTP 1.1 默认进行持久连接。在一次 TCP 连接中可以完成多个 HTTP 请求，但是对每个请求仍然要单独发 header
- Keep-Alive 不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如 Apache）中设定这个时间
- 这种长连接是一种“伪链接”
- websocket 的长连接，是一个真的全双工。长连接第一次 tcp 链路建立之后，后续数据可以双方都进行发送，不需要发送请求头
- keep-alive 双方并没有建立正真的连接会话，服务端可以在任何一次请求完成后关闭。WebSocket 它本身就规定了是正真的、双工的长连接，两边都必须要维持住连接的状态。

## http1.x 和 http2 区别

- HTTP2 使用的是二进制传送，HTTP1.X 是文本（字符串）传送
- HTTP2 支持多路复用

::: tip

因为有流 ID，所以通过同一个 http 请求实现多个 http 请求传输变成了可能，可以通过流 ID 来标示究竟是哪个流从而定位到是哪个 http 请求

:::

- HTTP2 头部压缩

::: tip

HTTP2 通过 gzip 和 compress 压缩头部然后再发送，同时客户端和服务器端同时维护一张头信息表，所有字段都记录在这张表中，这样后面每次传输只需要传输表里面的索引 Id 就行，通过索引 ID 查询表头的值

:::

- HTTP2 支持服务器推送，HTTP2 支持在未经客户端许可的情况下，主动向客户端推送内容
