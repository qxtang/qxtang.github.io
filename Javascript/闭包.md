# 闭包

- 函数 A 返回了一个函数 B，并且函数 B 中使用了函数 A 的变量，函数 B 就被称为闭包，函数 A 的执行上下文没有被释放
- 闭包中的变量不保存在栈内存中，而是保存在堆内存中。这也就解释了函数调用之后之后为什么闭包还能引用到函数内的变量
- 能够访问已经被销毁的执行上下文的活动对象的函数、有权访问另一个函数作用域中的变量的函数
- 函数做为参数传递或在尾部 return，并且子函数在外调用，形成闭包，子函数所在的父函数的作用域不会被释放，子函数的作用域中仍然保留着父级的单变量对象和作用域链，因此可以继续访问到父级的变量对象
- 应用：设计私有的方法和变量
- 优点：可以避免全局变量的污染
- 缺点：常驻内存会增大内存使用量，会躲掉垃圾回收机制，使用不当很容易造成内存泄露

## 闭包实现累加

```javascript
function A() {
  let start = 0;

  function B() {
    return ++start;
  }

  return B;
}

const inc = A();

console.log(inc());
console.log(inc());
console.log(inc());
```

## 如何优化闭包

- 通过解除对匿名函数的引用，可以将匿名函数占用的内存安全释（将闭包创建的函数赋值为 null）

```jsx
function outerFun(outerArg) {
  return function () {
    console.log('这里是内部匿名函数');
    console.log('可以访问包含函数的变量', outerArg);
  };
}

// 创建一个函数，是 outerFun 中返回的匿名函数
var create = outerFun('hi');

// 释放对匿名函数的引用
create = null;
```

- 如果没有对匿名函数的引用，匿名函数执行完之后自动销毁，就可以做到减少占用内存的问题
- 利用匿名函数，制造私有作用域（块级作用域），这样匿名函数执行完之后可以将引用的活动对象销毁
