# 垃圾回收

- 各大浏览器通常用采用的垃圾回收有两种：标记清除、引用计数

## 标记清除（主流）

- 垃圾收集器在运行时给存储在内存中的所有变量加上标记
- 因为只要上下文中的代码在运行，就有可能用到它们
- 从根部出发将能触及到的对象的标记清除
- 还存在标记的变量被视为准备删除的变量
- 销毁带标记的变量

## 引用计数

- 如果一个对象没有被其他对象引用，那它将被垃圾回收机制回收
- 跟踪记录每个值被引用的次数
- 当声明了一个变量并将一个引用类型赋值给该变量时，则这个值的引用次数就是 1
- 相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数就减 1
- 当这个引用次数变成 0 时，则说明没有办法再访问这个值了，因而就可以将其所占的内存空间给收回来
- 缺点：循环引用会造成对象无法被回收

## 如何避免垃圾回收

- 对象尽量复用
- 数组优化：将 [] 赋值给一个数组对象，但是这种方式又创建了一个新的空对象，且将原来的数组对象变成了一小片内存垃圾，实际上，将数组长度赋值为 0（arr.length = 0）也能达到清空数组的目的，并且同时能实现数组重用，减少内存垃圾的产生

## 引起内存泄漏的操作

- 全局变量
- 闭包
- dom 清除，事件绑定未清除
- 未清除的计时器
- setTimeout 的第一个参数使用字符串而非函数
- 引用循环：在两个对象彼此引用且彼此保留时，就会产生一个引用循环
- console.log 打印了太大的变量
- React 组件卸载后，存在异步回调中调用 setState

## 手动释放内存

fn = null【null：空指针对象】
