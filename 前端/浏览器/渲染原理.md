# 渲染原理

![](../../resource/渲染过程.png '合成渲染树')

## 创建 dom 树

> 字节 → 字符 → 令牌 → 节点 → 对象模型(DOM)

![](../../resource/%E5%88%9B%E5%BB%BAdom%E6%A0%91.png '创建 dom 树过程')

- 转换（字节 → 字符）：浏览器从磁盘或网络读取 HTML 原始字节，根据文件的指定编码（例如 UTF-8）将它们转换成字符

- 令牌化（字符 → 令牌）：浏览器将字符串转换成 W3C HTML5 标准规定的各种令牌，例如，`<html>`、`<body>`，以及其他尖括号内的字符串。每个令牌都具有特殊含义和一组规则

- 词法分析（令牌 → 节点）：分词器将字节流转换为一个一个的 Token，Token 分为 Tag Token 和文本 Token，令牌转换成定义其属性和规则的“对象”。

- DOM 构建（节点 → DOM）：将 Token 解析为 DOM 节点，并将 DOM 节点添加到 DOM 树中

::: tip

HTML 解析器维护了一个 Token 栈结构，用来计算节点间父子关系，在上阶段生成的 Token 会被顺序压到这个栈中：

- HTML 解析器开始工作时，会默认创建了一个根为 document 的空 DOM 结构，同时会将一个 StartTag document 的 Token 压入栈底
- 如果压入到栈中的是 StartTagToken，HTML 解析器会为该 Token 创建一个 DOM 节点，然后将这个 Dom 节点加入到 DOM 树中，它的父节点就是栈中相邻的那个元素生成的 DOM 节点
- 如果分词器解析出来的是文本 Token，那么会生成一个文本节点，然后把这个文本 Dom 节点加入到 DOM 树中（文本 Token 不需入栈），它的父节点就是当前栈顶 Token 所对应的 DOM 节点
- 如果分词器解析出来的是 EndTag 标签，HTML 解析器会查看 Token 栈顶的元素是否是 StartTag div，如果是，就将 StartTag div 从栈中弹出，边上该 div 元素解析完成
- 最后按照上面的规则，分词器一路解析下来，就形成了一个简单的 DOM 树

:::

- 由于 HTML 标记定义不同标记之间的关系（一些标记包含在其他标记内），创建的对象链接在一个树数据结构内，此结构也会捕获原始标记中定义的父项-子项关系：HTML 对象是 body 对象的父项，body 是 paragraph 对象的父项，依此类推。

## 创建 cssom 树

- 将 css 解析成 cssom 树
- 格式化样式表：字节流转为 document.styleSheets
- 标准化样式表：比如 em → px, red → rgba(255,0,0,0), bold → 700
- 计算每个 dom 节点样式

  计算规则：继承和层叠

  继承：每个子节点默认继承父节点样式，如果父节点找不到，采用浏览器默认样式（也叫 UserAgent 样式）

  层叠：样式层叠，是 CSS 一个基本特征，定义如何合并来自多个源的属性值的算法。具体层叠规则属于深入 CSS 语言的范畴

- 计算完样式后，所有样式值会挂载到 window.getComputedStyle() 当中，可以通过这个方法获取计算后的样式

## 解析 js

操作 dom 树和 cssom 树

## 将 dom 树和 cssom 树构造成渲染树

- 只包含可见元素

::: note

构造渲染树过程：

- 从 dom 树的根节点开始遍历每个可见的节点
- 对每个可见节点，找到 css 树中的对应的规则，并应用
- 根据每个可见的节点及其对应的样式，组合生成渲染树
- 渲染树的节点称为渲染对象，包含有颜色和大小等属性的矩形
- 渲染对象和 dom 对象相对应，但这种对应关系不是一对一的，不可见的 dom 元素不会被插入渲染树

:::

::: note

js 为什么会阻塞后续资源下载：

- 因为 js 有可能会修改 dom，在 js 执行完成前，后续资源的下载可能是没有必要的，所以代码中 script 标签最好放在 html 文档末尾
- 当文档加载过程中遇到 js 文件，html 文档会挂起渲染的线程，等待文档中 js 文件加载完毕，等待解析执行完毕，才恢复 html 文档的渲染线程

:::

::: tip

非外部引入 javascript，css，对渲染的影响：

- css 会阻塞 dom 渲染：render tree 生成依赖 dom 树和 cssom 树，故会阻塞 render tree 的生成
- css 不会阻塞 dom 解析：dom 树和 cssom 树的解析互不影响
- js 会阻塞 dom 解析：dom 树构建时当遇到 javascript 脚本，就要暂停 dom 解析，先去执行 javascript，因为 javascript 可能会操作当前已经生成的 dom，加上 defer 或者 async 属性，脚本下载的过程就不会阻塞 dom 解析
- css 会阻塞 js 执行：js 中可能会获取 dom 元素的 css 样式属性，为了获取到最新的正确的样式，需要等所有的 css 加载完成，否则获取的样式可能是错误的或者不是最新的，要等到 js 前面的 css 加载完成，js 才能执行，所以一般 cdn 引入第三方库的 js 一般放在 css 之前
- body 内部的外链 css 较为特殊，会形成样式闪烁现象，慎用

:::

::: tip

外部引入 javascript，css，对渲染的影响：

- webkit 渲染引擎有一个优化，当渲染进程接收 html 文件字节流时，会先开启一个预解析线程
- 如果遇到 javascript 文件或者 css 文件，预解析线程会提前下载这些数据

:::

::: tip

为什么：

- js 最好放底部：js 会阻塞 dom 解析
- css 最好放头部：避免屏闪，css 会阻塞 dom 渲染
- 头部同时有 js 与 css，最好将 js 放在 css 上面：如果 js 中获取元素的样式，浏览器是需要计算的，就是依赖于 css。浏览器无法感知 js 内容是什么，为避免样式获取，因而只好等前面所有 css 下载完后，再执行 js

:::

## 布局计算

## 分层

- 生成图层树（Layer Tree）
- 拥有层叠上下文属性的元素会被提升为单独一层
- 需要裁剪（clip）的地方也会创建图层
- 图层绘制

创建新图层的时机：

**显式合成：**

- 拥有层叠上下文的元素

  1. HTML 根元素本身具有层叠上下文
  1. 元素设置 position 不为 static 并且设置了 z-index 属性
  1. 元素的 opacity 值不是 1
  1. 元素的 transform 值不是 none
  1. 元素的 filter 值不是 none
  1. 元素的 isolation 值是 isolate
  1. will-change 指定的属性值为上面任意一个

- 需要剪裁（clip）的元素

元素有了层叠上下文的属性或者需要被剪裁，满足其中任意一点，就会被提升成为单独一层

**隐式合成：**

- z-index 比较低的节点会提升为一个单独的图层，那么层叠等级比它高的节点都会成为一个独立的图层
- 会增大内存的压力，有时候会让页面崩溃，这就是层爆炸

## 绘制图层

- 把一个复杂的图层拆分为很小的绘制指令，然后再按照这些指令的顺序组成一个==绘制数组==，==绘制数组==元素包含坐标、样式等属性

## 分块

- 绘制图层的操作在渲染进程中有专门的线程：合成线程
- 渲染进程的主线程会给合成线程发送消息，把==绘制数组==提交给合成线程
- 合成线程会将图层划分为图块，通常是 256 × 256 或者 512 × 512 这个规格

::: tip

此处 Chrome 底层优化首屏加载速度的一个手段：

- 因为非视口内图块数据要进入 GPU 内存，考虑到浏览器内存上传到 GPU 内存的操作消耗，即使是绘制一部分图块，也可能会耗费大量时间
- 在首次合成图块时只采用一个低分辨率的图片
- 当正常图块内容绘制完毕后，将当前低分辨率图块内容替换

:::

## 光栅化

- 合成线程按照视口附近的图块来优先生成位图
- 栅格化：指将图块转换为位图，生成位图的操作是由栅格化来执行的
- 图块是栅格化执行的最小单位
- 渲染进程中专门维护了一个栅格化线程池，专门负责把图块转换为位图数据
- 合成线程会选择视口附近的图块，把它交给栅格化线程池生成位图
- 生成位图的过程会使用 GPU 进行加速，生成的位图发送给合成线程，使用 GPU 生成位图的过程叫快速栅格化，或者 GPU 栅格化，保存在 GPU 内存

## 合成和显示

- 合成线程生成一个绘制命令，发送给浏览器进程
- 浏览器进程根据这个命令，把页面内容绘制到内存（生成了页面），把这部分内存发送给显卡

::: tip

显卡工作基本原理：

- 假设屏幕刷新频率 60Hz，即一秒更新 60 张图片，一张图片停留时间约为 16.7ms
- 每次更新的图片都来自显卡的前缓冲区
- 显卡接收到浏览器进程传来的页面后，会合成相应的图像，并将图像保存到后缓冲区
- 显卡系统自动将前缓冲区和后缓冲区对换位置，如此循环更新
- 比如某个动画大量占用内存时，浏览器生成图像变慢，图像传送给显卡不及时，而显示器还是以不变的频率刷新，因此会出卡顿掉帧现象

:::

## 回流-重绘-合成

回流：

- dom 几何尺寸变化的时候触发，会将布局计算样式等流程全部走一遍，比较消耗资源
- 根据得到的渲染树，计算所有节点在屏幕中的位置，得到节点的几何信息，进行布局
- 回流必定触发重绘，重绘不一定触发回流

触发回流的操作：

- 页面初次渲染
- 浏览器窗口大小改变
- 元素尺寸、位置、内容发生改变
- 元素字体大小变化
- 添加或者删除可见的 dom 元素
- 激活 CSS 伪类（例如：`:hover`）
- 查询某些属性或调用某些方法

重绘：

- 元素样式改变不影响位置时触发，省去布局的流程，跳过了布局树和建图层树
- 根据渲染树以及回流得到的几何信息，得到节点的绝对像素，遍历渲染树并调用硬件的 API 绘制所有节点

合成：

- 更改了一个既不要布局也不要绘制的属性
- 渲染引擎跳过布局和绘制，直接执行合成操作
- 提升合成层的最好方式是使用 CSS 的 will-change 属性

::: tip

例子：

比如使用 CSS 的 transform 来实现动画效果，避免了回流跟重绘，直接在非主线程中执行合成动画操作。效率更高，是在非主线程上合成的，没有占用主线程资源，也避开了布局和绘制两个阶段，相对于重绘和重排，合成能大大提升绘制效率。

:::

::: note

合成的优势：

- 交由 GPU 合成，比 CPU 处理要快
- 需要 repaint 时，只需要 repaint 本身，不会影响到其他的层
- 对于 transform 和 opacity 效果，不会触发 layout 和 paint

:::

::: tip

减少回流和重绘：

CSS：

- 使用 cssText 设置样式、或修改 class 来设置样式
- 将动画效果应用到 position 属性为 absolute 或 fixed 的元素上
- 避免使用 CSS 表达式（例如：calc()）
- CSS3 硬件加速（GPU 加速），可以让 transform、opacity、filters 这些动画不会引起回流重绘（如果为太多元素使用 css3 硬件加速，会导致内存占用较大，会有性能问题）

JavaScript：

- 避免频繁操作样式，最好一次性重写 style 属性，或者将样式列表定义为 class 并一次性更改 class 属性
- 避免频繁操作 DOM，创建一个 documentFragment，在它上面应用所有 DOM 操作，最后再把它添加到文档中
- 也可以先为元素设置 display: none，操作结束后再把它显示出来。因为在 display 属性为 none 的元素上进行的 DOM 操作不会引发回流和重绘
- 避免频繁读取会引发回流/重绘的属性或方法（offsetTop、offsetLeft、offsetWidth、offsetHeight、getBoundingClientRect 等），如果确实需要多次使用，就用一个变量缓存起来
- 对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流

:::

::: note

调用以下 api 会触发重绘回流：

- offsetTop、offsetLeft、offsetWidth、offsetHeight
- scrollTop、scrollLeft、scrollWidth、scrollHeight
- clientTop、clientLeft、clientWidth、clientHeight
- getComputedStyle()
- getBoundingClientRect
- https://gist.github.com/paulirish/5d52fb081b3570c81e3a

:::

::: tip

GPU 加速：

- 利用 CSS3 的 transform、opacity、filter、will-change 这些属性可以实现合成的效果，也就是常说的 GPU 加速
- 在合成的情况下，直接跳过布局和绘制流程，进入非主线程处理部分，直接交给合成线程处理
- 充分发挥 GPU 优势，合成线程生成位图的过程中会调用线程池，并在其中使用 GPU 进行加速生成，而 GPU 是擅长处理位图数据的
- 没有占用主线程的资源，即使主线程卡住了，效果依然流畅展示

:::

## 最佳实践

- 使用 createDocumentFragment 进行批量的 DOM 操作
- 对于 resize、scroll 等进行防抖/节流处理
- 动画使用 transform 或者 opacity 实现
- 将元素的 will-change 设置为 opacity、transform、top、left、bottom、right。渲染引擎会为其单独实现一个图层，当这些变换发生时，仅仅只是利用合成线程去处理这些变换，而不牵扯到主线程，提高渲染效率。
- 对于不支持 will-change 属性的浏览器，使用一个 3D transform 属性来强制提升为合成 `transform: translateZ(0);`
- 使用 requestAnimationFrame

## will-change

- <https://developer.mozilla.org/zh-CN/docs/Web/CSS/will-change>
- 告知浏览器该元素会有哪些变化的方法，这样浏览器可以在元素属性真正发生变化之前提前做好对应的优化准备工作
- 可以将一部分复杂的计算工作提前准备好，使页面的反应更为快速灵敏
- 应该被视为最后的应对手段，用于解决现有的性能问题。不应该被用来预测性能问题
