[{"id":"079c4846f4492de09e5c456d89c26df5","dirname":"工作沉淀","filename":"","basename":"","path":"/home/runner/work/qxtang.github.io/qxtang.github.io","children":[{"id":"cc58154c2ed8a033e1bdab835838c37a","dirname":"最佳实践","filename":"","basename":"","path":"/home/runner/work/qxtang.github.io/qxtang.github.io/工作沉淀","children":[{"id":"9c3ac40fb9238d39f71c7af6bc753354","filename":"CSS.md","basename":"CSS","path":"/home/runner/work/qxtang.github.io/qxtang.github.io/工作沉淀/最佳实践","content":"CSS善用继承关键字 inherit子元素设置 height:inherit 实现高度继承使用 inherit 关键字重置输入框的内置字体使用 all:unset 或 all:revert 将样式进行批量重置善用 max/min-contenthttps://www.zhangxinxu.com/wordpress/2016/05/css3-width-max-contnet-min-content-fit-content/"},{"id":"89c03bcf1c767af492556c4e3bee49b2","filename":"Javascript.md","basename":"Javascript","path":"/home/runner/work/qxtang.github.io/qxtang.github.io/工作沉淀/最佳实践","content":"Javascript先声明后调用声明变量优先使用 const常量大写不要忽略抛异常、不要忘了在 Promise\\async await 抛异常缓存耗时的计算，比如 dom 节点查找结果、设备信息查询结果等尽可能使用原生方法，因为原生方法是用低级语言写的（C/C++），并且被编译成机器码，效率更高，比如 Array 的 filter少用 for-in，比其他循环方式明显要慢，因为 for-in 要搜索原型属性基于函数的迭代 forEach 比一般的循环要慢，如果对运行速度要求很严格，不要使用使用枚举或策略模式减少 elseif，使用 Map、Object 优化 switch-case?? 空值合并操作符、?. 链合并运算符使用双取反运算符将变量转为 boolean 类型少写 console（或提交代码时删除 console），善于利用浏览器或 IDE 自带的 debugger 工具来调试，项目跑起来一堆的日志让队友很头疼多元判断时，可将条件拼接成字符串存到 Object 里/** * 按钮点击事件 * @param {number} status 活动状态：1未开始 2进行中 3结束 * @param {string} identity 身份标识：guest游客 admin管理员 */const onButtonClick = (status, identity) =&gt; {  if (identity == &#x27;guest&#x27;) {    if (status == 1) {      //do sth    } else if (status == 2) {      //do sth    } else if (status == 3) {      //do sth    } else {      //do sth    }  } else if (identity == &#x27;admin&#x27;) {    if (status == 1) {      //do sth    } else if (status == 2) {      //do sth    } else if (status == 3) {      //do sth    } else {      //do sth    }  }};// 可优化为const actions = new Map([  [&#x27;guest_1&#x27;, () =&gt; {} /*do sth*/],  [&#x27;guest_2&#x27;, () =&gt; {} /*do sth*/],  [&#x27;guest_3&#x27;, () =&gt; {} /*do sth*/],  [&#x27;admin_1&#x27;, () =&gt; {} /*do sth*/],  [&#x27;admin_2&#x27;, () =&gt; {} /*do sth*/],  [&#x27;admin_3&#x27;, () =&gt; {} /*do sth*/],  [&#x27;default&#x27;, () =&gt; {} /*do sth*/],]);/** * 按钮点击事件 * @param {string} identity 身份标识：guest游客 admin管理员 * @param {number} status 活动状态：1未开始 2进行中 3 结束 */const onButtonClick = (identity, status) =&gt; {  let action = actions.get(`${identity}_${status}`) || actions.get(&#x27;default&#x27;);  action.call(this);};可适当使用对象区分作用域使用 Array.includes 来优化多个条件的判断使用 Array.every 和 Array.some 来处理全部/部分满足条件减少嵌套，提前使用 return 语句用有意义且常用的单词命名变量// 错误：const yyyymmdstr = moment().format(&#x27;YYYY/MM/DD&#x27;);// 正确:const currentDate = moment().format(&#x27;YYYY/MM/DD&#x27;);保持统一命名可能同一个项目对于获取用户信息，会有三个不一样的命名，应该保持统一。// 错误：getUserInfo();getClientData();getCustomerRecord();// 正确：getUser();尽量少写魔法值，每个常量都该命名// 错误：// 三个月之后你还能知道 86400000 是什么吗?setTimeout(doSomeThing, 86400000);// 正确：const MILLISECOND_IN_A_DAY = 86400000;setTimeout(doSomeThing, MILLISECOND_IN_A_DAY);避免无意义的前缀如果创建了一个对象 car，就没有必要把它的颜色命名为 carColor。// 错误：const car = {  carMake: &#x27;Honda&#x27;,  carModel: &#x27;Accord&#x27;,  carColor: &#x27;Blue&#x27;,};function paintCar(car) {  car.carColor = &#x27;Red&#x27;;}// 正确：const car = {  make: &#x27;Honda&#x27;,  model: &#x27;Accord&#x27;,  color: &#x27;Blue&#x27;,};function paintCar(car) {  car.color = &#x27;Red&#x27;;}使用函数参数默认值// 错误：function doSomeThing(name) {  const username = name || &#x27;tony&#x27;;  // ...}// 正确：function doSomeThing(name = &#x27;tony&#x27;) {  // ...}参数越少越好如果参数超过两个，使用解构语法，不用考虑参数的顺序。// 错误：function createMenu(title, body, buttonText, cancellable) {  // ...}// 正确：function createMenu({ title, body, buttonText, cancellable }) {  // ...}createMenu({  title: &#x27;Foo&#x27;,  body: &#x27;Bar&#x27;,  buttonText: &#x27;Baz&#x27;,  cancellable: true,});抽象重复代码很多时候虽然是同一个功能，但由于一两个不同点，让你不得不写两个几乎相同的函数，要想优化重复代码需要有较强的抽象能力。不传 flag 参数不要通过 flag 的 true 或 false，来判断执行逻辑。不污染全局在 JavaScript 中不要污染全局，会容易产生难以预料的 bug。删除弃用代码可以在代码库历史版本中找到它。使用 class链式调用这种模式让的代码简洁优雅，在类的方法最后返回 this 就可以了。class Car {  constructor(make, model, color) {    this.make = make;    this.model = model;    this.color = color;  }  setMake(make) {    this.make = make;    return this;  }  setModel(model) {    this.model = model;    return this;  }  setColor(color) {    this.color = color;    return this;  }  save() {    console.log(this.make, this.model, this.color);    return this;  }}const car = new Car(&#x27;Ford&#x27;, &#x27;F-150&#x27;, &#x27;red&#x27;).setColor(&#x27;pink&#x27;).save();单一功能原则如果一个类干的事情太多太杂，会导致后期很难维护。我们应该厘清职责，各司其职减少相互之间依赖。封闭开放原则“当需要改变一个程序的功能或者给这个程序增加新功能的时候，可以使用增加代码的方式，但是不允许改动程序的源代码”比如我想修改一个公共组件的样式来适配自己的页面，但又需要保证其他使用这个组件的页面不受影响，可以通过增加一个主题参数，根据该参数加载一份新的样式文件"},{"id":"46ad0cb0a383a9a3d8534d3bb1701115","filename":"React.md","basename":"React","path":"/home/runner/work/qxtang.github.io/qxtang.github.io/工作沉淀/最佳实践","content":"Reacthooks 优先不要所有状态都通过类似 Redux 或 Mobx 等状态管理器去管理！定义类组件时，使用 PropTypes 对属性进行类型检查和赋予默认值使用 unstated-next 代替 redux组件属性超过 3 个则换行多用函数组件，更小的打包体积，更高的执行效率多用 PureComponent，PureComponent 会先对 state 和 props 进行浅比较，不同的时候才会 render遵循单一职责原则，使用 HOC / 装饰器 / Render Props 增加职责react 组件文件用 jsx，用大驼峰命名 jsx 文件表达式中的 jsx 使用圆括号包裹每个文件只写一个组件，但是多个无状态组件可以放在单个文件中，文件名要与默认导出的类名一致组合优于继承性能原因尽量不写内联函数，比如点击事件封装切换类型的组件时，使用一个配置数组来减少判断（策略模式）多使用解构，例如声明函数组件的 props 和 默认值export default ({ name = &#x27;小明&#x27;, sex = &#x27;男&#x27; }) =&gt; (  &lt;&gt;    我叫 {name}，性别 {sex}  &lt;/&gt;);没有子元素的组件写成自闭合// 错误：&lt;Foo&gt;&lt;/Foo&gt;// 正确：&lt;Foo/&gt;组件属性命名保持统一，使兼容性良好，避免无意义前缀// 错误，心塞&lt;MyInput inputValue onInputChange wrapStyle wrapClassName /&gt;// 正确&lt;MyInput value onChange style className /&gt;避免在 render 里面动态创建对象 / 方法，否则会导致子组件每次都 render// 错误：render() {  const obj = {num: 1}  return (    &lt;Child obj={obj} onClick={()=&gt;{...}} /&gt;  );}避免在 JSX 中写复杂的三元表达式，应通过封装函数或组件实现// 错误：render() {  const a = 8;  return (    &lt;div&gt;      {        a &gt; 0 ? a &lt; 9 ? ... : ... : ...      }    &lt;/div&gt;  );}// 正确：f() {    ...}render() {  const a = 8;  return (    &lt;div&gt;      {        this.f()      }    &lt;/div&gt;  );}使用运算符&amp;&amp;简化三元运算在 JavaScript 中，true &amp;&amp; expression 总是会返回 expression, 而 false &amp;&amp; expression 总是会返回 false，因此，如果条件是 true，&amp;&amp; 右侧的元素就会被渲染，如果是 false，React 会忽略并跳过它。例如：{  loading ? &lt;Loading /&gt; : null;}可简化为{  loading &amp;&amp; &lt;Loading /&gt;;}尽量避免使用展开运算符来展开 props变得难以理解和维护，容易出 bug遇到事件处理，使用一个返回新函数的方法例如：import React from &#x27;react&#x27;;export default function SampleComponent({ onValueChange }) {  const handleChange = (key) =&gt; {    return (e) =&gt; onValueChange(key, e.target.value);  };  return (    &lt;form&gt;      &lt;input onChange={handleChange(&#x27;name&#x27;)} /&gt;      &lt;input onChange={handleChange(&#x27;email&#x27;)} /&gt;      &lt;input onChange={handleChange(&#x27;phone&#x27;)} /&gt;    &lt;/form&gt;  );}这样看起来比较简洁使用 Hook components比如要封装一个弹窗组件：// 组件import React, { useCallback, useState } from &#x27;react&#x27;;import ConfirmationDialog from &#x27;components/global/ConfirmationDialog&#x27;;export default function useConfirmationDialog({ headerText, bodyText, confirmationButtonText, onConfirmClick }) {  const [isOpen, setIsOpen] = useState(false);  const onOpen = () =&gt; {    setIsOpen(true);  };  const Dialog = useCallback(    () =&gt; (      &lt;ConfirmationDialog        headerText={headerText}        bodyText={bodyText}        isOpen={isOpen}        onConfirmClick={onConfirmClick}        onCancelClick={() =&gt; setIsOpen(false)}        confirmationButtonText={confirmationButtonText}      /&gt;    ),    [isOpen]  );  return {    Dialog,    onOpen,  };}// 使用import React from &#x27;react&#x27;;import { useConfirmationDialog } from &#x27;./useConfirmationDialog&#x27;;function Client() {  const { Dialog, onOpen } = useConfirmationDialog({    headerText: &#x27;Delete this record?&#x27;,    bodyText: &#x27;Are you sure you want delete this record? This cannot be undone.&#x27;,    confirmationButtonText: &#x27;Delete&#x27;,    onConfirmClick: handleDeleteConfirm,  });  function handleDeleteConfirm() {}  const handleDeleteClick = () =&gt; {    onOpen();  };  return (    &lt;div&gt;      &lt;Dialog /&gt;      &lt;button onClick={handleDeleteClick} /&gt;    &lt;/div&gt;  );}export default Client;这种模式可以少写很多与组件相关的 state，比如弹窗的 visible、title 之类的将业务逻辑封装进 hooks，业务逻辑与 UI 分离（关注点分离）// 例如：import React from &#x27;react&#x27;;import ItemDisplay from &#x27;./ItemDisplay&#x27;;export default function SampleComponent() {  const { data, handleDelete, handleEdit, handleAdd } = useCustomHook();  return (    &lt;div&gt;      &lt;div&gt;        {data.map((item) =&gt; (          &lt;ItemDisplay item={item} /&gt;        ))}      &lt;/div&gt;      &lt;div&gt;        &lt;button onClick={handleDelete} /&gt;        &lt;button onClick={handleAdd} /&gt;        &lt;button onClick={handleEdit} /&gt;      &lt;/div&gt;    &lt;/div&gt;  );}不要把所有状态存放在 redux，redux 只用于存放用户登录信息、主题等信息不要任何变量都使用状态，可以使用 useRef 或成员属性（类组件）来储存与更新渲染无关的变量，可以通过已保存的状态来推断出的状态可使用 useMemo 来计算，而不要创建新状态尽量不要在组件中声明新的组件// 错误，不建议function A() {  const B = () =&gt; {    return &lt;p&gt;hello&lt;/p&gt;;  };  return (    &lt;div&gt;      &lt;B /&gt;    &lt;/div&gt;  );}原因：高耦合影响性能，A 每一次渲染都会重新声明一遍 B尽量避免向组件传递避免为了优化少量性能过度设计代码，反而降低了代码的可维护性、易读性，浪费时间"},{"id":"83df3dda341d59711de1066064258cc3","filename":"Typescript.md","basename":"Typescript","path":"/home/runner/work/qxtang.github.io/qxtang.github.io/工作沉淀/最佳实践","content":"Typescript风格少写 any接口命名以大写字母“I”开头，来自：http://wiki.eclipse.org/Naming_Conventions#Classes_and_Interfacestype 类型以大写字母“T”开头编译 ts 时，在把 ES6 语法转换成 ES5 语法时，会在每一个文件重复注入许多辅助函数，为了不让同样的辅助函数重复的出现在多个文件中，通过配置 importHelpers 为 true，并将 tslib 做为运行时依赖，可以解决这个问题，减少冗余代码：https://www.typescriptlang.org/tsconfig#importHelpers匹配某个对象的属性：keyof typeof obj类型定义文件(.d.ts)如何放置临时的类型，直接在使用时定义组件个性化类型，直接定义在 ts(x) 文件中范围/全局数据，定义在 global.d.ts 文件中，并在 tsconfig.json 配置让其生效"},{"id":"97fb86e95104d50c595636e7074a4977","filename":"指引.md","basename":"指引","path":"/home/runner/work/qxtang.github.io/qxtang.github.io/工作沉淀/最佳实践","content":"参考总结开发中常用的习惯和模式。https://isamatov.com/simple-tips-for-writing-clean-react-components/https://react-typescript-cheatsheet.netlify.app/https://juejin.im/post/5e021eb96fb9a01628014095https://juejin.cn/post/7086735198942920712"},{"id":"e0832f81d6fa5851a6a1b32edc71d1ab","filename":"通用.md","basename":"通用","path":"/home/runner/work/qxtang.github.io/qxtang.github.io/工作沉淀/最佳实践","content":"通用通用项目目录结构assets 静态资源service 业务逻辑封装components 组件business 业务组件common 通用组件constants 常量store reduxpages 页面types 通用类型utils 工具npm 脚本命名同一系列行为的脚本，但是命令行参数有差异，或者环境变量有差异，用冒号区分，比如&quot;scripts&quot;: {  &quot;build:test&quot;: &quot;tsc &amp;&amp; vite build --mode test&quot;,  &quot;build:prod&quot;: &quot;tsc &amp;&amp; vite build --mode production&quot;,}前置操作的处理如登录、获取用户信息、权限检查等任务，放在根组件（App.tsx、App.vue）中执行，执行结束再渲染路由组件，保证业务接口能正确获取业务参数在使用 Taro 框架开发的小程序中，由于入口组件 app.js 不会渲染任何内容，必须同步返回 props.children，所以对前置操作的处理，可以将首页设置为一个 loading 页，在 loading 页中显示加载中且进行前置操作后，再跳转到普通业务页面（可为 loading 页设置如 redirectUrl 参数，选择要跳转的页面）。不建议在本地构建部署代码应使用 devops 系统前端项目的一般部署流程获取代码：从代码仓库获取项目代码，并切换到待部署的分支或版本安装依赖：安装项目构建所需要的依赖包源码构建：使用构建工具对项目源代码进行构建，生成产物代码产物打包：将部署所需的代码（通常指的是构建后的产物代码，如果是部署 Node 服务则还需要其他目录与文件）打成压缩包推送代码：将待部署的文件或压缩包推送至目标服务器的特定目录下，如果是推送压缩包的情况，还需执行解压重启服务：在部署 Node 服务的情况下，在代码推送后需要进行服务重启本地部署的优势快速：不需要获取代码、安装依赖这几个步骤构建失败能更方便查找问题本地部署的劣势溯源难环境一致性：不同开发人员的本地依赖包版本可能存在差异，导致打包结果并不严格一致；本地环境和部署代码的目标服务器环境之间也可能存在差异；导致项目代码的稳定性无法得到保障例如对于一个 Node 项目而言，在一个 NodeJS 低版本环境下构建的产物，在 Node 高版本环境下就有可能启动异常其他动态 polyfill尽量不要污染全局 window 对象通过封装解决浏览器差异兼容性问题为项目配置代码引用路径别名 alias项目不要添加任何与开发工具强耦合的设置（比如某个地方必须借助 vscode 的某个插件才能运行）禁止安装私人依赖包客户端缓存的键值写成常量，不要写死魔法值字符串使用 Webpack Bundle Analyzer 分析包大小组成函数遵循单一职责原则只导入类型，使用 import typeimport type { DependencyList, useEffect, useLayoutEffect } from &#x27;react&#x27;;想要在 chrome 移动设备模拟器上添加某个自定义设备型号，需要知道该设备的分辨率console.log(document.body.clientWidth, document.body.clientHeight);业务配置必须是不可修改的常量，可使用 Object.freeze() 冻结，禁止任何业务代码修改通过定义环境变量、判断环境变量的方式，区分执行环境差异代码，借助 DefinePlugin 将环境变量静态嵌入客户端代码开发环境 node 和 npm 版本需要一致，因为不同版本 node、npm 行为不一样移除生产环境的 console.log第三方库按需加载抽奖，支付类的操作，请务必做防抖，保证只有一个请求在进行React 应用中的权限管理：https://isamatov.com/react-permissions-and-roles/"}]},{"id":"c259441ba1b59e345b9198134fbe688a","filename":"ADB 通过 Wi-Fi 调试手机.md","basename":"ADB 通过 Wi-Fi 调试手机","path":"/home/runner/work/qxtang.github.io/qxtang.github.io/工作沉淀","content":"ADB 通过 Wi-Fi 调试手机手机和电脑需连接在同一 WiFi 下手机启用开发者选项和无线调试模式允许无线调试后，选择使用配对码配对，adb pair ip:port，填写显示的配对码、IP 地址和端口号运行 adb connect ip:port"},{"id":"18ee921cd515e914d7e5a89fd6bba176","filename":"GitFlow 笔记.md","basename":"GitFlow 笔记","path":"/home/runner/work/qxtang.github.io/qxtang.github.io/工作沉淀","content":"GitFlow 笔记简单记录工作中使用 gitflow 模型管理代码版本、保证代码安全的方法。参考：A successful Git branching modelGit 工作流程Git 分支管理策略git flow 的使用GitFlow 原理浅析gitflow 现在被认为过于复杂，可能不适用于现代软件开发：如何看待 Git flow 发明人称其不适用于持续交付？Issues with git-flow在阿里，我们如何管理代码分支？分支类型master只有一条主分支只读，只能从分支 release 或 hotfix 合并进来所有发生在 master 分支的修改应该打 tag 做记录，方便追溯develop只有一条主开发分支，基于 master 分支克隆包含所有要发布到下一个 release 的代码只读，只能从 feature 或 release 合并进来feature 功能分支完成开发后，合并到 develop，合并到 develop 前，提交合并申请，与 develop 分支进行比较做代码审查，审查通过则允许合并从 develop 拉取 release 分支，提测release 或 hotfix 分支上线完毕，合并回 develop。feature功能开发分支，基于 develop 分支克隆，主要用于新需求新功能的开发有多条，按功能划分，如：/feature/20200712-新增用户、/feature/20200801-登陆注册可以几个人一起开发一条 feature，也可以一人负责一条 feature功能开发完毕后，提测前，合并到 develop 分支feature 类型的分支可同时存在多个，用于团队中多个功能同时开发，属于临时分支，功能完成后可选择删除release版本分支，用于测试与上线，基于 feature 分支合并到 develop 之后，从 develop 分支克隆有多条，按版本划分，如：/release/20200712-第一版v0.1、/release/20200713-第二版v0.2release 类型的分支主要用于测试和修改 bug，完成上线后合并回 develop 与 master 分支hotfix补丁分支，基于 master 分支克隆，主要用于对线上的版本进行 BUG 修复有多条，按版本划分，如：/hotfix/20200712-修复xss漏洞、/hotfix/20200713-修复新增用户失败bug修复完毕后合并回 develop 与 master 分支主要工作流程示例初始化项目，创建 master 分支，然后从 master 拉取 develop 分支根据需求划分功能，从 develop 拉取 feature 分支进行编码开发，如/feature/20200712-新增用户、/feature/20200801-登陆注册feature 分支完成后，合并到 develop 前，提交合并申请，与 develop 比较，进行代码审查，合并完成可以选择删除当前 feature需要发布时，从 develop 拉取 release 分支进行测试，例如/release/20200712-第一版，测试过程中在该条 release 分支上修改 BUG，测试通过后将该条 release 分支发布回归：任一 release 分支通过测试上线后，合并该 release 分支到 develop 与 master，master 分支打 tag，当前 release 不可修改，线上有问题须从 master 拉取 hotfix 分支进行修改通知所有进行中的 feature、release 把 master 合进来一次上线之后若发现 bug，从 master 拉取 hotfix 进行 bug 修改，如/hotfix/20200713-修复新增用户失败bughotfix 通过测试上线后，合并 hotfix 分支到 develop 与 master，master 分支打 tag版本回退：如果需进行版本回退，则选择上一版本号的 release 分支进行发布分支名称可以使用 YYYYMMDD-功能名称 这样的格式，因为这样的命名格式，git gui 工具或者命令行上显示的时候是会自动根据前面的时间来排序，找分支找起来比较方便"},{"id":"e9a2550e8c53d313e8e31853512a444e","filename":"Nginx 笔记.md","basename":"Nginx 笔记","path":"/home/runner/work/qxtang.github.io/qxtang.github.io/工作沉淀","content":"Nginx 笔记工作中经常用的，简单记录一下。实用跨域# 这里约定代理请求url path是以/apis/开头location ^~/apis/ {    # 这里重写了请求，将正则匹配中的第一个()中$1的path，拼接到真正的请求后面，并用break停止后续匹配    rewrite ^/apis/(.*)$ /$1 break;    ...    proxy_pass https://www.tianqiapi.com/;}处理前端单页应用的 history 路由模式location / {    try_files $uri $uri/ /index.html;}适配 PC 和移动环境location / {    # 移动、pc设备适配    if ($http_user_agent ~* &#x27;(Android|webOS|iPhone|iPod|BlackBerry)&#x27;) {        set $mobile_request &#x27;1&#x27;;    }    if ($mobile_request = &#x27;1&#x27;) {        rewrite ^.+ http://mysite-base-H5.com;    }}端口转发http {    ...    upstream dmp8001 {        server 127.0.0.1:8001;    }    server {        listen       80;        server_name  abc.com;        location / {            ...            proxy_pass http://dmp8001;        }    }    ...}善用正则# 动态校验企业微信 h5 应用可信域名location ~ WW_verify_(.*).txt {    return 200 $1;}虚拟主机server {    listen 12332;    server_name 127.0.0.1;    location / {        root D:/Desktop/test;        index index.html index.htm;    }}防媒体文件盗链location ~* \\.(gif|jpg|png|jpeg|mp4)$ {    expires 30d;    valid_referers *.hugao8.com www.hugao8.com m.hugao8.com *.baidu.com *.google.com;    if ($invalid_referer) {        rewrite ^/ http://ww4.sinaimg.cn/bmiddle/051bbed1gw1egjc4xl7srj20cm08aaa6.jpg;        # return 404;    }}简单实现负载均衡轮询（默认），请求过来后，Nginx 随机分配流量到任一服务器upstream backend {    server 127.0.0.1:3000;    server 127.0.0.1:3001;}weight=number 设置服务器的权重，默认为 1，权重大的会被优先分配upstream backend {    server 127.0.0.1:3000 weight=2;    server 127.0.0.1:3001 weight=1;}backup 标记为备份服务器。当主服务器不可用时，将传递与备份服务器的连接upstream backend {    server 127.0.0.1:3000 backup;    server 127.0.0.1:3001;}代理这个集群server {    listen      9000;    server_name localhost;    location / {        proxy_set_header Host $http_host;        proxy_set_header X-Real-IP $remote_addr;        proxy_set_header X-Scheme $scheme;        proxy_pass backend;    }}关于 location 的匹配location 的几种匹配方式普通匹配：location = URI { configuration } #精确匹配location ^~ URI { configuration } #非正则匹配location [空格] URI { configuration } #前缀匹配正则匹配：location ~ URI { configuration } #区分大小写location ~* URI { configuration } #不区分大小写几种匹配方式的说明与优先级整体规则按照先普通匹配，然后再正则匹配，如果正则不匹配，则回退至上一个普通匹配。其中普通匹配没有顺序之分，哪个匹配最精确，就使用哪个 location，正则匹配按照规则的书写顺序进行。= 精确匹配，匹配后停止后续匹配，直接执行该匹配后的 configuration。[空格] 前缀匹配，匹配后，继续更长前缀匹配和正则匹配。^~ 不属于正则匹配，匹配该规则后，停止继续正则匹配。~ 区分大小写的正则匹配，按顺序匹配，一旦匹配即停止后续匹配。~* 不区分大小写的正则匹配，按顺序匹配，一旦匹配即停止后续匹配。示例location = / {    [ configuration A ]}location / {    [ configuration B ]}location /user/ {    [ configuration C ]}location ^~ /images/ {    [ configuration D ]}location ~* \\.(gif|jpg|jpeg)$ {    [ configuration E ]}请求/精准匹配 A，不再往下查找。请求/index.html匹配 B。首先查找匹配的前缀字符，找到最长匹配是配置 B，接着又按照顺序查找匹配的正则。结果没有找到，因此使用先前标记的最长匹配，即配置 B。请求/user/index.html匹配 C。首先找到最长匹配 C，由于后面没有匹配的正则，所以使用最长匹配 C。请求/user/1.jpg匹配 E。首先进行前缀字符的查找，找到最长匹配项 C，继续进行正则查找，找到匹配项 E。因此使用 E。请求/images/1.jpg匹配 D。首先进行前缀字符的查找，找到最长匹配 D。但是，特殊的是它使用了^~修饰符，不再进行接下来的正则的匹配查找，因此使用 D。这里，如果没有前面的修饰符，其实最终的匹配是 E。大家可以想一想为什么。请求/documents/about.html匹配 B。因为 B 表示任何以/开头的 URL 都匹配。在上面的配置中，只有 B 能满足，所以匹配 B。总结location 的配置有两种形式，普通和正则。查找匹配的时候，先查找普通，选择最长匹配项，再查找正则。正则的优先级高于普通。正则查找是按照在配置文件中的顺序进行的，因此正则顺序很重要，建议越精细的放的越靠前。使用=精准匹配可以加快查找的效率，如果经常被访问建议使用精确匹配=。"},{"id":"3b0a71df838e15d30317921a3fd409de","filename":"web应用登录方案.md","basename":"web应用登录方案","path":"/home/runner/work/qxtang.github.io/qxtang.github.io/工作沉淀","content":"web 应用登录方案方案一：仅 jwt后端直接签发 jwt，后端不存储缺点：一旦下发，后端无法拒绝携带该 jwt 的请求，无法踢除用户方案二：jwt + redis后端备份一份 token 存入 redis，请求进来时，使用前端传来的 jwt 从 redis 查询出对应 token，做对比，若 redis 中的 token 过期或不存在则视为无权限方案三：长短 token首次登录设置两个 token，都保存进 redisaccess_token：标准 JWT 格式，即请求时的授权令牌，过期时间较短，一般 2 个小时，redis key：uuid-access，value：jwtrefresh_token：用于刷新 access_token，过期时间较长，一般 1 个月，redis key：uuid-refresh，value：jwt添加凭 refresh_token 刷新 access_token 的接口前端请求封装先发起请求，如果接口返回 access_token 过期，先刷新 access_token，再进行一次重试为了让活跃用户保持登录，其他方案频繁续签会有性能问题，该方案解决此问题遇到的问题前端请求刷新 token 有延迟，如何防止多次请求同时发起多次刷新 token请求封装中设置刷新 token 防抖锁，如果一次刷新任务进行中，则其他刷新请求取消同时发起多个请求时，access_token 正好过期，同时多次提示无权限请求封装中，如果刷新 token 锁处于关闭状态，则把请求任务保存进一个数组，等待锁打开再执行密码保存哈希加盐哈希函数：单向不可逆加密算法直接哈希的缺陷有可能被查表法、逆向查表法、彩虹表等方式破解首先将一些比较常用的密码的哈希值算好，然后建立一张表，当然密码越多，这张表就越大。当你知道某个密码的哈希值时，你只需要在你建立好的表中查找该哈希值，如果找到了，你就知道对应的密码了加盐盐就是一个随机生成的字符串将盐与原始密码连接在一起（前或后都可以），然后将连接后的字符串加密盐和加密后的密码一起保存进数据库登录时将盐和密码都查出来，前端传来的密码同样算法加密后进行比对直接 md5 加密保存也是一种不可逆加密算法，输入任意长度的信息，经过处理，输出都是 128 位的信息值小于 8 位的密码用 md5 加密都很不安全可以破解，至于原因，做为前端开发我暂时没有继续探究为什么不能用用户 id 当做盐用户 id 有可能是会变的，用户 id 一旦有变，登录时计算出来的结果就会不一样"},{"id":"a7aff4b7b9eea3d879a7aad0c984a6fb","filename":"为什么前端团队要统一技术栈.md","basename":"为什么前端团队要统一技术栈","path":"/home/runner/work/qxtang.github.io/qxtang.github.io/工作沉淀","content":"为什么前端团队要统一技术栈公司前端团队建议应该尽可能统一技术栈、统一开发框架。参考https://juejin.cn/post/6844903925947039757不统一开发框架的弊端断崖效应：团队决策者通常会从自身利益考量，希望尽量减少对外部门的依赖，无论是技术选型，规范建立，组件选取，运行环境都能够自行掌控，项目技术栈由单个员工决定的话，单个员工对单个项目的影响变的非常巨大。一个产品经常会因为一两个核心员工的离职难以为继，最后不得不重新开发新的产品。当一位核心员工构建了一些基础的平台工具后，往往随着他的离开把之前的技术积累全部丢弃掉，而更严重的情况会导致整个项目的持续运行都成了问题，比如有的前端会自己偷偷开发一个 npm 包做为项目依赖。统一开发框架的优势避免重复性技术研究，节约人力成本，让项目组把精力更多的投入到业务中。标准化技术规范，提升产品项目质量。要千人一面，而不要千人千面。采用统一的开发框架（平台）后，在技术栈，技术组件，技术实现方案，甚至在代码规范上就能形成标准化的技术输出模式，标准化带来的最大效果不仅仅是开发效率的快速提升，还有产品质量的大幅提升，这是显而易见的。进行技术沉淀，提升公司整体技术能力，避免陷入一个人的能力决定一个项目。当存在公司级别的统一开发框架（平台），项目团队基于该平台进行自身项目的研发，不再需要关注于底层技术实现，只需要关注业务即可。当存在核心同事离职时，平台的研发同事可以对新进入项目的同事进行相关培训，不会导致青黄不接的事情发生。而且，专注于平台的同事为了更好的满足项目组的技术需求，对平台进行不断的改进，从而达到技术积累和沉淀的目标。"},{"id":"15c0a89ff7639100c849b3d0090fd083","filename":"动态校验企微应用可信域名.md","basename":"动态校验企微应用可信域名","path":"/home/runner/work/qxtang.github.io/qxtang.github.io/工作沉淀","content":"动态校验企微应用可信域名在企业微信后台创建自己的自建应用时，如应用页面需使用微信 JS-SDK、跳转小程序等，需完成域名归属验证，需要下载校验文件到自己服务器的根目录下，并能够通过 [自己的域名]/[校验文件名] 访问，以完成校验，如果有很多不同的企业需要安装你的应用，那么每一次安装都需要上传一遍校验文件，很麻烦，一次偶然，我将下载下来的校验文件打开，发现文件名与文件内容是有匹配的：也就是说，当企微请求 [自己的域名]/WW_verify_[随机串].txt 时，我们的服务器能将 随机串 响应给企微就可以通过校验，使用 nginx 的正则表达式能力，就可以轻松实现，匹配请求路径中 WW_verify_ 与 .txt 之间的内容，直接返回，location ~ WW_verify_(.*).txt {  return 200 $1;}这样在任何企业安装我们的应用时，只要填写的是我们的域名，就能直接点击确定通过可信域名校验，完全不需要上传校验文件了，大大减少了在不同企业安装应用的成本，非常舒服，已在公司的企微云客多项目中实践验证。"},{"id":"b113ce2d11fb3ad7fc3a16d27da51e74","filename":"工作中遇到问题汇总.md","basename":"工作中遇到问题汇总","path":"/home/runner/work/qxtang.github.io/qxtang.github.io/工作沉淀","content":"工作中遇到问题汇总Q：某个站点的 nginx 配置使用 location 前缀匹配，某些服务的前缀有相同部分，比如 /api-serve1、/api-serve2，流量转发到了后面的服务A：前缀匹配命中后，会继续更长前缀匹配和正则匹配。可换成使用 ~ 来匹配，这是区分大小写的正则匹配，按顺序匹配，一旦匹配即停止后续匹配。Q：小程序适配 iphonex 机型底部安全区域A：padding-bottom: constant(safe-area-inset-bottom);Q：小程序: hideLoading 能把 toast 也隐藏掉A：https://developers.weixin.qq.com/community/develop/doc/00020212ec8200bc146731f2f51800https://developers.weixin.qq.com/community/develop/doc/000008d41284382afbf6bdf6051c00Q：css module 的局限性，无法准确预测类名// 例如这样的写法，使用了 css module 不会生效.parent {  color: red;}// 鼠标经过某个子节点想要修改父节点的样式.children {  &amp;:hover .parent {    color: yellow;  }}Q：MySQL 数据库使用 utf8 编码格式 无法保存 emoji 表情A：改成 utf8mb4是 MySQL 的一个历史遗留问题，utf8mb4 才是真正的 UTF-8在 MySQL 中，“utf8”编码只支持每个字符最多三个字节，中文是占 3 个字节，其他数字、英文、符号占一个字节而真正的 UTF-8 是每个字符最多四个字节，emoji 符号占 4 个字节，一些较复杂的文字、繁体字也是 4 个字节MySQL 一直没有修复这个 bug，他们在 2010 年发布了一个叫作“utf8mb4”的字符集，巧妙的绕过了这个问题Q：IOS 无法通过 volume 属性设置 video 音量A：https://developer.apple.com/library/archive/documentation/AudioVideo/Conceptual/Using_HTML5_Audio_Video/Device-SpecificConsiderations/Device-SpecificConsiderations.htmlQ：小程序环境判断https://developers.weixin.qq.com/community/develop/doc/000e466b2c84d057b178e339d5b000https://developers.weixin.qq.com/community/develop/article/doc/000e6606ab4ac0edb4791eb4951013Q：typescript 工程，编译产物每一个文件都产生多余辅助函数A：https://www.typescriptlang.org/tsconfig#importHelpersQ：rendering twice because of strict modeA：https://stackoverflow.com/questions/61254372/my-react-component-is-rendering-twice-because-of-strict-modeQ：useEffect hook, dom ref is null in unmount callbackA：https://github.com/facebook/react/issues/20875https://reactjs.org/blog/2020/08/10/react-v17-rc.html#effect-cleanup-timingQ：H5 页面在 iphone 手机底部出现留白A：meta viewport，加入 viewport-fit=cover&lt;meta  name=&quot;viewport&quot;  content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0, viewport-fit=cover&quot;/&gt;Q：解决 Git 默认不区分文件名大小写的问题A：https://www.jianshu.com/p/df0b0e8bcf9bgit config core.ignorecase false"},{"id":"418a1beec827be890faf7fef2fdb59d8","filename":"敏捷迭代模型.md","basename":"敏捷迭代模型","path":"/home/runner/work/qxtang.github.io/qxtang.github.io/工作沉淀","content":"敏捷迭代模型总览敏捷模型组织架构客户化小组专项+小车道小组组建与职责"},{"id":"cdc10d3ed389a940115d2c0e55b9f2c9","filename":"真机调试微信 h5 页面.md","basename":"真机调试微信 h5 页面","path":"/home/runner/work/qxtang.github.io/qxtang.github.io/工作沉淀","content":"真机调试微信 h5 页面需求：真机上通过 https 和微信可信域名访问本地开发服务，进行本地调试目前推荐更好的工具：https://github.com/avwo/whistle条件手机和电脑处在同一局域网环境电脑安装 Fiddler本地 hosts 文件添加映射假设可信域名为 abc.com假设电脑局域网 ip 为 192.168.1.106编辑 hosts 文件，将域名映射到电脑局域网 ip## 微信开发192.168.1.106 abc.com设置 Fiddlertools -&gt; optionshttps 相关设置代理相关设置，这里设置代理端口号为 8002，可以设置任意合法端口号修改 webpack 配置开启 httpshttps://webpack.js.org/configuration/dev-server/#devserverhttps本地服务端口号改成 443此时可在电脑浏览器通过 https://abc.com 访问本地服务修改手机代理进入手机 wlan 设置，选择连接的 wifi，代理选择手动主机名填电脑局域网 ip，端口填 Fiddler 代理设置中的端口号手机安装 Fiddler 证书手机浏览器访问 http://[电脑局域网ip]:[Fiddler 代理端口号]，这里是 http://192.168.1.106:8002点击下载 Fiddler 证书，进入手机 wlan 设置安装证书此时手机浏览器可通过 https://abc.com 访问电脑上的本地服务。结束"},{"id":"2c345830cc8d387301b8b41dde257133","filename":"设计稿多端适配方案.md","basename":"设计稿多端适配方案","path":"/home/runner/work/qxtang.github.io/qxtang.github.io/工作沉淀","content":"设计稿多端适配方案参考https://juejin.cn/post/7018730346216685582问题如何让不同尺寸的屏幕能以正常比例呈现设计稿动态修改 font-size + rem 方案动态修改 html 标签 font-size，样式单位统一用 rem，数值为设计稿尺寸除以 basevar fn = function () {  var designWidth = 1920; // 设计稿尺寸  var base = 16; // 1rem 的占比，不要小于 12  var html = document.getElementsByTagName(&#x27;html&#x27;)[0];  var clientWidth = document.body.clientWidth || document.documentElement.clientWidth;  html.style.fontSize = (clientWidth / designWidth) * base + &#x27;px&#x27;;};document.addEventListener(&#x27;DOMContentLoaded&#x27;, function () {  fn();});window.onresize = function () {  fn();};弊端和根元素 font-size 值强耦合，系统字体放大或缩小时，会导致布局错乱html 文件头部需插入一段 js 代码相较之下，vw 单位兼容性比 rem 稍差，ios8、安卓 4.4 及以上才完全支持。这也是为什么之前 rem 布局一直更流行的原因。目前 ios8、安卓 4.4 以下的用户已经非常少了，caniuse 上面显示，在中国这部分用户只有 1.2%，比例已经非常低了设计稿 px 转 vw 方案（推荐）1vw 表示屏幕宽度的 1%把所有需要适配屏幕大小等比缩放的元素都使用 vw 做为单位。不需要缩放的元素使用 px 做单位举个例子。设计师交付的设计稿宽度是 750px，设计稿上一个标题的 fontSize 标注尺寸是 32px。(32/750)*100% = 4.27% ，换句话说这个标题的字号占屏幕宽度的占比是 4.27%，不管任何屏幕都是如此。4.27% 即 4.27vw。可以使用 post-css 专门的插件做转换，或使用预处理样式语言中的函数@baseScreenWidth: 320;.px2vw(@name, @px) {  @{name}: (@px / @baseScreenWidth) * 100vw;}@function px2vw($px) {  @return $px * 100vw / 750;}// 以iphone7尺寸@2x 750像素宽的视觉稿为例@function vw($px) {  @return ($px / 750) * 100vw;}// 假设一个div元素在视觉稿中，宽度为120px，字体大小为12pxdiv {  width: vw(120);  font-size: vw(12);}dpr 是什么设备像素比，通过 window.devicePixelRatio 获取是设备上物理像素和设备独立像素（dips）的比例，window.devicePixelRatio = 物理像素 / dips简单的讲其实就是 dpr 决定了 css 1px 等于多少屏幕物理像素物理像素显示器上最小的物理显示单元，在操作系统的调度下，每一个设备像素都有自己的颜色值和亮度值设备独立像素（dips）也叫密度无关像素，可以认为是计算机坐标系统中得一个点，这个点代表一个可以由程序使用的虚拟像素（比如: css 像素），然后由相关系统转换为物理像素viewport用于定义视口的各种行为：视口宽度、初始缩放、最小最大缩放比例、是否允许用户手动缩放解决设备屏幕宽高比差异问题https://developer.mozilla.org/en-US/docs/Web/CSS/aspect-ratiohttps://developer.mozilla.org/en-US/docs/Web/CSS/@media/device-aspect-ratio"}]},{"id":"07405a1e638d890ec4968814c210740b","dirname":"前端技术","filename":"","basename":"","path":"/home/runner/work/qxtang.github.io/qxtang.github.io","children":[{"id":"65251720ce93a86e0baf484ea8ff1fd2","filename":"AST抽象语法树.md","basename":"AST抽象语法树","path":"/home/runner/work/qxtang.github.io/qxtang.github.io/前端技术","content":"AST 抽象语法树参考https://segmentfault.com/a/1190000016231512https://juejin.cn/post/6844903725228621832解析器 Parser把 js 源码转化为抽象语法树（AST）常用解析器https://github.com/babel/babel/tree/master/packages/babel-parserhttps://github.com/acornjs/acorn解析步骤两步：词法分析、语法分析词法分析把字符串形式的代码转换为 令牌（tokens）流，可以把令牌看作是一个扁平的语法片段数组例如：// 源n * n;// 词法分析结果[  { type: { ... }, value: &quot;n&quot;, start: 0, end: 1, loc: { ... } },  { type: { ... }, value: &quot;*&quot;, start: 2, end: 3, loc: { ... } },  { type: { ... }, value: &quot;n&quot;, start: 4, end: 5, loc: { ... } },]每一个 type 有一组属性来描述该令牌：const token = {  type: {    label: &#x27;name&#x27;,    keyword: undefined,    beforeExpr: false,    startsExpr: true,    rightAssociative: false,    isLoop: false,    isAssign: false,    prefix: false,    postfix: false,    binop: null,    updateContext: null,  },};语法分析根据词法分析的结果，也就是令牌 tokens，将其转换成 AST// 源function square(n) {  return n * n;}// ATSconst ast = {  type: &#x27;FunctionDeclaration&#x27;,  id: {    type: &#x27;Identifier&#x27;,    name: &#x27;square&#x27;,  },  params: [    {      type: &#x27;Identifier&#x27;,      name: &#x27;n&#x27;,    },  ],  body: {    type: &#x27;BlockStatement&#x27;,    body: [      {        type: &#x27;ReturnStatement&#x27;,        argument: {          type: &#x27;BinaryExpression&#x27;,          operator: &#x27;*&#x27;,          left: {            type: &#x27;Identifier&#x27;,            name: &#x27;n&#x27;,          },          right: {            type: &#x27;Identifier&#x27;,            name: &#x27;n&#x27;,          },        },      },    ],  },};应用IDE 使用，如代码风格检测(eslint 等)、代码的格式化，代码高亮，代码错误等等代码的混淆压缩转换代码工具，如 babelvue 模板编译过程prettierbabel-plugin-import将 antd 组件 import 语句转换成按需引入写法的 babel 插件"},{"id":"4f33420293c9962d59b3bea05fc9da86","filename":"Babel.md","basename":"Babel","path":"/home/runner/work/qxtang.github.io/qxtang.github.io/前端技术","content":"Babel概念一个 JavaScript 翻译器将 ECMAScript 2015+ 语法编写的代码转换为向后兼容的 JavaScript 语法，以便能够运行在各种环境中通过 Polyfill 方式在目标环境中添加缺失的特性 （通过引入第三方 polyfill 模块，例如 core-js）基本工作原理第 1 步 解析（Parse）通过解析器 babylon 将代码解析成抽象语法树，包括词法分析和语法分析，词法分析主要把字符流源代码（Char Stream）转换成令牌流（ Token Stream），语法分析主要是将令牌流转换成抽象语法树第 2 步 转换（TransForm）通过 babel-traverse plugin 对抽象语法树进行深度优先遍历，遇到需要转换的，就直接在 AST 对象上对节点进行添加、更新及移除操作，比如遇到箭头函数，就转换成普通函数，最后得到新的 AST 树第 3 步 生成（Generate）通过 babel-generator 将 AST 树生成 es5 代码，同时也能创建 Source Map 映射配置主要分为 presets 和 plugins.babelrc._ 和 babel.config._ 区别.babelrc._ 仅适用于项目的某个部分babel.config._ 会影响整个项目中的代码，包含 node_modules 中的代码推荐使用 babel.config._，Babel 自身使用的就是这种格式presets逆序处理，从后往前，这主要是为了确保向后兼容，由于大多数用户将 &quot;es2015&quot; 放在 &quot;stage-0&quot; 之前，可以是数组、对象、字符串{  &quot;presets&quot;: [    &quot;presetA&quot;, // bare string    [&quot;presetA&quot;], // wrapped in array    [&quot;presetA&quot;, {}] // 2nd argument is an empty options object  ]}useBuiltIns{  &quot;presets&quot;: [    [      &quot;@babel/preset-env&quot;,      {        &quot;useBuiltIns&quot;: &quot;usage&quot;,        &quot;debug&quot;: true,        &quot;corejs&quot;: 3 // 建议使用 3，core-js@2 分支中已经不会再添加新特性，新特性都会添加到 core-js@3      }    ]  ]}babel 在转译的时候，会将源代码分成 syntax（语法） 和 api 两部分来处理，语法处理通过配置 presets，babel 使用 polyfill 来处理 api，@babel/preset-env 中有一个配置选项 useBuiltIns，用来告诉 babel 如何处理 api，由于这个选项默认值为 false，即不处理 api，所以代码转译后默认没有处理 api，可以通过手动引入 polyfill，但是 polyfill 没有动态引入会增加包的体积设置 useBuiltIns 的值为 &quot;entry&quot;，同时在源代码的最上方手动引入 @babel/polyfill 这个库（该库一共分为两部分，第一部分是 core-js，第二部分是 regenerator-runtime。其中 core-js 为其他团队开源的另一个独立项目），此时 babel 根据项目 browserslist，引入浏览器不兼容的 polyfill。需要在入口文件手动添加 import '@babel/polyfill'，会自动根据 browserslist 替换成浏览器不兼容的所有 polyfill将 useBuiltIns 改为 &quot;usage&quot;，babel 就可以按需加载 polyfill，并且不需要手动引入 @babel/polyfill存在的问题polyfill 会直接在全局对象上定义方法，比如 Array.include，众所周知前端开发不鼓励污染全局变量，babel 会向翻译后的每一个文件原地定义许多帮助函数，用于转义语法，比如 __spreadArray、__generator,plugins本质是一个 JS 程序, 指示 Babel 如何对代码进行转换排列顺序很重要plugins 在 presets 之前运行plugins 顺序从前往后排列，与 presets 相反核心与其周边@babel/corebabel 使用了微内核的架构风格，也就是说它们的核心非常小，大部分功能都是通过插件扩展实现的，@babel/core 就是这个内核，包含核心功能作用：加载和处理配置(config)加载插件调用 Parser 进行语法解析，生成 AST调用 Traverser 遍历 AST，并使用访问者模式应用'插件'对 AST 进行转换生成代码，包括 SourceMap 转换和源代码生成@babel/cli命令行工具@babel/plugin-transform-runtime、@babel/runtime这个插件就是为了解决 useBuiltIns polyfill 污染全局的问题和每一个文件都有辅助函数问题，将 babel 转译时添加到文件中的内联辅助函数统一隔离到 babel-runtime 提供的 helper 模块中编译时，直接从 helper 模块加载，不在每个文件中重复的定义辅助函数，从而减少包的尺寸其中 @babel/plugin-transform-runtime 的作用是转译代码，转译后的代码中可能会引入 @babel/runtime-corejs3 里面的模块。前者运行在编译时，后者运行在运行时。类似 polyfill，后者需要被打包到最终产物里在浏览器中运行@babel/plugin-transform-runtime 通常仅在开发时使用，但是运行时最终代码需要依赖 @babel/runtime，所以 @babel/runtime 必须要作为生产依赖被安装typescript 的 importHelpers 配置和 tslib 也是类似的原理安装：$ yarn add @babel/plugin-transform-runtime -D$ yarn add @babel/runtime-corejs3修改配置如下：{  &quot;presets&quot;: [    [      &quot;@babel/preset-env&quot;      // 移除，否则和下面重复了      // {      //   &quot;useBuiltIns&quot;: &quot;usage&quot;,      //   &quot;debug&quot;: true      // }    ]  ],  &quot;plugins&quot;: [    [      &quot;@babel/plugin-transform-runtime&quot;,      {        &quot;corejs&quot;: 3 // 指定 runtime-corejs 的版本，目前有 2 3 两个版本      }    ]  ]}引入了这个插件后：api 从之前的直接修改原型改为了从一个统一的模块中引入，避免了对全局变量及其原型的污染helpers 从之前的原地定义改为了从一个统一的模块中引入，使得打包的结果中每个 helper 只会存在一个@babel/parser将源代码解析为 AST已经内置支持很多语法. 例如 JSX、Typescript、Flow、以及最新的 ECMAScript 规范@babel/traverse实现了访问者模式，对 AST 进行遍历，转换插件会通过它获取感兴趣的 AST 节点，对节点继续操作@babel/generator将 AST 转换为源代码，支持 SourceMap@babel/preset-env语法转换插件的集合可以根据目标浏览器运行环境配置（browserslist、targets），将 ES2015+ 的语法转换为 es5 语法，不需要一个个语法插件去安装（比如@babel/plugin-transform-arrow-functions）core.js新 api 集合@babel/polyfill@babel/polyfill 融合了 core-js 和 regenerator-runtime，因此 babel-polyfill 本质就是 corejs引入 @bable/polyfill 就相当于在代码中引入下面两个库import &#x27;core-js/stable&#x27;;import &#x27;regenerator-runtime/runtime&#x27;;官方提示已经 deprecated，推荐使用 core-js@3 + @babel/preset-env 即可🚨 As of Babel 7.4.0, this package has been deprecated in favor of directly including core-js/stable (to polyfill ECMAScript features) and regenerator-runtime/runtime (needed to use transpiled generator functions)regenerator-runtime生成器函数、async、await 函数经 babel 编译后，regenerator-runtime 模块用于提供功能实现，运行时依赖，需要打包进产物"},{"id":"da1cb124c51c98d0dd90ce9db78aa2dc","filename":"React源码学习.md","basename":"React源码学习","path":"/home/runner/work/qxtang.github.io/qxtang.github.io/前端技术","content":"React 源码学习参考https://pomb.us/build-your-own-react/https://github.com/Hazlank/blog/issues/13"},{"id":"d3c9e089dd008e2d59c32305f690bbb7","filename":"微前端.md","basename":"微前端","path":"/home/runner/work/qxtang.github.io/qxtang.github.io/前端技术","content":"微前端微前端不一定是一种新技术，也不必太复杂。只要我们保证代码隔离和团队自治，无论我们采用何种技术栈，我们都可以达到相同的效果由来工程越来越大，打包越来越慢团队人员多，产品功能复杂，代码冲突频繁、影响面大在后端服务开发中，为了解决庞大的一整块后端服务带来的变更与扩展方面的限制，出现了微服务架构把应用程序设计成一系列松耦合的细粒度服务允许使用不同的编程语言来编写不同服务前端也出现这样的问题，即，一种由独立交付的多个应用组成整体的架构风格。将前端应用分解成一些更小更简单的能够独立开发、测试、部署的小块，而在用户看来仍然是内聚的单个产品比起一整块的前端代码库，微前端架构下的代码库倾向于更小/简单、更容易开发传统开发的缺点历史项目，祖传代码交付压力，当时求快就近就熟，当时求稳导致技术栈落后，甚至强行混用多种技术栈，耦合混乱，不敢动，牵一发动全身每个微前端都应具备有自己的持续交付流水线（包括构建、测试并部署到生产环境），且要能独立部署，不必过多考虑其它代码库的状态意义技术栈无关，主框架不限制接入应用的技术栈，微应用具备完全自主权独立开发、独立部署，微应用仓库独立，前后端可独立开发，部署完成后主框架自动完成同步更新增量升级，在面对各种复杂场景时，我们通常很难对一个已经存在的系统做全量的技术栈升级或重构，而微前端是一种非常好的实施渐进式重构的手段和策略独立运行时，每个微应用之间状态隔离，运行时状态不共享微前端架构旨在解决单体应用在一个相对长的时间跨度下，由于参与的人员、团队的增多、变迁，从一个普通应用演变成一个巨石应用后，随之而来的应用不可维护的问题。这类问题在企业级 Web 应用中尤其常见。技术方案package 集成将每个微前端发布为一个 npm 包，并让容器应用程序将所有微前端应用作为依赖项这意味着只要有一个包更新，即使是小版本，宿主也要重新构建一次。不建议使用这种方案iframe优点：隔离得很彻底缺点：速度慢，浏览器处理 iframe 要启动更多的进程；页面刷新难以保存状态，路由、历史记录等等使用 umd 包通过 script 标签引入放在 cdn 上的资源，可以始终保持最新，子应用更新不需要通知宿主具有完全的灵活性，宿主可以控制什么时候载入每个应用，以及渲染应用时额外传参数微前端架构存在的一些普遍问题下载量独立构建的 JavaScript 文件可能导致重复的公共依赖，从而增加用户的下载量例如，如果每个微应用都包括自己的 React 副本，那么用户就得多次下载 React环境差异在本地开发时无法把所有微应用和对应的后端都启动起来，不得不在本地进行环境的简化。如果开发环境和生产环境不严谨一致，容易造成问题。如果开发者想要完全模拟生产环境，会比较耗时治理复杂性要管理更多的东西：更多的代码库、更多的工具、更多的构建管道、更多的服务器、更多的域名等"},{"id":"2227cf216416fc887bc6ecb4f95596a7","filename":"性能优化.md","basename":"性能优化","path":"/home/runner/work/qxtang.github.io/qxtang.github.io/前端技术","content":"性能优化代码层面缓存 dom 查找结果用 innerHTML 代替 DOM 操作，减少 DOM 操作次数不频繁修改 DOM如果要修改 DOM 的多个样式可以用 cssText 一次性将要改的样式写入，或将样式写到 class 里，再修改 DOM 的 class 名称// badconst el = document.querySelector(&#x27;.myDiv&#x27;);el.style.borderLeft = &#x27;1px&#x27;;el.style.borderRight = &#x27;2px&#x27;;el.style.padding = &#x27;5px&#x27;;// goodconst el = document.querySelector(&#x27;.myDiv&#x27;);el.style.cssText += &#x27;border-left: 1px; border-right: 2px; padding: 5px;&#x27;;// cssText会覆盖已存在的样式，所以使用 +=列表绑定事件，使用事件委托如无必要，不要重写原生方法，因为原生方法底层是用 C/C++实现的，速度更快CSS 能做的事情，尽量不用 JS 来做避免 css 表达式比如 calcwebpack、babel 层面webpack 按需加载，React.lazy + import()，Webpack 4 之后，只需要用异步语句 require.ensure(&quot;./xx.js&quot;) 或 import(&quot;./xx.js&quot;) 方式引入模块，就可以实现模块的动态加载，这种能力本质也是基于 Chunk 实现的，遇到异步引入语句时会为该模块单独生成一个 chunkwebpack 配置 external，将通用库抽离，不打包进 bundle，比如 jquery、lodash，使用 CDN，并开启强缓存配置 babel 动态 polyfill，只针对不支持的浏览器引入 polyfill配置 file-loader，使小图使用 base64借助 webpack-bundle-analyzer 工具分析打包出的文件包含哪些，大小占比如何，模块包含关系webpack 的 tree-shaking 删除多余代码antd 按需加载，babel-plugin-importwebpack 拆包优化其他不常修改的资源（jquery），开启强缓存优化，配置响应头 Cache-Control 与 Expires减少 http 请求次数：雪碧图、小图片使用字体图标代替css 放顶部、js 放底部，非关键性的脚本（比如百度统计），script 标签加上 defer 或者 async单页应用首屏加载放个 loading，优化用户感知，利用一些过渡效果、骨架屏使用 link 标签的 rel 属性，设置 prefetch、preload（preload 将会把资源得下载顺序权重提高，使得关键数据提前下载好，优化页面打开速度）注意项目中是否使用了字体，字体加载也会让首屏加载变得很慢压缩 js、css 代码减少 cookie 的体积使用公共 CDN，好处：如果其他网站刚好也用过同一个资源，会得到缓存服务端开启 gzip（gzip 只对文本文件有效，比如 js、css，流文件无效，比如图片）路由懒加载图片懒加载将静态资源放在其他域名的原因（CDN）浏览器对于相同域名有并发请求数限制请求时不会发送 cookie，节省了流量cookie 会发送给二级域名，所以这些静态资源不放在二级域名，放在单独一级域名script 标签的 defer 和 async没有 defer 或 async 属性，浏览器会立即加载并执行相应的脚本async：立即下载，下载完立即执行，不确定顺序执行。对于完全独立的脚本来才去使用 async，比如谷歌统计百度统计。一定会在页面的 load 事件前执行，但不确定在 DOMContentLoaded 事件触发前后执行。defer：立即下载，将延迟到整个页面都解析完毕后再运行js 为什么放最下面？当文档加载过程中遇到 js 文件，html 文档会挂起渲染（加载解析渲染同步）的线程，不仅要等待文档中 js 文件加载完毕，还要等待解析执行完毕，才可以恢复 html 文档的渲染线程，因为 JS 有可能会修改 DOM，比如 document.write，这意味着，在 JS 执行完成前，后续所有资源的下载可能是没有必要的，这是 js 阻塞后续资源下载的原因。所以平时的代码中，js 是放在 html 文档末尾的css 为什么放最上面？CSS 不会阻塞 DOM 的解析，但会阻塞 DOM 渲染css 是由单独的下载线程异步下载的但会阻塞 render 树渲染（渲染时需等 css 加载完毕，因为 render 树需要 css 信息）gzip只对文本文件有效，比如 js、css，流文件无效，比如图片需要客户端和服务端的同时支持客户端支持：请求头中有个 Accept-Encoding 来标识对压缩的支持，content-encoding: gzip服务端支持：能够返回经过 gzip 压缩的文件重绘（repaint）与回流（reflow）重绘：当元素样式的改变不影响布局时，触发重绘，此时由于只需要 UI 层面的重新像素绘制，因此 损耗较少。回流、重排：当元素的尺寸、结构或触发某些属性时，触发回流。此时，浏览器需要重新经过计算，计算后还需要重新页面布局，因此是较耗性能的操作。触发回流的操作：页面初次渲染浏览器窗口大小改变元素尺寸、位置、内容发生改变元素字体大小变化添加或者删除可见的 dom 元素激活 CSS 伪类（例如：:hover）查询某些属性或调用某些方法回流必定触发重绘，重绘不一定触发回流。重绘的开销较小，回流的代价较高。如何避免触发回流和重绘CSS：避免使用 table 布局。尽可能在 DOM 树的最末端改变 class。避免设置多层内联样式。将动画效果应用到 position 属性为 absolute 或 fixed 的元素上避免使用 CSS 表达式（例如：calc()）CSS3 硬件加速（GPU 加速）JavaScript：避免频繁操作样式，最好一次性重写 style 属性，或者将样式列表定义为 class 并一次性更改 class 属性避免频繁操作 DOM，创建一个 documentFragment，在它上面应用所有 DOM 操作，最后再把它添加到文档中也可以先为元素设置 display: none，操作结束后再把它显示出来。因为在 display 属性为 none 的元素上进行的 DOM 操作不会引发回流和重绘避免频繁读取会引发回流/重绘的属性或方法（offsetTop、offsetLeft、offsetWidth、offsetHeight、getBoundingClientRect 等），如果确实需要多次使用，就用一个变量缓存起来对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流requestAnimationFrame使用一个回调函数作为参数。这个回调函数会在浏览器重绘之前调用浏览器用于定时循环操作的一个接口，类似于 setTimeout，主要用途是按帧对网页进行重绘设置这个 API 的目的是为了让各种网页动画效果（DOM 动画、Canvas 动画、SVG 动画、WebGL 动画）能够有一个统一的刷新机制，从而节省系统资源，提高系统性能，改善视觉效果代码中使用这个 API，就是告诉浏览器希望执行一个动画，让浏览器在下一个动画帧安排一次网页重绘优势在于可以充分利用显示器的刷新机制，比较节省系统资源显示器有固定的刷新频率（60Hz 或 75Hz），也就是说，每秒最多只能重绘 60 次或 75 次，requestAnimationFrame 的基本思想就是与这个刷新频率保持同步cancelAnimationFrame 用于取消重绘，它的参数是 requestAnimationFrame 返回的一个代表任务 ID 的整数值为了提高性能和电池寿命，因此在大多数浏览器里，当 requestAnimationFrame() 运行在后台标签页或者隐藏的 &lt;iframe&gt; 里时，requestAnimationFrame() 会被暂停调用以提升性能和电池寿命当浏览器渲染线程被过度占用时这个 API 调用间隔会非常不稳定，它并不是银弹使用：function test(timestamp) {  console.log(timestamp);  requestAnimationFrame(test);}requestAnimationFrame(test);如何判断一个页面卡顿的原因内存泄漏，由于疏忽或者程序的某些错误造成未能释放已经不再使用的内存的情况（比如不再使用的变量额外创建）Chrome devTools Performance 查看内存情况打开 Chrome 的无痕模式，这样做的目的是为了屏蔽掉 Chrome 插件对我们之后测试内存占用情况的影响"}]},{"id":"6e812ab51a7eb39b3c4495548c8b8868","filename":"css世界、css新世界读书笔记.md","basename":"css世界、css新世界读书笔记","path":"/home/runner/work/qxtang.github.io/qxtang.github.io","content":"更新中..."},{"id":"index","filename":"index.md","basename":"index","path":"/home/runner/work/qxtang.github.io/qxtang.github.io","content":"✒ 工作与日常学习笔记via：doc-builder"}]