[{"id":"d04c16bcfbdfba8c24c5ad9cf75efe27","dirname":"Javascript","filename":"","basename":"","path":"/home/runner/work/qxtang.github.io/qxtang.github.io","children":[{"id":"b7acc861eaf47e03b0a92a42651c79c8","isRootIndexFile":false,"isIndexFile":false,"filename":"Promise.md","basename":"Promise","path":"/home/runner/work/qxtang.github.io/qxtang.github.io/Javascript","content":"Promise描述解决 es5 回调地狱实例化 Promise：传入一个函数，代码在这个函数中执行，这个函数接收两个参数 resolve 和 reject，当作函数来执行设置成功：在函数中调用 resolve 函数把 Promise 的状态变为成功，通过参数把结果传递出去，能在这个 Promise 对象的 then 方法中获取结果，then 方法可以链式调用多次，then 方法接受一个函数作为参数，这个函数的参数就是 resolve 传递出来的结果设置失败：在函数中调用 reject 函数把 Promise 的状态变为失败，用法同 resolve，能在这个 Promise 对象的 catch 方法中获取结果无论结果如何都会走 finally 方法Promise.all：接受一个数组作为参数（都是 Promise 实例），调用 Promise.all 的时候，这些实例会一起开始执行，返回一个结果数组，只有全部实例的状态是成功，结果的状态才会是成功，只要有一个失败，结果就是失败Promise.race：接受一个数组作为参数（都是 Promise 实例），返回一个结果数组，调用 Promise.race 的时候，传进去的实例是竞赛关系，哪个结果获得的快，就返回哪个结果Promise.resolve()：直接返回一个成功状态的 Promise 对象，接受一个参数，这个参数可以是：成功的结果\\Promise 实例\\不带有参数Promise.reject()：失败，同上Promise 实现链式调用原理每个方法其实都是返回一个新的 Promise 对象promise.catch 是不是微任务是的"},{"id":"4c24e2cb0810d551ab2bdfd7f7965355","isRootIndexFile":false,"isIndexFile":false,"filename":"Proxy 和 Reflect.md","basename":"Proxy 和 Reflect","path":"/home/runner/work/qxtang.github.io/qxtang.github.io/Javascript","content":"Proxy 和 Reflect通过 Proxy 创建对象的代理对象，在代理对象中使用 Reflect 达到对于 JavaScript 原始操作的拦截Proxy 为什么需要 Reflect 来配合简化 Proxy 的创建统一将 Object 的一些明显属于语言内部的方法（比如 Object.defineProperty），放到 Reflect 对象上。现阶段，某些方法同时在 Object 和 Reflect 对象上部署，未来的新方法将只部署在 Reflect 对象上。也就是说，从 Reflect 对象上可以拿到语言内部的方法。统一某些 Object 方法的返回结果，让其变得更合理。比如，Object.defineProperty(obj, name, desc)在无法定义属性时，会抛出一个错误，而 Reflect.defineProperty(obj, name, desc)则会返回 false让 Object 操作都统一变成函数行为。某些 Object 操作是命令式，比如 name in obj 和 delete obj[name]，而 Reflect.has(obj, name)和 Reflect.deleteProperty(obj, name)让它们变成了函数行为Reflect 对象的方法与 Proxy 对象的方法一一对应，只要是 Proxy 对象的方法，就能在 Reflect 对象上找到对应的方法。这就让 Proxy 对象可以方便地调用对应的 Reflect 方法，完成默认行为，作为修改行为的基础。也就是说，不管 Proxy 怎么修改默认行为，你总可以在 Reflect 上获取默认行为Proxy 的局限性一些内置对象具有“内部插槽”，对这些对象的访问无法被代理let map = new Map();let proxy = new Proxy(map, {});proxy.set(&#x27;test&#x27;, 1); // Error解决：let map = new Map();let proxy = new Proxy(map, {  get(target, prop, receiver) {    let value = Reflect.get(...arguments);    return typeof value == &#x27;function&#x27; ? value.bind(target) : value;  },});proxy.set(&#x27;test&#x27;, 1);alert(proxy.get(&#x27;test&#x27;)); // 1私有字段私有字段是通过内部插槽实现的，在调用 getName() 时，this 的值是代理后的 user，它没有带有私有字段的插槽class User {  #name = &#x27;Guest&#x27;;  getName() {    return this.#name;  }}let user = new User();user = new Proxy(user, {});alert(user.getName()); // Error解决：// 该解决方案也有缺点：它将原始对象暴露给该方法，可能使其进一步传递并破坏其他代理功能class User {  #name = &#x27;Guest&#x27;;  getName() {    return this.#name;  }}let user = new User();user = new Proxy(user, {  get(target, prop, receiver) {    let value = Reflect.get(...arguments);    return typeof value == &#x27;function&#x27; ? value.bind(target) : value;  },});alert(user.getName()); // Guest无法拦截严格相等性检查 ===使用示例// 要包装的对象let target = {};// 代理配置const handler = {  // 拦截写入  set(target, prop, val, receiver) {    return Reflect.set(target, prop, val, receiver);  },  // 拦截读取  get(target, prop, receiver) {    return Reflect.get(target, prop, receiver);  },};// 代理对象let proxy = new Proxy(target, handler);可撤销 Proxylet object = {  data: &#x27;Valuable data&#x27;,};let { proxy, revoke } = Proxy.revocable(object, {});alert(proxy.data); // Valuable datarevoke();alert(proxy.data); // Error"},{"id":"cba08ec3eed650e75ecc9b68be1e625b","isRootIndexFile":false,"isIndexFile":true,"filename":"index.md","basename":"Javascript","path":"/home/runner/work/qxtang.github.io/qxtang.github.io/Javascript","content":"JavascriptString 原生方法substr(start[, length])：deprecated，同 slice/substringsplit([separator[, limit]])：按照给定规则分割字符串，返回一个由分割出来的子字符串组成的数组 '1,2,3' =&gt; [1, 2, 3]substring(indexStart[, indexEnd])：返回字符串在开始索引到结束索引之间的一个子集，或从开始索引直到字符串末尾的一个子集slice(beginIndex[, endIndex])：提取字符串一部分，返回一个新的字符串，不会改动原字符串Array 原生方法push(element1, ..., elementN)：在数组末端添加一个/多个元素，返回添加结果数组 length，改变原数组pop()：删除数组最后一个元素，返回该元素，改变原数组shift()：删除数组第一个元素，返回该元素，改变原数组unshift(element1, ..., elementN)：在数组的第一个位置添加元素，返回添加新元素后的数组 length，改变原数组join([separator])：以指定参数作为分隔符，将所有数组成员连接为一个字符串返回，如果不提供参数，默认用逗号分隔，[1, 2, 3] =&gt; '1,2,3'slice([begin[, end]])：提取数组的一部分，返回一个新数组，不改变原数组splice(start[, deleteCount[, item1[, item2[, ...]]]])：删除原数组的一部分成员，并可以在删除的位置添加新的成员，返回被删除的元素，改变原数组遍历迭代方法：for in 顺序遍历一个对象自有的、继承的、可枚举的、非 Symbol 的属性。对于每个不同的属性，语句都会被执行如果只考虑对象本身的属性，而不是它的原型，那么使用 getOwnPropertyNames() 或 hasOwnProperty() 来确定属性是否是对象本身的。for of ES6 新增，替代 for in 和 forEach，可以遍历 Array，String，Map，Set 等可迭代数据结构forEach 遍历数组每一项，没有返回值，对原数组没有影响，注意：在 forEach 中用 return 不会返回，break 不会跳出，函数会继续执行map 返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值flat 将嵌套的数组“拉平”，变成一维的数组，返回一个新数组，不改变原数组，默认只会“拉平”一层，如果想要“拉平”多层的嵌套数组，可以将 flat() 方法的参数写成一个整数flatMap 对原数组的每个成员执行一个函数（相当于 map），然后对返回值组成的数组执行 flat() 方法。返回一个新数组，不改变原数组，只能展开一层数组filter 返回通过过滤的元素，不改变原数组some 检测数组中某个元素是否满足指定条件，返回 boolean 值，不改变原数组every 检测数组中所有元素是否符合指定条件，返回 boolean 值，不改变原数组reduce 接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值reduceRight 同 reduce，方向相反find 返回通过测试（函数内判断）的数组的第一个元素的值forEach、for in、for of 区别forEach 更多的用来遍历数组for in 一般常用来遍历对象或 jsonfor of 数组对象都可以遍历，遍历对象需要通过和 Object.keys()for in 循环出的是 key，for of 循环出的是 value类数组对象拥有 length 属性，length-0 可隐式转换为 number 类型var a = { 1: &#x27;gg&#x27;, 2: &#x27;love&#x27;, 4: &#x27;meimei&#x27;, length: 5 };类数组对象转数组：Array.prototype.slice.call(arrLike);Array.from(arrLike);内置对象BigIntURL 对象ErrorMathDateRegExpProxy\\ReflectURL 对象：提供用于创建和解析 URLDOM 变动观察器（Mutation observer）：观察 DOM 元素，并在检测到更改时触发回调ES6 新特性箭头函数Promise扩展运算符和解构赋值对象和数组解构let const模板字符串函数的参数默认值classfor of 和 for in模块尾调用优化 TCOvar let constlet 和 const 具有块级作用域，var 不存在块级作用域const 声明常量，不能修改，声明的对象，属性可以被修改用 var 重复声明不会报错，但 let 和 const 会var 会使变量提升，变量可以在 var 声明之前使用。let 和 const 不会使变量提升，提前使用会报错深浅拷贝浅拷贝: 以赋值形式拷贝引用对象，仍指向同一个地址，修改时原对象也会受到影响，实现：Object.assign 或 展开运算符深拷贝：JavaScript 包含基本类型 和 引用类型基本类型按值访问、引用类型按引用访问直接复制引用类型的值，实际上是同一个内存地址的指针，修改新的变量，原变量也会被修改手写深拷贝：function deepCopy(obj) {  // 判断是否是简单数据类型，  if (typeof obj == &#x27;object&#x27;) {    // 复杂数据类型    var result = obj.constructor == Array ? [] : {};    for (let i in obj) {      result[i] = typeof obj[i] == &#x27;object&#x27; ? deepCopy(obj[i]) : obj[i];    }  } else {    // 简单数据类型 直接赋值    var result = obj;  }  return result;}Generator 函数function 关键字与函数名之间有一个星号函数体内部使用 yield 表达式返回一个指向内部状态的指针对象，是一个遍历器对象调用遍历器对象的 next 方法，使指针移向下一个状态内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个 yield 表达式（或 return 语句）为止next 方法返回一个对象，它的 value 属性是当前 yield 表达式的值，done 属性的值表示遍历是否结束async/awaitasync 用来声明函数，告诉解释器这是一个异步函数，只有 async 声明的函数里面才能用 awaitawait 等待一个 promise 执行结束，可以返回 promise 对象 resolve 出来的结果如果 await 等待的这个 Promise 对象出错或者结果为 reject，可以通过 try catch 捕获到错误实现原理：Generator 函数的语法糖将 Generator 函数和自动执行器，包装在一个函数里async function fn(args) {  // ...}// 等同于function fn(args) {  return spawn(function* () {    // ...  });}spawn 函数就是自动执行器，spawn 函数的实现：function spawn(genF) {  return new Promise(function (resolve, reject) {    const gen = genF();    function step(nextF) {      let next;      try {        next = nextF();      } catch (e) {        return reject(e);      }      if (next.done) {        return resolve(next.value);      }      Promise.resolve(next.value).then(        function (v) {          step(function () {            return gen.next(v);          });        },        function (e) {          step(function () {            return gen.throw(e);          });        }      );    }    step(function () {      return gen.next(undefined);    });  });}apply、call、bind都是用来改变函数 this 的指向区别：apply 和 call 的区别是 call 方法接受的是若干个参数列表，而 apply 接收的是一个包含多个参数的数组bind 方法创建新的函数，在 bind 被调用时，这个新函数的 this 被指定为 bind 的第一个参数，而其余参数将作为新函数的参数，供调用时使用，bind 与 apply/call 一样都能改变函数 this 指向，但 bind 并不会立即执行函数，而是返回一个绑定了 this 的新函数，你需要再次调用此函数才能达到最终执行手写：// callFunction.prototype.myCall = function (context, ...args) {  if (typeof this !== &#x27;function&#x27;) {    throw new Error(&#x27;Type error&#x27;);  }  // 判断 context 是否传入，如果没有传就设置为 window  context = context || window;  // 使用 Symbol 来保证属性唯一  // 保证不会重写用户自己原来定义在 context 中的同名属性  const fnSymbol = Symbol();  // 将被调用的方法设置为 context 的属性  // this 即为我们要调用的方法  context[fnSymbol] = this;  // 将执行结果返回  try {    return context[fnSymbol](...args);  } finally {    // 最后删除手动增加的属性方法    delete context[fnSymbol];  }};var foo = {  value: 1,};function bar() {  console.log(this.value);}bar.call(foo); // 1bar.myCall(foo); // 1// apply// 与 call 相比仅获取参数方式不同// bindFunction.prototype.myBind = function (context, ...args) {  if (typeof this !== &#x27;function&#x27;) {    throw new Error(&#x27;Type error&#x27;);  }  const fn = this;  return function Fn() {    return fn.apply(      this instanceof Fn ? this : context,      // 当前的这个 arguments 是指 Fn 的参数      args.concat(...arguments)    );  };};作用域用来管理引擎如何在当前作用域以及嵌套子作用域中根据标识符名称（变量名或者函数名）进行变量查找作用域类型：全局作用域和函数作用域块级作用域解决 ES5 的问题：内层变量可能覆盖外层变量用来计数的循环变量泄露为全局变量作用域链当访问一个变量时，编译器在执行这段代码时，会首先从当前的作用域中查找是否有这个标识符，如果没找到，就去父作用域查找，如果父作用域还没找到继续向上查找，直到全局作用域为止，作用域链，就是由当前作用域与上层作用域的一系列变量对象组成，保证了当前执行的作用域对符合访问权限的变量和函数的有序访问词法作用域和动态作用域JavaScript 采用词法作用域，也就是静态作用域函数的作用域在函数定义的时候就决定了而与词法作用域相对的是动态作用域，函数的作用域是在函数调用的时候才决定var value = 1;function foo() {  console.log(value);}function bar() {  var value = 2;  foo();}bar();// 1执行上下文当函数执行时，会创建一个称为执行上下文的内部对象一个执行上下文定义了一个函数执行时的环境，函数每次执行时对应的执行上下文都是独一无二的，所以多次调用一个函数会导致创建多个执行上下文，当函数执行完毕，执行上下文被销毁参数传递参数如果是基本类型是按值传递，如果是引用类型按共享传递但是当值是一个复杂的数据结构的时候，拷贝就会产生性能上的问题按值传递把函数外部的值复制给函数内部的参数，就和把值从一个变量复制到另一个变量一样共享传递在传递对象的时候，传递对象的引用的副本假设 arg 是一个对象参数，修改 arg.value，可以通过引用找到原值，但是直接修改 arg，并不会修改原值arguments一个类数组对象，存储传入函数的全部参数callee 属性：当前函数的引用妙用：递归、参数累加为什么 arguments 是类数组：BE 本人也承认 arguments 的设计是因为当时只花了十天所以整得太糙了为什么 ES6 不推荐 arguments.callee()：访问 arguments 是个很昂贵的操作，因为它是个很大的对象，每次递归调用时都需要重新创建。影响浏览器的性能，还会影响闭包当一个函数必须调用自身的时候，假如它是函数表达式则给它命名，或者使用函数声明，避免使用 calleedelete 机制使用 delete 操作符不会直接释放内存，与 V8 引擎有关最有效的方式，应该是将不需要的属性设置为 undefined在实际业务中可以考虑使用 Map 来代替 object，map 包装对象有 delete 方法，比以上方式都快设置一个对象所有属性不能修改Object.preventExtensions()Object.seal() 封闭一个对象，阻止添加新属性并将所有现有属性标记为不可配置，当前属性的值只要原来是可写的就可以改变Object.freeze() 使用 Object.freeze() 冻结的对象中的现有属性值是不可变的。用 Object.seal() 密封的对象可以改变其现有属性值代理对参考：https://zh.javascript.info/string所有常用的字符都是一个 2 字节的代码。大多数欧洲语言，数字甚至大多数象形文字中的字母都有 2 字节的表示形式但 2 字节只允许 65536 个组合，这对于表示每个可能的符号是不够的。所以稀有的符号被称为“代理对”的一对 2 字节的符号编码代理对在 JavaScript 被创建时并不存在，因此无法被编程语言正确处理这些符号的 length 是 2：alert(&#x27;𝒳&#x27;.length); // 2，大写数学符号alert(&#x27;😂&#x27;.length); // 2，部分 emoji 表情alert(&#x27;𩷶&#x27;.length); // 2，罕见的中国象形文字并发控制实现async function asyncPool(poolLimit, array, iteratorFn) {  const ret = []; // 存储所有的异步任务  const executing = []; // 存储正在执行的异步任务  for (const item of array) {    // 调用iteratorFn函数创建异步任务    const p = Promise.resolve().then(() =&gt; iteratorFn(item, array));    ret.push(p); // 保存新的异步任务    // 当poolLimit值小于或等于总任务个数时，进行并发控制    if (poolLimit &lt;= array.length) {      // 当任务完成后，从正在执行的任务数组中移除已完成的任务      const e = p.then(() =&gt; executing.splice(executing.indexOf(e), 1));      executing.push(e); // 保存正在执行的异步任务      if (executing.length &gt;= poolLimit) {        await Promise.race(executing); // 等待较快的任务执行完成      }    }  }  return Promise.all(ret);}function multiRequest(urls = [], maxNum) {  // 请求总数量  const len = urls.length;  // 根据请求数量创建一个数组来保存请求的结果  const result = new Array(len).fill(false);  // 当前完成的数量  let count = 0;  return new Promise((resolve, reject) =&gt; {    // 请求maxNum个    while (count &lt; maxNum) {      next();    }    function next() {      let current = count++;      // 处理边界条件      if (current &gt;= len) {        // 请求全部完成就将promise置为成功状态, 然后将result作为promise值返回        !result.includes(false) &amp;&amp; resolve(result);        return;      }      const url = urls[current];      console.log(`开始 ${current}`, new Date().toLocaleString());      fetch(url)        .then((res) =&gt; {          // 保存请求结果          result[current] = res;          console.log(`完成 ${current}`, new Date().toLocaleString());          // 请求没有全部完成, 就递归          if (current &lt; len) {            next();          }        })        .catch((err) =&gt; {          console.log(`结束 ${current}`, new Date().toLocaleString());          result[current] = err;          // 请求没有全部完成, 就递归          if (current &lt; len) {            next();          }        });    }  });}WeakMap\\Map 区别Map 的键可以是任意类型，WeakMap 只接受对象作为键（null 除外），不接受其他类型的值作为键WeakMap 的键名所指向的对象，不计入垃圾回收机制，设计目的在于，有时想在某个对象上面存放一些数据，但是这会形成对于这个对象的引用。一旦不再需要这两个对象，就必须手动删除这个引用，否则垃圾回收机制就不会释放对象占用的内存Map 的键跟内存地址绑定，只要内存地址不一样，就视为两个键；WeakMap 的键是弱引用，键所指向的对象可以被垃圾回收，此时键是无效的Map 的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键；WeakMap 的键是弱引用，键所指向的对象可以被垃圾回收，此时键是无效的escape\\encodeURI\\encodeURIComponent 区别escape 和它们不是同一类，是对字符串进行编码(而另外两种是对 url)，作用是让它们在所有电脑上可读encodeURI\\encodeURIComponent 唯一区别就是编码的字符范围encodeURIComponent 比 encodeURI 编码的范围更大扩展运算符的应用取出参数对象中的所有可遍历属性，拷贝到当前对象之中合并对象，覆盖对象属性将一个数组转为用逗号分隔的参数序列，且每次只能展开一层数组console.log(...[1, 2, 3]);// 1 2 3console.log(...[1, [2, 3, 4], 5]);// 1 [2, 3, 4] 5合并数组字符串转真数组[...&#x27;hello&#x27;]; // [ &quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot; ]转任何部署了 Iterator 接口的对象为真数组位运算计算机对二进制数据进行的运算，加减乘除等，叫位运算JavaScript 为什么要进行变量提升js 引擎在代码执行前有一个解析的过程，创建了执行上下文，初始化了一些代码执行时需要用到的对象当访问一个变量时，会到当前执行上下文中的作用域链中去查找提高性能 容错性更好解析和执行解析: 检查语法，并对函数进行预编译。解析的时候会先创建一个全局执行上下文环境，先把代码中即将执行的变量、函数声明都拿出来，变量先赋值为 undefined，函数先声明好可使用。在一个函数执行之前，也会创建一个函数执行上下文环境，跟全局执行上下文类似，不过函数执行上下文会多出 this、arguments 和函数的参数执行: 按照代码的顺序依次执行严格模式文件顶部添加 'use strict' 开启意义：消除 Javascript 语法的不合理、不严谨之处，减少怪异行为消除代码运行的不安全之处，保证代码运行的安全提高编译器效率，增加运行速度为未来新版本的 Javascript 做好铺垫区别：禁止使用 with 语句禁止 this 关键字指向全局对象对象不能有重名的属性DOM api创建新节点createDocumentFragment() //创建一个 DOM 片段createElement() //创建一个具体的元素createTextNode() //创建一个文本节点添加、移除、替换、插入appendChild() //添加removeChild() //移除replaceChild() //替换insertBefore() //插入查找getElementsByTagName()getElementsByName()getElementById()document.querySelector()document.querySelectorAll()手写 Ajaxvar xhr = new XMLHttpRequest();xhr.onreadystatechange = function () {  // 通信成功时，状态值为4  if (xhr.readyState === 4) {    if (xhr.status === 200) {      console.log(xhr.responseText);    } else {      console.error(xhr.statusText);    }  }};xhr.onerror = function (e) {  console.error(xhr.statusText);};xhr.open(&#x27;GET&#x27;, &#x27;http://www.example.com/page.php&#x27;, true);xhr.send(null);XMLHttpRequest.readyState 返回一个整数，表示实例对象的当前状态。该属性只读。它可能返回以下值。0，XMLHttpRequest 实例已经生成，但是实例的 open() 方法还没有被调用。1，open() 方法已经调用，但是实例的 send() 方法还没有调用，仍然可以使用实例的 setRequestHeader() 方法，设定 HTTP 请求的头信息。2，实例的 send() 方法已经调用，并且服务器返回的头信息和状态码已经收到。3，正在接收服务器传来的数据体（body ）。这时，如果实例的 responseType 属性等于 text 或者空字符串，responseText 属性就会包含已经收到的部分信息。4，服务器返回的数据已经完全接收，或本次接收已经失败。"},{"id":"a4bcc659f42c0cc2ccf097877b704a61","isRootIndexFile":false,"isIndexFile":false,"filename":"垃圾回收.md","basename":"垃圾回收","path":"/home/runner/work/qxtang.github.io/qxtang.github.io/Javascript","content":"垃圾回收各大浏览器通常用采用的垃圾回收有两种：标记清除、引用计数标记清除（主流）垃圾收集器在运行时给存储在内存中的所有变量加上标记因为只要上下文中的代码在运行，就有可能用到它们从根部出发将能触及到的对象的标记清除还存在标记的变量被视为准备删除的变量销毁带标记的变量引用计数如果一个对象没有被其他对象引用，那它将被垃圾回收机制回收跟踪记录每个值被引用的次数当声明了一个变量并将一个引用类型赋值给该变量时，则这个值的引用次数就是 1相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数就减 1当这个引用次数变成 0 时，则说明没有办法再访问这个值了，因而就可以将其所占的内存空间给收回来缺点：循环引用会造成对象无法被回收如何避免垃圾回收对象尽量复用数组优化：将 [] 赋值给一个数组对象，但是这种方式又创建了一个新的空对象，且将原来的数组对象变成了一小片内存垃圾，实际上，将数组长度赋值为 0（arr.length = 0）也能达到清空数组的目的，并且同时能实现数组重用，减少内存垃圾的产生引起内存泄漏的操作全局变量闭包dom 清除，事件绑定未清除未清除的计时器setTimeout 的第一个参数使用字符串而非函数引用循环：在两个对象彼此引用且彼此保留时，就会产生一个引用循环console.log 打印了太大的变量React 组件卸载后，存在异步回调中调用 setState手动释放内存fn = null【null：空指针对象】"},{"id":"8e72deaaffb1f9d8d7d22ded1dced51d","isRootIndexFile":false,"isIndexFile":false,"filename":"尾调用和尾递归.md","basename":"尾调用和尾递归","path":"/home/runner/work/qxtang.github.io/qxtang.github.io/Javascript","content":"尾调用和尾递归尾调用指某个函数的最后一步是调用另一个函数函数调用会在内存形成一个&quot;调用记录&quot;，又称&quot;调用帧&quot;（call frame），保存调用位置和内部变量等信息所有的调用记录，就形成一个&quot;调用栈&quot;（call stack）尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用记录，因为调用位置、内部变量等信息都不会再用到了应用：优化递归尾递归函数调用自身，称为递归。如果尾调用自身，就称为尾递归递归耗费内存，因为需要保存多个调用记录，容易发生栈溢出错误但对于尾递归，只存在一个调用记录，所以不会发生栈溢出改写方法把所有用到的内部变量改写成函数的参数可以使用柯里化，将多参数的函数转换成单参数的形式// 没有尾递归 复杂度 O(n)function factorial(n) {  if (n === 1) return 1;  return n * factorial(n - 1);}factorial(5);// 改写为尾递归 复杂度 O(1)function factorial(n, total) {  if (n === 1) return total;  return factorial(n - 1, n * total);}factorial(5, 1);// 柯里化function currying(fn, n) {  return function (m) {    return fn.call(this, m, n);  };}function tailFactorial(n, total) {  if (n === 1) return total;  return tailFactorial(n - 1, n * total);}const factorial = currying(tailFactorial, 1);factorial(5);// 使用 es6 默认参数function factorial(n, total = 1) {  if (n === 1) return total;  return factorial(n - 1, n * total);}factorial(5);尾调用仅在严格模式下生效因为在正常模式下，函数内部有两个变量，可以跟踪函数的调用栈：arguments、func.caller尾调用优化发生时，函数的调用栈会改写，因此上面两个变量就会失真。严格模式禁用这两个变量，所以尾调用模式仅在严格模式下生效"},{"id":"9c385c2692f3ff1048c7151d11034f52","isRootIndexFile":false,"isIndexFile":false,"filename":"数据类型.md","basename":"数据类型","path":"/home/runner/work/qxtang.github.io/qxtang.github.io/Javascript","content":"数据类型基本类型：number、string、boolean、undefined、null、Symbol、BigInt引用类型：Object、Array、Function、内置对象（Date、Math 等）BigInt内置对象，提供了对任意长度整数的支持，表示任意大的整数Number.MAX_SAFE_INTEGER（2^53 - 1）是 Javascript 中可以用 Number 表示的最大数字，在这个数范围内不会出现精度丢失（⼩数除外），超过这个范围，js 会出现计算不准确的情况它提供了一种方法来表示大于 Number.MAX_SAFE_INTEGER 的整数BigInt 不支持一元加法BigInt 出现之前需要依靠第三方库创建 bigint：在一个整数字面量后面加 n 或者调用 BigInt 函数const bigint = 1234567890123456789012345678901234567890n;const sameBigint = BigInt(&#x27;1234567890123456789012345678901234567890&#x27;);const bigintFromNumber = BigInt(10); // 与 10n 相同内存管理基本数据类型保存在栈内存中，因为基本数据类型占用空间小、大小固定，通过按值来访问，属于被频繁使用的数据引用数据类型存储在堆内存中，因为引用数据类型占据空间大、占用内存不固定。如果存储在栈中，将会影响程序运行的性能引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体栈内存是一种特殊的线性表，它具有后进先出的特性存放基本类型，占据空间小、大小固定堆内存存放引用类型（在栈内存中存一个基本类型值保存对象在堆内存中的地址，用于引用这个对象）占据空间大、大小不固定类型判断typeof：判断基本类型、函数。不能判断 Null、Object、Array，因为都返回 objectinstanceof：判断对象类型，不能判断基本数据类型，机制是判断在对象原型链中能否找到该类型的原型Object.prototype.toString.call：所有类型都能判断，还有 Error 对象，Date 对象等判断数组Array.isArrayarr.__proto__ === Array.prototypearr instanceof ArrayObject.prototype.toString.callnull 和 undefined 区别null 表示没有对象，即该处不应该有值undefined 表示缺少值，即此处应该有值，但没有定义typeof null 为 objecttypeof undefined 为 undefinednull 和 undefined 转换成 number 数据类型时，null 转成 0 undefined 转成 NaNObject.is 与 ===\\== 区别== 会强转，Object.is 不会强转===\\== 将数字 -0 和 +0 视为相等，而将 Number.NaN 与 NaN 视为不相等，Object.is 反之Number.isNaN 与 isNaN 区别NaN 是一个值，当算术运算返回一个未定义的或无法表示的值时产生，typeof NaN 为 numberisNaN：确定一个值是否为 NaN/只要不是 number 就会返回 trueisNaN 会对传入的值使用 toNumber 转换一次，例如 isNaN('') 为 true，'' 隐式转换为 0Number.isNaN：只有传入的值为 NaN 时才返回 trueNaN == NaN 为什么是 falseNaN 的意思是 Not a Number，那么不是数字的字符肯定不是一个，而是一个范围，一个集合。就好像 A 不是数字，B 也不是数字，但是 A 肯定不是 B 一样。所以综上 NaN 其实是不等于它自身的== 强转规则类型相同直接比较是否在对比 null 和 undefined，是的话就会返回 true是否为 string 和 number，是的话就将 string 转 number其中一方是否为 boolean，是的话就 boolean 转 number其中一方是否为 object 且另一方为 string、number 或者 symbol，是的话就把 object 转为原始类型再进行判断object 转原始类型（ToPrimitive 方法）：先检查该值是否有 valueOf() 方法如果有并且返回基本类型值，就使用该值进行强制类型转换。如果没有就使用 toString() 的返回值来进行强制类型转换如果 valueOf() 和 toString() 均不返回基本类型值，会产生 TypeError 错误其他值到布尔类型的值的转换规则以下这些是 false，除此以外都是 true：undefinednull+0、-0 和 NaN&quot;&quot;精度丢失与浮点数在计算机内部（用二进制存储）的表示方法有关JS 采用 IEEE 754 标准的 64 位双精度浮点数表示法，这个标准是 20 世纪 80 年代以来最广泛使用的浮点数运算标准，为许多 CPU 与浮点运算器所采用，也被很多语言如 java、python 采用。这个标准，会让大部分的十进制小数都不能用二进制浮点数来精确表示（比如转成二进制就会变成无限小数）。所以一般情况下，你输入的十进制小数仅由实际存储在计算机中的近似的二进制浮点数表示。然而，许多语言在处理的时候，在一定误差范围内（通常极小）会将结果修正为正确的目标数字，而不是像 JS 一样将存在误差的真实结果转换成最接近的小数输出解决：使用 Number.EPSILON（误差范围）Number.EPSILON 表示 1 与 Number 可表示的大于 1 的最小的浮点数之间的差值function isEqual(a, b) {  return Math.abs(a - b) &lt; Number.EPSILON;}console.log(isEqual(0.1 + 0.2, 0.3)); // true0.1 + 0.2 为什么不等于 0.3本质是：二进制模拟十进制进行计算时的精度问题进制转换：js 在做数字计算的时候，0.1 和 0.2 被转成二进制后无限循环，但是 js 采用的 IEEE 754 二进制浮点运算，最大可以存储 53 位有效数字，于是大于 53 位后面的会全部截掉，将导致精度丢失对阶运算：由于指数位数不相同，运算时需要对阶运算，阶小的尾数要根据阶差来右移（0 舍 1 入），尾数位移时可能会发生数丢失的情况，影响精度0.2 + 0.3 为什么没有这个问题？："},{"id":"c6b9fd6a48d36ee64ab6ce9417f7b313","isRootIndexFile":false,"isIndexFile":false,"filename":"模块.md","basename":"模块","path":"/home/runner/work/qxtang.github.io/qxtang.github.io/Javascript","content":"模块实现：常用 IIFE 实现模块化：匿名函数自调用，将数据和行为封装到一个函数内部，外部依赖通过参数传入常见规范：ES6 模块（esm）、CommonJS、CMD、AMD什么是 Tree Shaking删除无用代码的算法，集成在 webpack 和 rollup 等打包工具中CommonJS通用环境，比如 nodejs，不局限于浏览器每个模块提供一个 module 变量一个文件一个模块可以动态引入，所以不支持树摇特点：语法相对简单，浏览器不直接支持AMD明确基于浏览器基本退出了历史舞台RequireJS 是 AMD 的一个实现特点：异步加载、同一个文件定义一个模块ESMesm 是 javascript 的标准功能，是语言规范，是官方明确的发展方向，cjs 只是 esm 出来之前的临时解决方案而已相比 cjs 的好处是可以使用 tree shaking，支持静态分析模块脚本自动采用严格模式模块顶层的 this 关键字返回 undefinedesm 是编译时加载，也就是只有所有 import 的模块都加载完成，才会开始执行，这有利于引擎的静态分析，加载的过程会先于代码的执行，却也导致 import 导入语句不能在函数或者 if 语句中执行。es2020 提案引入 import() 函数，用来动态加载模块，并且可以用在函数和 if 语句中模块缓存：同一个模块如果加载多次，只会执行一次export 导出的是值引用，当模块内部的值被修改时，esm 可以获取到被修改后的值，cjs 获取不到CommonJS，ESM 区别都属于不同的模块规范，require 属于 CommonJS 规范，import 属于 ES modulerequire 支持动态导入，import 不支持它们都是一种模块规范，例如 Node 使用的就是 CommonJS 规范。ES module 则是语言标准上的模块规范 区别：CommonJS 模块使用 require() 和 module.exports，ES6 模块使用 import 和 exportCommonJS 模块输出的是一个值的浅拷贝，ES6 模块输出的是值的引用CommonJS 模块是运行时加载，ES6 模块是编译时输出接口，是因为 CommonJS 加载的是一个对象（即 module.exports 属性），该对象只有在脚本运行完才会生成，而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成CommonJS 模块的 require() 是同步加载模块，ES6 模块的 import 命令是异步加载，有一个独立的模块依赖的解析阶段ES6 模块之中，顶层的 this 指向 undefined；CommonJS 模块的顶层 this 指向当前模块UMD通用模块定义规范（Universal Module Definition）可以通过运行时或者编译时让同一个代码模块在使用 CommonJs、CMD 甚至是 AMD 的项目中运行。未来同一个 JavaScript 包运行在浏览器端、服务端甚至是 APP 端都只需要遵守同一个写法就行了是前端实现跨平台技术需求发展下的产物它没有自己专有的规范，是集结了 CommonJs、CMD、AMD 的规范于一身，一个简单实现的例子：((root, factory) =&gt; {  if (typeof define === &#x27;function&#x27; &amp;&amp; define.amd) {    // AMD    define([&#x27;jquery&#x27;], factory);  } else if (typeof exports === &#x27;object&#x27;) {    // CommonJS    var $ = requie(&#x27;jquery&#x27;);    module.exports = factory($);  } else {    // 没有模块环境，直接挂载在全局对象上    root.testModule = factory(root.jQuery);  }})(this, ($) =&gt; {  return {    name: &#x27;我是一个umd模块&#x27;,  };});/*  定义一个 IIFE，  在定义模块的时候检测当前使用环境和模块的定义方式，  将各种模块化定义方式转化为同样一种写法，\t先判断当前环境如果支持 AMD，则使用 require.js 提供的 define 函数定义模块，\t再判断是否 cjs，如果是则使用 cjs 相应的模块定义方法进行模块定义，  如果还需要兼容其他类型的模块系统也是类似思路去兼容，  最后如果没有模块环境，直接挂载在全局对象上，这个传进来的全局对象 this，其值可能是 window 或者 global，视运行环境而定*/"},{"id":"cca3708fb440763c24616b1c2e3c2443","isRootIndexFile":false,"isIndexFile":false,"filename":"闭包.md","basename":"闭包","path":"/home/runner/work/qxtang.github.io/qxtang.github.io/Javascript","content":"闭包函数 A 返回了一个函数 B，并且函数 B 中使用了函数 A 的变量，函数 B 就被称为闭包，函数 A 的执行上下文没有被释放闭包中的变量不保存在栈内存中，而是保存在堆内存中。这也就解释了函数调用之后之后为什么闭包还能引用到函数内的变量能够访问已经被销毁的执行上下文的活动对象的函数、有权访问另一个函数作用域中的变量的函数函数做为参数传递或在尾部 return，并且子函数在外调用，形成闭包，子函数所在的父函数的作用域不会被释放，子函数的作用域中仍然保留着父级的单变量对象和作用域链，因此可以继续访问到父级的变量对象应用：设计私有的方法和变量优点：可以避免全局变量的污染缺点：常驻内存会增大内存使用量，会躲掉垃圾回收机制，使用不当很容易造成内存泄露闭包实现累加function A() {  let start = 0;  function B() {    return ++start;  }  return B;}const inc = A();console.log(inc());console.log(inc());console.log(inc());如何优化闭包通过解除对匿名函数的引用，可以将匿名函数占用的内存安全释（将闭包创建的函数赋值为 null）function outerFun(outerArg) {  return function () {    console.log(&#x27;这里是内部匿名函数&#x27;);    console.log(&#x27;可以访问包含函数的变量&#x27;, outerArg);  };}// 创建一个函数，是 outerFun 中返回的匿名函数var create = outerFun(&#x27;hi&#x27;);// 释放对匿名函数的引用create = null;如果没有对匿名函数的引用，匿名函数执行完之后自动销毁，就可以做到减少占用内存的问题利用匿名函数，制造私有作用域（块级作用域），这样匿名函数执行完之后可以将引用的活动对象销毁"}]},{"id":"785adeeaf391ec96d5bb3f7fae59f68e","dirname":"Typescript","filename":"","basename":"","path":"/home/runner/work/qxtang.github.io/qxtang.github.io","children":[{"id":"42e6798920d6ff44395defafa4f42997","isRootIndexFile":false,"isIndexFile":true,"filename":"index.md","basename":"Typescript","path":"/home/runner/work/qxtang.github.io/qxtang.github.io/Typescript","content":"Typescript强类型 Javascript 超集，支持 ES6 语法，支持面向对象，不直接在浏览器上运行，需要编译器编译成 Javascript 来运行，对 js 进行静态类型检查使工程更严谨、增强可维护性、ide 提示参数校验，利于团队规范有学习成本基础类型number、string、boolean、Array、object、Symbol、Tuple、enum、never、void、null、undefined、anyany 和 unknown 的区别：any 直接放弃类型检查（我不在乎它的类型）unkonwn，类型安全的 any，会对 unknown 类型的变量执行类型检查类型断言不确定类型的时候访问其中一个类型的属性或方法时使用断言类型断言对运行没有影响，仅供编译器使用向编译器提供我们所希望的分析代码的提示表示断言的两种方式：1：&lt;类型&gt;变量 2：变量 as 类型 （在 tsx 中只能使用这种方式）接口可以定义对象、数组、函数、类等为一个变量类型进行命名，定义契约可以相互继承可以继承类可选属性与额外检查装饰器是一种特殊类型的声明，它能被附加在类、方法、属性、访问符、参数上装饰器使用 @expression 这种方式，expression 求值后必须为一个函数，它在运行时调用，被装饰器声明的信息作为参数传入Declare在 .ts 中使用第三方库时没有 .d.ts 声明文件的时候，我们可以通过 declare 来写声明文件可以声明该模块，甚至可以直接声明一个值为 any 的同名的变量，然后我们就可以在代码中直接使用该三方库了tsconfig.json该文件存在于 Typescript 项目的根目录里，其作用是指定相关选项告诉 ts 编译器如何编译 ts 文件所有选项：https://www.tslang.cn/docs/handbook/compiler-options.htmlinfer 的含义声明一个类型变量并且对它进行使用type ReturnType&lt;T&gt; = T extends (...args: any[]) =&gt; infer R ? R : any;project referencesTypeScript 3.0 新功能，允许将 TypeScript 程序构建为更小的部分缩短构建时间，实现组件之间的逻辑分离，以更好方式组织代码https://www.tslang.cn/docs/handbook/project-references.htmlhttps://blog.csdn.net/qiwoo_weekly/article/details/126295762意义：假设 a 模块和 b 模块都很大，编译要很久，但是两者的关联不是特别大。a 模块下的变动基本和 b 模块下的没啥关系，但是 a 变了，b 也要重新编译，b 变了 a 也要重新编译，很没必要使用：模块下各自创建一个 tsconfig.json，要求 compilerOptions.composite 设置为 true在根目录的 tsconfig.json 里加上一个 references 的配置，引入 a 模块 和 b 模块{  &quot;references&quot;: [    {      &quot;path&quot;: &quot;packages/a&quot;    },    {      &quot;path&quot;: &quot;packages/b&quot;    }  ]}执行 tsc --build 进行编译dts 文件使用 js 编写的库的类型声明文件用 ts 写的模块在发布时仍然是用 js 发布，这就导致一个问题：ts 那么多类型数据都没了，所以需要一个 d.ts 文件来标记某个 js 库里面导出对象的类型调用时编辑器能根据这个文件给出提示可以通过 npm 安装对应类库的类型包，https://www.npmjs.com/~types，类型包会安装在 ./node_modules/@types 文件夹中重载定义以多种方式调用的函数定义一组带有参数和返回类型的函数用于实现不同参数输入并且对应不同参数输出的函数function getMessage(id: number): Message | undefined;function getMessage(type: MessageType): Message[];function getMessage(query: any): any {  if (typeof query === &#x27;number&#x27;) {    return data.find((message) =&gt; message.id === query);  } else {    return data.filter((message) =&gt; message.type === query);  }}定义一个 interface，如何依据 a 参数的值来决定 b 参数是否可选？使用联合类型type IParams = { type: &#x27;a&#x27; } | { type: &#x27;b&#x27;; params: string };const a: IParams = { type: &#x27;a&#x27; };const b: IParams = { type: &#x27;b&#x27;, params: &#x27;&#x27; };三斜线指令理解成 import，必须放在文件最顶部已经不推荐"},{"id":"1fdca525eedd483c6becd39c1b3729dc","isRootIndexFile":false,"isIndexFile":false,"filename":"最佳实践.md","basename":"最佳实践","path":"/home/runner/work/qxtang.github.io/qxtang.github.io/Typescript","content":"最佳实践接口命名以大写字母 I 开头，来自：http://wiki.eclipse.org/Naming_Conventions#Classes_and_Interfacestype 类型以大写字母 T 开头类型定义文件(.d.ts)如何放置临时类型，在使用时定义组件个性化类型，定义在 ts(x) 文件中范围/全局数据，定义在 global.d.ts 文件中，并在 tsconfig.json 配置让其生效"},{"id":"13cd8af91bad9a2aa47557b9d5176822","isRootIndexFile":false,"isIndexFile":false,"filename":"模板字面量类型.md","basename":"模板字面量类型","path":"/home/runner/work/qxtang.github.io/qxtang.github.io/Typescript","content":"模板字面量类型TypeScript 4.1 版本新功能提供了连接字符串字面量的能力可以把非字符串基本类型的字面量转换为对应的字符串字面量类型// css 的 margin、padding 属性type Direction = &#x27;left&#x27; | &#x27;right&#x27; | &#x27;top&#x27; | &#x27;bottom&#x27;;type CssPadding = `padding-${Direction}`;type MarginPadding = `margin-${Direction}`;// 实用例子type EventName&lt;T extends string&gt; = `${T}Changed`;type Concat&lt;S1 extends string, S2 extends string&gt; = `${S1}-${S2}`;type ToString&lt;T extends string | number | boolean | bigint&gt; = `${T}`;type T0 = EventName&lt;&#x27;foo&#x27;&gt;; // &#x27;fooChanged&#x27;type T1 = Concat&lt;&#x27;Hello&#x27;, &#x27;World&#x27;&gt;; // &#x27;Hello-World&#x27;type T2 = ToString&lt;&#x27;阿宝哥&#x27; | 666 | true | -1234n&gt;; // &quot;阿宝哥&quot; | &quot;true&quot; | &quot;666&quot; | &quot;-1234&quot;当类型占位符的实际类型是联合类型（A ｜ B ｜ C）的话，就会被自动展开type T3 = EventName&lt;&#x27;foo&#x27; | &#x27;bar&#x27; | &#x27;baz&#x27;&gt;;// &quot;fooChanged&quot; | &quot;barChanged&quot; | &quot;bazChanged&quot;type T4 = Concat&lt;&#x27;top&#x27; | &#x27;bottom&#x27;, &#x27;left&#x27; | &#x27;right&#x27;&gt;;// &quot;top-left&quot; | &quot;top-right&quot; | &quot;bottom-left&quot; | &quot;bottom-right&quot;"},{"id":"d1717ba400642b4a80b534e90d45a089","isRootIndexFile":false,"isIndexFile":false,"filename":"泛型.md","basename":"泛型","path":"/home/runner/work/qxtang.github.io/qxtang.github.io/Typescript","content":"泛型类型变量，由尖括号包裹可以作用在函数、类、接口上可以被约束支持默认类型使用场景函数、接口或类，需要处理多种数据类型时函数、接口或类，在多个地方使用该数据类型时泛型约束确保属性存在没有进行约束，访问属性，会报错：function trace&lt;T&gt;(arg: T): T {  console.log(arg.size); // Error: Property &#x27;size doesn&#x27;t exist on type &#x27;T&#x27;}使用 extends 关键字进行约束：interface Sizeable {  size: number;}function trace&lt;T extends Sizeable&gt;(arg: T): T {  console.log(arg.size);}检查对象上的键是否存在限制输入的属性名包含在 keyof 返回的联合类型中：// 确保参数 key 一定是对象中含有的键function getProperty&lt;T, K extends keyof T&gt;(obj: T, key: K): T[K] {  return obj[key];}条件类型以一个条件表达式进行类型关系检测，从而在两种类型中选择其一：// 若 T 能够赋值给 U，那么类型是 X，否则为 YT extends U ? X : Y通常还会结合 infer 关键字，实现类型抽取：interface Dictionary&lt;T = any&gt; {  [key: string]: T;}type StrDict = Dictionary&lt;string&gt;;type DictMember&lt;T&gt; = T extends Dictionary&lt;infer V&gt; ? V : never;type StrDictMember = DictMember&lt;StrDict&gt;; // string"}]},{"id":"e6087fb36c2e7e45d806a54d447462b2","dirname":"性能优化","filename":"","basename":"","path":"/home/runner/work/qxtang.github.io/qxtang.github.io","children":[{"id":"c477ea9277e72a5e67d59d633cf2c137","isRootIndexFile":false,"isIndexFile":true,"filename":"index.md","basename":"性能优化","path":"/home/runner/work/qxtang.github.io/qxtang.github.io/性能优化","content":"性能优化gzip只对文本文件有效，比如 js、css，流文件无效，比如图片需要浏览器和服务端的同时支持浏览器支持：请求头中添加 accept-encoding，标识对压缩的支持，说明自己接受哪些压缩方法服务端支持：能够返回经过 gzip 压缩的文件，响应头添加 content-encoding: gzip，这个字段用于说明数据的压缩方法服务器实时压缩：可通过配置 nginx 开启，express 框架中有一个 compression 中间件，也可以开启 gzip构建时压缩：可在前端构建时使用 compression-webpack-plugin 插件，减少耗费服务器 CPU 和时间开销https://segmentfault.com/a/1190000012800222Javascript缓存 dom 查找结果用 innerHTML 代替 DOM 操作，减少 DOM 操作次数不频繁修改 DOM如果要修改 DOM 的多个样式可以用 cssText 一次性将要改的样式写入，或将样式写到 class 里，再修改 DOM 的 class 名称// badconst el = document.querySelector(&#x27;.myDiv&#x27;);el.style.borderLeft = &#x27;1px&#x27;;el.style.borderRight = &#x27;2px&#x27;;el.style.padding = &#x27;5px&#x27;;// goodconst el = document.querySelector(&#x27;.myDiv&#x27;);el.style.cssText += &#x27;border-left: 1px; border-right: 2px; padding: 5px;&#x27;;// cssText 会覆盖已存在的样式，所以使用 +=列表绑定事件，使用事件委托如无必要，不要重写原生方法，因为原生方法底层是用 C/C++实现的，速度更快CSS 能做的事情，尽量不用 JS 来做使用 requestAnimationFrameCSS避免 css 表达式比如 calc减少选择层级，最高不超过 3 层尽量使用 class 选择器，避免使用标签选择器少使用后代选择器，后代选择器开销高避免对可继承的属性重复定义避免使用通配规则器 *，只对需要的元素进行处理属性值为 0 时，不加单位webpack压缩 js、css 代码webpack 按需加载，React.lazy + import()，Webpack 4 之后，只需要用异步语句 require.ensure(&quot;./xx.js&quot;) 或 import(&quot;./xx.js&quot;) 方式引入模块，就可以实现模块动态加载，遇到异步引入语句时会为该模块单独生成一个 chunk配置 external，将通用库抽离，不打包进 bundle，比如 jquery、lodash，使用 CDN，并开启强缓存配置 babel 动态 polyfill，只针对不支持的浏览器引入 polyfill配置 file-loader 的 limit 选项，小图转 base64开启 tree-shaking 删除多余代码antd 按需加载，babel-plugin-importwebpack 拆包优化第三方库按需加载动态 polyfill 方案​polyfill.io​​（Polyfill Service）（推荐）是一个 script 资源：https://cdn.polyfill.io/v2/polyfill.js识别请求中的 User Agent，判断浏览器是否支持某些特性，然后下发不同的 Polyfillbabel-polyfillReact 16 官方推荐包体积 200k+，难以单独抽离 Map、Set；项目里 react 是单独引用的 cdn，如果要用它需要单独构建一份放 react 前加载babel-plugin-transform-runtime能只 polyfill 用到的类或方法，相对体积较小不能 polyfill 原型上的方法，不适用于业务项目的复杂开发环境其他不常修改的资源（jquery），开启强缓存，配置响应头 Cache-Control 与 Expires减少 http 请求次数：雪碧图、小图片使用字体图标代替css 放顶部、js 放底部，非关键性的脚本（比如百度统计），script 标签加上 defer 或者 async单页应用首屏加载放个 loading，优化用户感知，利用一些过渡效果、骨架屏使用 link 标签的 rel 属性，设置 prefetch、preload（preload 将会把资源得下载顺序权重提高，使得关键数据提前下载好，优化页面打开速度）注意项目中是否使用了字体，字体加载也会让首屏加载变得很慢减少 cookie 的体积使用公共 CDN，好处：如果其他网站刚好也用过同一个资源，浏览器会有缓存服务端开启 gzip（gzip 只对文本文件有效，比如 js、css，流文件无效，比如图片）路由懒加载图片懒加载使用字体图标 iconfont 代替图片图标，不会失真，生成的文件体积小将静态资源放在其他域名的原因（CDN）：浏览器对于相同域名有并发请求数限制请求时不会发送 cookie，节省流量cookie 会发送给二级域名，所以这些静态资源不放在二级域名，放在单独一级域名script 标签的 defer 和 async没有 defer 或 async 属性，浏览器会立即加载并执行相应的脚本async：立即下载，下载完立即执行，不确定顺序执行。对于完全独立的脚本来才去使用 async，比如谷歌统计百度统计。一定会在页面的 load 事件前执行，但不确定在 DOMContentLoaded 事件触发前后执行。defer：立即下载，将延迟到整个页面都解析完毕后再运行js 为什么放最下面？当文档加载过程中遇到 js 文件，html 文档会挂起渲染（加载解析渲染同步）的线程，不仅要等待文档中 js 文件加载完毕，还要等待解析执行完毕，才可以恢复 html 文档的渲染线程，因为 js 有可能会修改 DOM，比如 document.write，这意味着，在 js 执行完成前，后续所有资源的下载可能是没有必要的，这是 js 阻塞后续资源下载的原因。所以平时的代码中，js 是放在 html 文档末尾的css 为什么放最上面？css 不会阻塞 DOM 的解析，但会阻塞 DOM 渲染css 是由单独的下载线程异步下载的但会阻塞 render 树渲染（渲染时需等 css 加载完毕，因为 render 树需要 css 信息）如何判断一个页面卡顿的原因内存泄漏，由于疏忽或者程序的某些错误造成未能释放已经不再使用的内存的情况（比如不再使用的变量额外创建）Chrome devTools Performance 查看内存情况打开 Chrome 的无痕模式，这样做的目的是为了屏蔽掉 Chrome 插件对我们之后测试内存占用情况的影响"},{"id":"e6550d621738d7e47a2f89dac59256aa","isRootIndexFile":false,"isIndexFile":false,"filename":"首屏加载优化.md","basename":"首屏加载优化","path":"/home/runner/work/qxtang.github.io/qxtang.github.io/性能优化","content":"首屏加载优化在 root 节点中写一些东西&lt;!-- 不美观 --&gt;&lt;div class=&quot;root&quot;&gt;Loading...&lt;/div&gt;&lt;div id=&quot;root&quot;&gt;  &lt;!-- 这里画一个 SVG --&gt;&lt;/div&gt;使用 html-webpack-plugin 自动插入 loading：var HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;);var path = require(&#x27;path&#x27;);// 读取写好的 loading 态的 html 和 cssvar loading = {  html: fs.readFileSync(path.join(__dirname, &#x27;./loading.html&#x27;)),  css: &#x27;&lt;style&gt;&#x27; + fs.readFileSync(path.join(__dirname, &#x27;./loading.css&#x27;)) + &#x27;&lt;/style&gt;&#x27;,};var webpackConfig = {  entry: &#x27;index.js&#x27;,  output: {    path: path.resolve(__dirname, &#x27;./dist&#x27;),    filename: &#x27;index_bundle.js&#x27;,  },  plugins: [    new HtmlWebpackPlugin({      filename: &#x27;xxxx.html&#x27;,      template: &#x27;template.html&#x27;,      loading: loading,    }),  ],};&lt;!-- 在模板中引用 --&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;  &lt;head&gt;    &lt;%= htmlWebpackPlugin.options.loading.css %&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;div id=&quot;root&quot;&gt;&lt;%= htmlWebpackPlugin.options.loading.html %&gt;&lt;/div&gt;  &lt;/body&gt;&lt;/html&gt;使用 SplitChunksPlugin 自动拆分业务基础库编译到 ES2015+ 提升代码运行效率大多数项目的做法是，编写 ES6+ 的代码，然后在构建时编译到 ES5 运行，不仅体积大，而且运行速度慢大部分现代浏览器已经原生支持 ES6+把代码编译到 ES6+，然后为少数使用老旧浏览器的用户保留一个 ES5 标准的备胎即可使用 &lt;script type=&quot;module&quot;&gt;，支持这个的浏览器必然支持 ES6，不支持 type module 的浏览器会因为无法识别这个标签，而不去加载老旧浏览器无法识别 nomodule 属性，会自动忽略，从而加载 ES5 标准的代码&lt;script type=&quot;module&quot; src=&quot;main.js&quot;&gt;&lt;/script&gt;&lt;script nomodule src=&quot;main.es5.js&quot;&gt;&lt;/script&gt;骨架屏、react-placeholder 提前撑开页面布局避免出现闪屏"}]},{"id":"cfc6762313c8fadde407c043154409f7","dirname":"最佳实践","filename":"","basename":"","path":"/home/runner/work/qxtang.github.io/qxtang.github.io","children":[{"id":"5d9cd149bffeb85ff35aed2ff52e3c4c","isRootIndexFile":false,"isIndexFile":false,"filename":"CSS最佳实践.md","basename":"CSS最佳实践","path":"/home/runner/work/qxtang.github.io/qxtang.github.io/最佳实践","content":"CSS 最佳实践待完善善用继承关键字 inherit使用 all:unset 或 all:revert 将样式进行批量重置"},{"id":"90c722fcc7f93ea31011ef4abc7f384d","isRootIndexFile":false,"isIndexFile":false,"filename":"Javascript.md","basename":"Javascript","path":"/home/runner/work/qxtang.github.io/qxtang.github.io/最佳实践","content":"Javascript先声明后调用优先 const常量大写少写魔法值，常量需要命名不污染全局不要忽略抛异常、不要忘了在 Promise\\async await 抛异常缓存耗时的计算，比如 dom 查找、设备信息查询等尽可能使用原生方法，因为原生方法是用低级语言写的（C/C++），并且被编译成机器码，效率更高，比如 Array 的 filter少用 for-in，慢，for-in 要搜索原型属性基于函数的迭代 forEach 比一般的循环要慢，如果对运行速度要求很严格，不要使用使用枚举或策略模式减少 elseif，使用 Map、Object 优化 switch-case?? 空值合并操作符、?. 链合并运算符少写 console（或提交代码时删除 console），项目跑起来一堆的日志让队友很头疼多元判断时，可将条件拼接成字符串存到 Object 里/** * 按钮点击事件 * @param {number} status 活动状态：1未开始 2进行中 3结束 * @param {string} identity 身份标识：guest游客 admin管理员 */const onButtonClick = (status, identity) =&gt; {  if (identity == &#x27;guest&#x27;) {    if (status == 1) {      //do sth    } else if (status == 2) {      //do sth    } else if (status == 3) {      //do sth    } else {      //do sth    }  } else if (identity == &#x27;admin&#x27;) {    if (status == 1) {      //do sth    } else if (status == 2) {      //do sth    } else if (status == 3) {      //do sth    } else {      //do sth    }  }};// 可优化为const actions = new Map([  [&#x27;guest_1&#x27;, () =&gt; {} /*do sth*/],  [&#x27;guest_2&#x27;, () =&gt; {} /*do sth*/],  [&#x27;guest_3&#x27;, () =&gt; {} /*do sth*/],  [&#x27;admin_1&#x27;, () =&gt; {} /*do sth*/],  [&#x27;admin_2&#x27;, () =&gt; {} /*do sth*/],  [&#x27;admin_3&#x27;, () =&gt; {} /*do sth*/],  [&#x27;default&#x27;, () =&gt; {} /*do sth*/],]);/** * 按钮点击事件 * @param {string} identity 身份标识：guest游客 admin管理员 * @param {number} status 活动状态：1未开始 2进行中 3 结束 */const onButtonClick = (identity, status) =&gt; {  let action = actions.get(`${identity}_${status}`) || actions.get(&#x27;default&#x27;);  action.call(this);};可适当使用对象区分作用域使用 Array.includes 来优化多个条件的判断使用 Array.every 和 Array.some 来处理全部/部分满足条件减少嵌套，提前使用 return用有意义且常用的单词命名变量// 错误：const yyyymmdstr = moment().format(&#x27;YYYY/MM/DD&#x27;);// 正确:const currentDate = moment().format(&#x27;YYYY/MM/DD&#x27;);保持统一命名可能同一个项目对于获取用户信息，会有三个不一样的命名，应该保持统一。// 错误：getUserInfo();getClientData();getCustomerRecord();// 正确：getUser();避免无意义前缀如果创建了一个对象 car，就没有必要把它的颜色命名为 carColor。// 错误：const car = {  carMake: &#x27;Honda&#x27;,  carModel: &#x27;Accord&#x27;,  carColor: &#x27;Blue&#x27;,};function paintCar(car) {  car.carColor = &#x27;Red&#x27;;}// 正确：const car = {  make: &#x27;Honda&#x27;,  model: &#x27;Accord&#x27;,  color: &#x27;Blue&#x27;,};function paintCar(car) {  car.color = &#x27;Red&#x27;;}使用函数参数默认值// 错误：function doSomeThing(name) {  const username = name || &#x27;tony&#x27;;  // ...}// 正确：function doSomeThing(name = &#x27;tony&#x27;) {  // ...}参数越少越好如果参数超过两个，使用解构语法，不用考虑参数顺序。// 错误：function createMenu(title, body, buttonText, cancellable) {  // ...}// 正确：function createMenu({ title, body, buttonText, cancellable }) {  // ...}createMenu({  title: &#x27;Foo&#x27;,  body: &#x27;Bar&#x27;,  buttonText: &#x27;Baz&#x27;,  cancellable: true,});抽象重复代码很多时候虽然是同一个功能，但由于一两个不同点，让你不得不写两个几乎相同的函数，要想优化重复代码需要有较强的抽象能力。不传 flag 参数不要通过 flag 的 true 或 false，来判断执行逻辑。删除弃用代码可以在代码库历史版本中找到它。使用 class链式调用这种模式让的代码简洁优雅，在类的方法最后返回 this 就可以了。class Car {  constructor(make, model, color) {    this.make = make;    this.model = model;    this.color = color;  }  setMake(make) {    this.make = make;    return this;  }  setModel(model) {    this.model = model;    return this;  }  setColor(color) {    this.color = color;    return this;  }  save() {    console.log(this.make, this.model, this.color);    return this;  }}const car = new Car(&#x27;Ford&#x27;, &#x27;F-150&#x27;, &#x27;red&#x27;).setColor(&#x27;pink&#x27;).save();单一功能原则如果一个类干的事情太多太杂，会导致后期很难维护。我们应该厘清职责，各司其职减少相互之间依赖。封闭开放原则“当需要改变一个程序的功能或者给这个程序增加新功能的时候，可以使用增加代码的方式，但是不允许改动程序的源代码”比如我想修改一个公共组件的样式来适配自己的页面，但又需要保证其他使用这个组件的页面不受影响，可以通过增加一个主题参数，根据该参数加载一份新的样式文件"},{"id":"38f7be06c8c5c4d4d37ea6cadecfc7fe","isRootIndexFile":false,"isIndexFile":false,"filename":"React.md","basename":"React","path":"/home/runner/work/qxtang.github.io/qxtang.github.io/最佳实践","content":"React使用 hooks使用 styled-components https://medium.com/building-crowdriff/styled-components-to-use-or-not-to-use-a6bb4a7ffc21考虑使用 unstated-next 代替 redux组件属性超过 3 个则换行没有子元素的组件写成自闭合多用函数组件，更小的打包体积，更高的执行效率多用 PureComponent，PureComponent 会先对 state 和 props 进行浅比较，不同的时候才会 render遵循单一职责原则，使用 HOC / 装饰器 / Render Props 增加职责react 组件文件用 jsx，用大驼峰命名 jsx 文件表达式中的 jsx 使用圆括号包裹每个文件只写一个组件，但是多个无状态组件可以放在单个文件中，文件名要与默认导出的类名一致组合优于继承性能原因尽量不写内联函数，比如点击事件React 应用中的权限管理：https://isamatov.com/react-permissions-and-roles/多使用解构，例如声明函数组件的 props 和 默认值export default ({ name = &#x27;小明&#x27;, sex = &#x27;男&#x27; }) =&gt; (  &lt;&gt;    我叫 {name}，性别 {sex}  &lt;/&gt;);组件属性命名保持统一，使兼容性良好，避免无意义前缀// 错误&lt;MyInput inputValue onInputChange wrapStyle wrapClassName /&gt;// 正确&lt;MyInput value onChange style className /&gt;避免在 render 里面动态创建对象 / 方法，否则会导致子组件每次都 render// 错误：render() {  const obj = {num: 1}  return (    &lt;Child obj={obj} onClick={()=&gt;{...}} /&gt;  );}避免在 JSX 中写复杂的三元表达式，应通过封装函数或组件实现// 错误：render() {  const a = 8;  return (    &lt;div&gt;      {        a &gt; 0 ? a &lt; 9 ? ... : ... : ...      }    &lt;/div&gt;  );}// 正确：f() {  // ...}render() {  const a = 8;  return (    &lt;div&gt;      {        this.f()      }    &lt;/div&gt;  );}使用运算符&amp;&amp;简化三元运算在 JavaScript 中，true &amp;&amp; expression 总是会返回 expression, 而 false &amp;&amp; expression 总是会返回 false，因此，如果条件是 true，&amp;&amp; 右侧的元素就会被渲染，如果是 false，React 会忽略并跳过它。例如：{  loading ? &lt;Loading /&gt; : null;}可简化为{  loading &amp;&amp; &lt;Loading /&gt;;}尽量避免使用展开运算符来展开 props变得难以理解和维护，容易出 bug遇到事件处理，可以使用一个返回新函数的方法例如：import React from &#x27;react&#x27;;export default function SampleComponent({ onValueChange }) {  const handleChange = (key) =&gt; {    return (e) =&gt; onValueChange(key, e.target.value);  };  return (    &lt;form&gt;      &lt;input onChange={handleChange(&#x27;name&#x27;)} /&gt;      &lt;input onChange={handleChange(&#x27;email&#x27;)} /&gt;      &lt;input onChange={handleChange(&#x27;phone&#x27;)} /&gt;    &lt;/form&gt;  );}使用 Hook components比如要封装一个弹窗组件：// 组件import React, { useCallback, useState } from &#x27;react&#x27;;import ConfirmationDialog from &#x27;components/global/ConfirmationDialog&#x27;;export default function useConfirmationDialog({ headerText, bodyText, confirmationButtonText, onConfirmClick }) {  const [isOpen, setIsOpen] = useState(false);  const onOpen = () =&gt; {    setIsOpen(true);  };  const Dialog = useCallback(    () =&gt; (      &lt;ConfirmationDialog        headerText={headerText}        bodyText={bodyText}        isOpen={isOpen}        onConfirmClick={onConfirmClick}        onCancelClick={() =&gt; setIsOpen(false)}        confirmationButtonText={confirmationButtonText}      /&gt;    ),    [isOpen]  );  return {    Dialog,    onOpen,  };}// 使用import React from &#x27;react&#x27;;import { useConfirmationDialog } from &#x27;./useConfirmationDialog&#x27;;function Client() {  const { Dialog, onOpen } = useConfirmationDialog({    headerText: &#x27;Delete this record?&#x27;,    bodyText: &#x27;Are you sure you want delete this record? This cannot be undone.&#x27;,    confirmationButtonText: &#x27;Delete&#x27;,    onConfirmClick: handleDeleteConfirm,  });  function handleDeleteConfirm() {}  const handleDeleteClick = () =&gt; {    onOpen();  };  return (    &lt;div&gt;      &lt;Dialog /&gt;      &lt;button onClick={handleDeleteClick} /&gt;    &lt;/div&gt;  );}export default Client;这种模式可以少写很多与组件相关的 state，比如弹窗的 visible、title 之类的将业务逻辑封装进 hooks，业务逻辑与 UI 分离（关注点分离）// 例如：import React from &#x27;react&#x27;;import ItemDisplay from &#x27;./ItemDisplay&#x27;;export default function SampleComponent() {  const { data, handleDelete, handleEdit, handleAdd } = useCustomHook();  return (    &lt;div&gt;      &lt;div&gt;        {data.map((item) =&gt; (          &lt;ItemDisplay item={item} /&gt;        ))}      &lt;/div&gt;      &lt;div&gt;        &lt;button onClick={handleDelete} /&gt;        &lt;button onClick={handleAdd} /&gt;        &lt;button onClick={handleEdit} /&gt;      &lt;/div&gt;    &lt;/div&gt;  );}不要把所有状态存放在 redux，redux 只用于存放用户登录信息、主题等信息不要任何变量都使用状态，可以使用 useRef 或成员属性（类组件）来储存与更新渲染无关的变量，可以通过已保存的状态来推断出的状态可使用 useMemo 来计算，而不要创建新状态尽量不要在组件中声明新的组件// 错误，不建议function A() {  const B = () =&gt; {    return &lt;p&gt;hello&lt;/p&gt;;  };  return (    &lt;div&gt;      &lt;B /&gt;    &lt;/div&gt;  );}原因：高耦合影响性能，A 每一次渲染都会重新声明一遍 B避免为了优化少量性能过度设计代码，牺牲代码的可维护性、易读性，浪费时间"},{"id":"d02c013ecd23b0f2469dc30db74d4108","isRootIndexFile":false,"isIndexFile":false,"filename":"git 实践.md","basename":"git 实践","path":"/home/runner/work/qxtang.github.io/qxtang.github.io/最佳实践","content":"git 实践git rebase可以直接理解为改变基底。feature 分支是基于 master 分支的 B 拉出来的分支，feature 的基底是 B。而 master 在 B 之后有新的提交，就相当于此时要用 master 上新的提交来作为 feature 分支的新基底。实际操作为把 B 之后 feature 的提交存下来，然后删掉原来这些提交，再找到 master 的最新提交位置，把存下来的提交再接上去（新节点新 commit id）如此 feature 分支的基底就相当于变成了 M 而不是原来的 B 了。注意，如果 master 上在 B 以后没有新提交，那么就还是用原来的 B 作为基，rebase 操作相当于无效，此时和 git merge 就基本没区别了，差异只在于 git merge 会多一条记录 Merge 操作的提交记录大部分公司其实会禁用 rebase，不管是拉代码还是 push 代码统一都使用 merge，虽然会多出无意义的一条提交记录“Merge … to …”，但至少能清楚地知道主线上谁合了的代码以及他们合代码的时间先后顺序GitFlow简单记录工作中使用 gitflow 模型管理代码版本、保证代码安全的方法。参考：A successful Git branching modelGit 工作流程Git 分支管理策略git flow 的使用GitFlow 原理浅析gitflow 现在被认为过于复杂，可能不适用于现代软件开发：如何看待 Git flow 发明人称其不适用于持续交付？Issues with git-flow在阿里，我们如何管理代码分支？分支类型master只有一条主分支只读，只能从分支 release 或 hotfix 合并进来所有发生在 master 分支的修改应该打 tag 做记录，方便追溯develop只有一条主开发分支，基于 master 分支克隆包含所有要发布到下一个 release 的代码只读，只能从 feature 或 release 合并进来feature 功能分支完成开发后，合并到 develop，合并到 develop 前，提交合并申请，与 develop 分支进行比较做代码审查，审查通过则允许合并从 develop 拉取 release 分支，提测release 或 hotfix 分支上线完毕，合并回 develop。feature功能开发分支，基于 develop 分支克隆，主要用于新需求新功能的开发有多条，按功能划分，如：/feature/20200712-新增用户、/feature/20200801-登陆注册可以几个人一起开发一条 feature，也可以一人负责一条 feature功能开发完毕后，提测前，合并到 develop 分支feature 类型的分支可同时存在多个，用于团队中多个功能同时开发，属于临时分支，功能完成后可选择删除release版本分支，用于测试与上线，基于 feature 分支合并到 develop 之后，从 develop 分支克隆有多条，按版本划分，如：/release/20200712-第一版v0.1、/release/20200713-第二版v0.2release 类型的分支主要用于测试和修改 bug，完成上线后合并回 develop 与 master 分支hotfix补丁分支，基于 master 分支克隆，主要用于对线上的版本进行 BUG 修复有多条，按版本划分，如：/hotfix/20200712-修复xss漏洞、/hotfix/20200713-修复新增用户失败bug修复完毕后合并回 develop 与 master 分支主要工作流程示例初始化项目，创建 master 分支，然后从 master 拉取 develop 分支根据需求划分功能，从 develop 拉取 feature 分支进行编码开发，如/feature/20200712-新增用户、/feature/20200801-登陆注册feature 分支完成后，合并到 develop 前，提交合并申请，与 develop 比较，进行代码审查，合并完成可以选择删除当前 feature需要发布时，从 develop 拉取 release 分支进行测试，例如/release/20200712-第一版，测试过程中在该条 release 分支上修改 BUG，测试通过后将该条 release 分支发布回归：任一 release 分支通过测试上线后，合并该 release 分支到 develop 与 master，master 分支打 tag，当前 release 不可修改，线上有问题须从 master 拉取 hotfix 分支进行修改通知所有进行中的 feature、release 把 master 合进来一次上线之后若发现 bug，从 master 拉取 hotfix 进行 bug 修改，如/hotfix/20200713-修复新增用户失败bughotfix 通过测试上线后，合并 hotfix 分支到 develop 与 master，master 分支打 tag版本回退：如果需进行版本回退，则选择上一版本号的 release 分支进行发布分支命名使用 YYYYMMDD-功能名称 格式，gui 工具或命令行打印时自动排序，找分支找比较方便参考https://ourai.ws/posts/working-with-git-in-team/https://www.cnblogs.com/irving/p/5146738.htmlhttps://mp.weixin.qq.com/s/0N3isbSZL4fM5HjZo1aafAhttps://ihower.tw/blog/archives/3843"},{"id":"6b4ced9d2ef205d68999ba7579eb19ac","isRootIndexFile":false,"isIndexFile":true,"filename":"index.md","basename":"最佳实践","path":"/home/runner/work/qxtang.github.io/qxtang.github.io/最佳实践","content":"最佳实践参考https://guide.aotu.io/docs/https://isamatov.com/simple-tips-for-writing-clean-react-components/https://react-typescript-cheatsheet.netlify.app/https://juejin.im/post/5e021eb96fb9a01628014095https://juejin.cn/post/7086735198942920712"},{"id":"a8b2265cbd54ac650bb8381258e83bd7","isRootIndexFile":false,"isIndexFile":false,"filename":"前端组件设计原则.md","basename":"前端组件设计原则","path":"/home/runner/work/qxtang.github.io/qxtang.github.io/最佳实践","content":"前端组件设计原则细粒度的考量：单一职责原则组件要建立在可复用的基础上，对于不可复用的单一职责组件仅作为独立组件的内部组件即可通用性考量暴露拓展能力给调用方（插槽、render props）css 解决方案使用 css-in-js、styled-components测试方案使用 Jest 测试框架"},{"id":"e7542d604b34ce539d8b7baa7df7746b","isRootIndexFile":false,"isIndexFile":false,"filename":"通用工程实践.md","basename":"通用工程实践","path":"/home/runner/work/qxtang.github.io/qxtang.github.io/最佳实践","content":"其他工程实践滥用事件总线的危害事件名称难以追溯，增加了代码复杂度、可维护性降低调试难度大业务代码分层习惯├─assets 静态资源├─service 业务逻辑封装├─components 组件  ├─business 业务组件  ├─common 通用组件├─constants 常量├─store 全局状态├─pages 页面├─types 通用类型├─utils 工具使前端能够脱离后端进行独立测试集成 mockjs 等工具，使前端能够脱离后端独立的进行测试，模拟后端各种请求报错以及所有其他情况npm 脚本命名同一系列行为的脚本，命令行参数、环境变量有差异，用冒号区分，比如&quot;scripts&quot;: {  &quot;build:test&quot;: &quot;tsc &amp;&amp; vite build --mode test&quot;,  &quot;build:prod&quot;: &quot;tsc &amp;&amp; vite build --mode production&quot;,}前置操作的处理如登录、获取用户信息、权限检查等任务，放在根组件（App.tsx、App.vue）中执行，执行结束再渲染路由组件，保证业务接口能正确获取参数小程序：小程序入口组件不会渲染任何内容，例如 Taro 框架，根组件必须同步返回 props.children，所以对前置操作的处理，可以将首页设置为一个 loading 页，在 loading 页中显示加载中且进行前置操作后，再跳转到业务页面（为 loading 页设置如 redirectUrl 参数设置跳转页面）。不建议在本地构建部署代码应使用 devops 系统前端项目的一般部署流程获取代码：从代码仓库获取项目代码，并切换到待部署的分支或版本安装依赖：安装项目构建所需要的依赖包源码构建：使用构建工具对项目源代码进行构建，生成产物代码产物打包：将部署所需的代码（通常指的是构建后的产物代码，如果是部署 Node 服务则还需要其他目录与文件）打成压缩包推送代码：将待部署的文件或压缩包推送至目标服务器的特定目录下，如果是推送压缩包的情况，还需执行解压重启服务：在部署 Node 服务的情况下，在代码推送后需要进行服务重启本地部署的优势快速：不需要获取代码、安装依赖这几个步骤构建失败能更方便查找问题本地部署的劣势溯源难环境一致性：不同开发人员的本地依赖包版本可能存在差异，导致打包结果并不严格一致；本地环境和部署代码的目标服务器环境之间也可能存在差异；导致项目代码的稳定性无法得到保障例如对于一个 Node 项目而言，在一个 NodeJS 低版本环境下构建的产物，在 Node 高版本环境下就有可能启动异常其他第三方库按需加载移除生产环境的控制台打印动态 polyfill通过判断环境变量的方式，区分执行环境差异代码，借助 DefinePlugin 将环境变量静态嵌入客户端代码尽量不要污染全局 window 对象通过封装解决浏览器差异兼容性问题为项目配置代码引用路径别名 alias项目不要添加任何与开发环境强耦合的设置（比如某个地方必须借助 vscode 的某个插件才能运行）禁止安装私人依赖包使用 Webpack Bundle Analyzer 分析包大小组成函数遵循单一职责原则只导入类型，使用 import typeimport type { DependencyList, useEffect, useLayoutEffect } from &#x27;react&#x27;;想要在 chrome 移动设备模拟器上添加某个自定义设备型号，需要知道该设备的分辨率console.log(document.body.clientWidth, document.body.clientHeight);开发环境 node 和 npm 版本需要一致，因为不同版本 node、npm 行为不一样小程序环境判断https://developers.weixin.qq.com/community/develop/doc/000e466b2c84d057b178e339d5b000https://developers.weixin.qq.com/community/develop/article/doc/000e6606ab4ac0edb4791eb4951013"}]},{"id":"a0c5da9a0cd648aa743ef98594dd0703","dirname":"构建工具","filename":"","basename":"","path":"/home/runner/work/qxtang.github.io/qxtang.github.io","children":[{"id":"f76805d5a2ef74d03db420f95ad2e5ba","dirname":"Webpack","filename":"","basename":"","path":"/home/runner/work/qxtang.github.io/qxtang.github.io/构建工具","children":[{"id":"1c964e57911bcf5ca7cd965d5fad4338","isRootIndexFile":false,"isIndexFile":false,"filename":"Loader.md","basename":"Loader","path":"/home/runner/work/qxtang.github.io/qxtang.github.io/构建工具/Webpack","content":"LoaderLoader 本质上是导出函数的 JavaScript 模块，可用于实现内容转换，进行各种文件类型的加载与转换，比如 babel-loader 将 jsx 转为 React.createElementwebpack 只认识 JavaScript，Loader 将资源转化成 Webpack 可以理解的内容当 Webpack 在转换某文件类型的时候，会按顺序链式调用每一个 loaderloader 的开发需要遵循一些规范，比如返回值必须是标准的 JS 代码字符串，以保证下一个 loader 能够正常工作编写 loaderhttps://webpack.docschina.org/contribute/writing-a-loader/通常是一个函数module.exports = function (source, sourceMap?, data?) {  // source：为 loader 的输入，可能是文件内容，也可能是上一个 loader 处理结果  // sourceMap：可选参数，代码的 sourcemap 结构  // data：可选参数，其它需要在 Loader 链中传递的信息  return source;};通过 return 语句返回处理结果，除此之外 Loader 还可以调用 callback api 返回更多信息，供下游 Loader 或者 Webpack 本身使用callback 签名：this.callback(  // 异常信息，Loader 正常运行时传递 null 值即可  err: Error | null,  // 转译结果  content: string | Buffer,  // 源码的 sourcemap 信息  sourceMap?: SourceMap,  // 任意需要在 Loader 间传递的值  // 经常用来传递 ast 对象，避免重复解析  data?: any);loader 例子：module.exports = function (source) {  const content = doSomeThing2JsString(source);  // 如果 loader 配置了 options 对象，那么this.query将指向 options  const options = this.query;  // 可以用作解析其他模块路径的上下文  console.log(&#x27;this.context&#x27;);  /*   * this.callback 参数：   * error：Error | null，当 loader 出错时向外抛出一个 error   * content：String | Buffer，经过 loader 编译后需要导出的内容   * sourceMap：为方便调试生成的编译后内容的 source map   * ast：本次编译生成的 AST 静态语法树，之后执行的 loader 可以直接使用这个 AST，进而省去重复生成 AST 的过程   */  this.callback(null, content);  // or return content;};为什么 loader 执行顺序是从右到左webpack 选择了函数式编程的方式，最左侧的 loader 返回值必须是 JS 模块，不然 webpack 无法识别其他语言模块（webpack 只认识 JS 和 JSON）常见 loaderraw-loader：加载文件原始内容（utf-8）image-loader：加载并且压缩图片文件file-loader: 加载文件资源，如 字体 / 图片 等，具有移动/复制/命名等功能、把文件输出到一个文件夹中，在代码中通过相对 URL 去引用输出的文件url-loader: 通常用于加载图片，可以将小图片直接转换为 Date Url，减少请求；和 file-loader 类似，但是能在文件很小的情况下以 base64 的方式把文件内容注入到代码中去babel-loader: 加载 js / jsx 文件， 将 ES6 / ES7 代码转换成 ES5，抹平兼容性问题；ts-loader: 加载 ts / tsx 文件，编译 TypeScript；style-loader: 将 css 代码以 style 标签形式插入"},{"id":"fbe579f71e1521e74442b1935abac94d","isRootIndexFile":false,"isIndexFile":false,"filename":"Plugin.md","basename":"Plugin","path":"/home/runner/work/qxtang.github.io/qxtang.github.io/构建工具/Webpack","content":"Pluginhttps://www.webpackjs.com/contribute/writing-a-plugin/构建流程中引入自定义的行为，需要理解 webpack 底层的特性来处理相应的钩子通常是一个带有 apply 方法的类在 Webpack 运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果compiler 暴露了和 Webpack 整个生命周期相关的钩子：https://www.webpackjs.com/api/compiler-hooks/compilation 则暴露了与模块和依赖有关的粒度更小的事件钩子：https://www.webpackjs.com/api/compilation-hooks/class MyPlugin {  apply(compiler) {    // 找到合适的事件钩子，实现自己的插件功能    compiler.hooks.emit.tap(&#x27;MyPlugin&#x27;, (compilation) =&gt; {      // compilation: 当前打包构建流程的上下文      console.log(compilation);      // do something...    });  }}常见 PlugindefinePlugin：定义环境变量html-webpack-pluginmini-css-extract-plugin: 分离样式文件，CSS 提取为独立文件，支持按需加载 (替代 extract-text-webpack-plugin)clean-webpack-plugin"},{"id":"a229946809829f1260ee10f79a146fdc","isRootIndexFile":false,"isIndexFile":true,"filename":"index.md","basename":"Webpack","path":"/home/runner/work/qxtang.github.io/qxtang.github.io/构建工具/Webpack","content":"Webpack模块打包工具，处理浏览器不认识的各种资源，让其能够运行在浏览器基于入口文件，递归解析入口所需要加载的所有资源，然后用不同的 loader 来处理不同类型的文件，用 Plugin 来扩展 webpack 的功能通过分析模块之间的依赖，最终将所有模块打包成一份或者多份代码包，供 HTML 直接引用Webpack 仅提供打包功能和文件处理，通过生态中的各种 Loader 和 Plugin 对代码进行预编译和打包因此 Webpack 具有高度的可拓展性，能更好的发挥社区生态的力量作用模块打包使我们在开发时可以使用新特性和新语法能力扩展：plugin、loader概念Entry: 入口文件，Webpack 会从该文件开始进行分析与编译；Output: 出口路径，打包后创建 bundler 的文件路径以及文件名；Module: 源码目录中的每一个文件，在 Webpack 中任何文件都可以作为一个模块，会根据配置的不同的 Loader 进行加载和打包；Chunk: webpack 打包过程中的产物，在进行模块的依赖分析的时候，代码分割出来的代码块，可以根据配置，将所有模块代码合并成一个或多个代码块，以便按需加载，提高性能；chunk 类型Initial Chunk：基于 Entry 配置项生成的 ChunkAsync Chunk：异步模块引用，如 import() 语句对应的异步 ChunkRuntime Chunk：只包含运行时代码的 ChunkLoader: 模块加载器，进行各种文件类型的加载与转换，比如 babel-loader 将 jsx 转为 React.createElement；Plugin: 拓展插件，可以通过 Webpack 相应的事件钩子，介入到打包过程中的任意环节，从而对代码按需修改；Bundle: webpack 打包出来的文件，webpack 最终输出的东西，可以直接在浏览器运行。在抽离 css(当然也可以是图片、字体文件之类的)的情况下，一个 chunk 是会输出多个 bundle 的，但是默认情况下一般一个 chunk 也只是会输出一个 bundlevendor: 依赖的第三方库文件指纹hash：所有的 bundle 使用同一个 hash 值，跟每一次 webpack 打包的过程有关chunkhash：根据每一个 chunk 的内容进行 hash，同一个 chunk 的所有 bundle 产物的 chunkhash 值是一样的。因此若其中一个 bundle 的修改，同一 chunk 的所有产物 hash 也会被修改contenthash：与文件内容本身相关注意：开发环境热更新下只能使用 hash 或者不使用 hash。在生产环境中我们一般使用 contenthash 或者 chunkhash，因为在热更新模式下，会导致 chunkhash 和 contenthash 计算错误配置示例const path = require(&#x27;path&#x27;);module.exports = {  entry: &#x27;./src/index.js&#x27;,  devtool: &#x27;inline-source-map&#x27;,  devServer: {    static: &#x27;./dist&#x27;,  },  plugins: [    new HtmlWebpackPlugin({      title: &#x27;Output Management&#x27;,    }),  ],  output: {    filename: &#x27;[name].[contenthash].js&#x27;,    path: path.resolve(__dirname, &#x27;dist&#x27;),    clean: true,    publicPath: &#x27;/&#x27;,  },  externals: {    lodash: {      commonjs: &#x27;lodash&#x27;,      commonjs2: &#x27;lodash&#x27;,      amd: &#x27;lodash&#x27;,      root: &#x27;_&#x27;,    },  },  optimization: {    splitChunks: {      cacheGroups: {        vendor: {          test: /[\\\\/]node_modules[\\\\/]/,          name: &#x27;vendors&#x27;,          chunks: &#x27;all&#x27;,        },      },    },  },  module: {    rules: [      {        test: /\\.css$/i,        use: [&#x27;style-loader&#x27;, &#x27;css-loader&#x27;],      },      {        test: /\\.(png|svg|jpg|jpeg|gif)$/i,        type: &#x27;asset/resource&#x27;,      },    ],  },};工作流程初始化初始化配置参数：从配置文件和 Shell 参数中读取与合并得出参数创建编译器对象 Compiler初始化编译环境：包括注入内置插件、注册各种模块工厂、加载配置的插件等开始编译：执行 compiler 对象的 run 方法确定入口：根据配置中的 entry 找出所有的入口文件构建编译模块：从入口文件出发，调用 loader 将模块转译为标准 JS 内容，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理，并在合适的时机点触发广播事件，Plugin 收听这些事件执行相应方法完成模块编译：上一步递归处理所有能触达到的模块后，得到了每个模块被翻译后的内容以及它们之间的 依赖关系图生成输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会写入文件系统：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统以上过程中，Webpack 会在特定的时间点广播出特定的事件，插件在监听到事件后会执行特定逻辑，并且插件可以调用 Webpack 提供的 api 改变 Webpack 的运行结果rollup 和 webpack 区别webpack 支持代码拆分、按需加载rollup 所有资源放在同一个地方，一次性加载，利用 tree-shake 特性来剔除项目中未使用的代码，减少冗余对于应用使用 webpack，对于类库使用 rollup，rollup 适用于基础库的打包，如 vue、react如果你需要代码拆分(Code Splitting)，或者你有很多静态资源需要处理，再或者你构建的项目需要引入很多 CommonJS 模块的依赖，那么 webpack 是个很不错的选择如果您的代码库是基于 ES2015 模块的，而且希望你写的代码能够被其他人直接使用，你需要的打包工具可能是 rollupTree-Shaking基于 ES Module 规范的死码删除技术在运行过程中静态分析模块之间的导入导出，确定 ESM 模块中哪些导出值未曾被其它模块使用，并将其删除，以此实现打包产物的优化实现 Tree Shaking 技术的必要条件在 CommonJs、AMD、CMD 等旧版本的 JavaScript 模块化方案中，导入导出行为是高度动态，难以预测的而 ESM 方案则从规范层面规避这一行为，它要求所有的导入导出语句只能出现在模块顶层，且导入导出的模块名必须为字符串常量所以，ESM 下模块之间的依赖关系是高度确定的，与运行状态无关，编译工具只需要对 ESM 模块做静态分析，就可以从代码字面量中推断出哪些模块值未曾被其它模块使用"},{"id":"ec69a5c5d474a5557d0c9fd83dc0eedc","isRootIndexFile":false,"isIndexFile":false,"filename":"分包.md","basename":"分包","path":"/home/runner/work/qxtang.github.io/qxtang.github.io/构建工具/Webpack","content":"webpack 分包为什么分包资源冗余：客户端必须等待整个应用的代码包都加载完毕才能启动运行，但可能用户当下访问的内容只需要使用其中一部分代码缓存失效：将所有资源打成一个包，即使只是修改一个字符，浏览器都需要重新下载整个代码包，缓存命中率低配置 optimization.splitChunksmodule.exports = {  optimization: {    splitChunks: {      // 表示选择哪些 chunks 进行分割，可选值有：async、initial、all      chunks: &#x27;async&#x27;,      // 形成一个新代码块最小的体积，表示新分离出的chunk必须大于等于minSize，默认为30000，约30kb。      minSize: 30000,      // 表示一个模块至少应被minChunks个chunk所包含才能分割。默认为1。      minChunks: 1,      // 表示按需加载文件时，并行请求的最大数目。默认为5。      maxAsyncRequests: 5,      // 表示加载入口文件时，并行请求的最大数目。默认为3。      maxInitialRequests: 3,      // 表示拆分出的chunk的名称连接符。默认为~。如chunk~vendors.js      automaticNameDelimiter: &#x27;~&#x27;,      // 设置chunk的文件名。默认为true。当为true时，splitChunks基于chunk和cacheGroups的key自动命名。      name: true,      // cacheGroups 下可以可以配置多个组，每个组根据test设置条件，符合test条件的模块，就分配到该组。模块可以被多个组引用，但最终会根据priority来决定打包到哪个组中。默认将所有来自 node_modules目录的模块打包至vendors组，将两个以上的chunk所共享的模块打包至default组。      cacheGroups: {        vendors: {          test: /[\\\\/]node_modules[\\\\/]/,          priority: -10,        },        default: {          minChunks: 2,          priority: -20,          reuseExistingChunk: true,        },      },    },  },};默认分包规则同一个 entry 下触达到的模块组织成一个 chunk异步模块（import()或require.ensure()）单独组织为一个 chunkentry.runtime 单独组织成一个 chunkRuntime（运行时代码） 分包Webpack 5 还能根据 entry.runtime 配置单独打包运行时代码runtime除业务代码外，Webpack 编译产物中还需要包含一些用于支持 webpack 模块化、异步加载等特性的支撑性代码，这类代码在 webpack 中被统称为 runtime最佳实践尽量将第三方库拆为独立分包按路由分包，减少首屏资源负载"},{"id":"36b42f5305d0324c294138c790ddc810","isRootIndexFile":false,"isIndexFile":false,"filename":"最佳实践.md","basename":"最佳实践","path":"/home/runner/work/qxtang.github.io/qxtang.github.io/构建工具/Webpack","content":"最佳实践使用 html-webpack-plugin 配置 html 模板文件使用 clean-webpack-plugin 在打包输出前清空文件夹为 css 添加浏览器前缀：postcss-loader autoprefixer使用 mini-css-extract-plugin，把 css 样式从 js 文件中提取到单独的 css 文件中使用 extract-text-webpack-plugin 拆分多个 css使用 file-loader、url-loader 打包 图片、字体、媒体、等文件使用 HotModuleReplacementPlugin 配置 webpack-dev-server 进行热更新合理的配置 mode 参数与 devtool 参数缩小文件的搜索范围，配置 include exclude alias noParse extensions使用 HappyPack 开启多进程 Loader 转换使用 webpack-parallel-uglify-plugin 增强代码压缩使用 webpack 内置的 DllPlugin DllReferencePlugin 抽离第三方模块配置缓存：cache-loader引入 webpack-bundle-analyzer 分析打包后的文件externals：有时我们希望我们通过 script 引入的库，如用 CDN 的方式引入的 jquery，我们在使用时，依旧用 require 的方式来使用，但是却不希望 webpack 将它又编译进文件中参考https://juejin.cn/post/6844904031240863758"},{"id":"feaf7c0c42b2aa9ad1bb116958bb1cd2","isRootIndexFile":false,"isIndexFile":false,"filename":"构建优化.md","basename":"构建优化","path":"/home/runner/work/qxtang.github.io/qxtang.github.io/构建工具/Webpack","content":"构建优化分析工具webpack-bundle-analyzer：可视化方式看打包的 bundle 中包含哪些模块内容、大小webpackbar：实时显示打包进度实时显示打包进度：可以看到每个 loader 和 plugin 耗时情况speed-measure-webpack-plugin：分析打包速度构建速度优化思路：从 模块搜索时间、解析时间、压缩时间、二次打包时间 入手多进程构建运行在 Node.js 之上的 webpack 是单线程模式的，webpack 打包只能逐个文件处理使用 happypack（废弃）、thread-loader（推荐）仅在耗时的 loader 上使用，如果是小项目，不要开启多进程构建，开启进程需要花费时间，构建反而变慢// 把它放置在其它 loader 之前module.exports = {  module: {    rules: [      {        test: /\\.js$/,        use: [&#x27;thread-loader&#x27;, &#x27;babel-loader&#x27;],      },    ],  },};thread-loader 需要放在 style-loader 之后：因为 thread-loader 后的 loader 没法存取文件也没法获取 webpack 的选项设置利用缓存，提升二次构建速度使用缓存后，node_modules 中会有一个.cache 目录，用于存放缓存内容cache-loader：只对性能开销较大的 loader 使用，保存和读取缓存文件有开销module.exports = {  module: {    rules: [      {        test: /\\.js$/,        use: [&#x27;cache-loader&#x27;, &#x27;babel-loader&#x27;],      },    ],  },};babel-loader 开启缓存，在 babel-loader 后面加上?cacheDirectory=truehard-source-webpack-plugin：用于开启模块的缓存terser-webpack-plugin 开启缓存缩小打包作用域exclude/include：确定 loader 规则范围，node_modules 里的 js 文件基本上都是转译好了的，不需要再次处理，用 include/exclude 来避免不必要的转译优化 resolve.alias：可减少耗时的递归解析操作优化 resolve.extensions：列表要尽可能的小，尽可能减少后缀尝试次数；频率出现高的后缀优先放前面，尽快退出寻找过程；写导入语句时，尽可能带上后缀，避免寻找过程resolve.modules：指明第三方模块的绝对路径，减少不必要的查找优化 resolve.mainFields：一些第三方模块会针对不同环境提供几分代码，位置写在 package.json 文件里，webpack 会根据 mainFields 配置决定优先采用哪份代码优化 module.noParse：对不需要解析的库进行忽略（jquery、echarts），不解析但仍打包到 bundle 中，被忽略掉的文件里不应该包含 import、require、define 等模块化语句动态链接库将第三方库代码和业务代码都打包进一个 bundle，那么处理这个 bundle 文件的插件（比如压缩之类的插件），就没办法不处理里面第三方库内容第三方库代码基本都是成熟的，不用作处理，可以将第三方库代码分离出来配置 externals，每一个库都在 html 文档中引入一个 script 标签，js 文件下载影响性能，而且我们只使用库中的部分功能，script 标签全量引入不合理SplitChunks 在每一次构建会重新构建第三方库，不能有效提升构建速度使用 DllPlugin 和 DLLReferencePlugin（配合使用，webpack 内置插件），会将不频繁更新的第三方库单独打包，当这些第三方库版本没有变化时，不需要重新构建// webpack.dll.js 用于打包第三方库const path = require(&#x27;path&#x27;);const webpack = require(&#x27;webpack&#x27;);module.exports = {  mode: &#x27;production&#x27;,  entry: {    three: [&#x27;jquery&#x27;, &#x27;lodash&#x27;], // 第三方库配置  },  output: {    filename: &#x27;[name].dll.js&#x27;, // [name] 就是在 entry    path: path.resolve(__dirname, &#x27;dist/lib&#x27;),    library: &#x27;[name]&#x27;,  },  plugins: [    new webpack.DllPlugin({      name: &#x27;[name]&#x27;,      path: path.resolve(__dirname, &#x27;dist/lib/[name].json&#x27;), // manifest.json 的存放位置    }),  ],};module.exports = {  plugins: [    // 修改 CleanWebpackPlugin 配置    new CleanWebpackPlugin({      cleanOnceBeforeBuildPatterns: [        &#x27;!lib/**&#x27;, // 在每次清除 dist 目录时，不清理 lib 文件夹      ],    }),    // dll 相关配置    new webpack.DllReferencePlugin({      // 将 manifest 字段配置成第1步中打包出来的 json 文件      manifest: require(&#x27;./dist/lib/three.json&#x27;),    }),  ],};优化构建体积代码分割分离第三方库和业务代码中的基础库，通过 SplitChunks 或动态链接库动态 import减少首屏资源的体积，非首屏的资源在用到的时候再去请求路由配置使用 import() 来引入页面组件，凡是通过 import() 引用的模块都会打包成独立 bundletree shaking使用 esm 模块规范不要使用 export default那么在 mode：production 生产环境，就会自动开启 tree-shaking，移除没有使用到的代码代码压缩mode：production 自动开启uglifyjs-webpack-plugin（废弃） 和 terser-webpack-plugin（推荐）const TerserPlugin = require(&#x27;terser-webpack-plugin&#x27;);module.exports = {  optimization: {    minimizer: [      new TerserPlugin({        parallel: true, // 开启并行压缩，加快构建速度        sourceMap: true, // 使用 source-maps      }),    ],  },};terser 是什么：用于 ES6+ 的 JavaScript 解析器、mangler/compressor（压缩器）工具包。gzipcompression-webpack-pluginconst CompressionWebpackPlugin = require(&#x27;compression-webpack-plugin&#x27;);module.exports = {  plugins: [    new CompressionWebpackPlugin({      test: /\\.(js|css)$/, // 匹配要压缩的文件      algorithm: &#x27;gzip&#x27;,    }),  ],};"}]},{"id":"278fc17858441b35a42c08ff27b1fa6e","isRootIndexFile":false,"isIndexFile":false,"filename":"Vite.md","basename":"Vite","path":"/home/runner/work/qxtang.github.io/qxtang.github.io/构建工具","content":"Vite待完善与 Webpack 区别利用浏览器的能力，将解析依赖和获取 js 模块的工具交给浏览器去做，减少了分析依赖跟源码打包的成本Vite 项目启动时间很快，把部分在 webpack 启动时做的工作，交给了浏览器去做了Vite 首次启动加载慢，因为模块以 ES6 原生的模块加载机制的方式被浏览器加载，没有对代码进行打包跟压缩处理，因此请求数会更多，下载文件也会更大，但仅仅是首次，第二次启动是会有缓存的"}]},{"id":"3740baa7f411a43d1dd5ca51e1d17cd2","dirname":"框架","filename":"","basename":"","path":"/home/runner/work/qxtang.github.io/qxtang.github.io","children":[{"id":"89dbe899b1f34a5fd136b8210e81f4f9","dirname":"React","filename":"","basename":"","path":"/home/runner/work/qxtang.github.io/qxtang.github.io/框架","children":[{"id":"607f2cec98ac0a0adb8a132a8963635c","isRootIndexFile":false,"isIndexFile":false,"filename":"Fiber.md","basename":"Fiber","path":"/home/runner/work/qxtang.github.io/qxtang.github.io/框架/React","content":"Fiber一种基于浏览器的单线程调度算法核心渲染算法的重新实现，React 团队两年多研究结晶，对 reconciliation 的重新编写，重新实现了 reconciler（协调器），递归改循环目标是提高对动画、布局和手势等领域的适用性将更新分解成更小的任务，达到增量渲染，将渲染工作拆分为块并将其分散到多个帧上，更新不会长时间阻止主线程（比如用户输入，动画之类）其他功能包括能够在新更新到来时暂停，中止或重用工作注意：并不会减少总工作量或更新所需的时间为什么 Fiber旧版 React 在处理 UI 时，使用栈递归遍历树结构，整个过程同步无法被打断，如果树结构太大层级很深，会一直占用浏览器主线程，可能导致动画丢帧（JS 线程和 GUI 线程是互斥的）改变了 react 的组件渲染机制，新的架构使原来同步渲染的组件可以异步化，可中途中断渲染，执行更高优先级的任务。释放浏览器主线程，保证任务在浏览器空闲的时候执行Fiber 执行过程浏览器现有 api：requestIdleCallback（闲时调用）可实现异步渲染，但 React 为了兼容大多数浏览器，自己实现了 requestIdleCallback两个阶段：Reconciliation 与 Commit。Reconciliation 阶段对应早期版本的 diff 过程，Commit 阶段对应早期版本的 patch 过程，以 render 为界阶段一（Reconciliation）：生成 Fiber 树，得出需要更新的节点信息。这一步是一个渐进的过程，可以被打断，让优先级更高的任务先执行阶段二（Commit）：需要更新的节点一次批量更新，这个过程不能打断Reconciliation 阶段，如果遇到更高优先级事件，则进行打断，渲染到一半的组件，会从头开始渲染，一些生命周期可能会重新执行，例如：componentWillMountcomponentWillReceivePropsshouldComponentUpdatecomponentWillUpdate这些生命周期函数会在 Commit 阶段调用：componentDidMountcomponentDidUpdatecomponentWillUnmountFiber 树React 在 render 第一次渲染时，会通过 React.createElement 创建一颗 Element 树，称之为 Virtual DOM Tree由于要记录上下文信息，加入了 Fiber，每一个 Element 会对应一个 Fiber Node将 Fiber Node 链接起来的结构为 Fiber TreeFiber Tree 一个重要的特点是链表结构，将递归遍历改为循环遍历，然后配合 requestIdleCallback API, 实现任务拆分、中断与恢复workInProgress Fiber 树在 React 中会同时存在两棵 Fiber 树，当前显示在页面是 current Fiber 树在内存中构建的 Fiber 树称为 workInProgress Fiber 树workingProgress Fiber 这棵树是在内存中构建的，构建完成才统一替换，这样不会产生不完全的真实 dom一旦更新完成，react 会将 current 树替换成 workInProgress Fiber 树，也是 react 提升性能的一部分Fiber 数据结构interface FiberNode {  stateNode: any; // 节点实例  child: any; // 对应子节点  sibling: any; // 对应兄弟节点  return: any; // 对应父节点}Fiber 为什么使用链表React 使用单链表树遍历算法实现在没有递归的情况下遍历树，之前的树形结构不满足中途暂停对异步友好，可以暂停遍历并使阻止堆栈增长之前的虚拟 DOM 是树结构，当任务被打断后，树结构无法恢复之前的任务继续执行，所以需要一种新的数据结构，即链表，链表可以包含多个指针，可以轻易找到下一个节点，继而恢复任务的执行Fiber 采用的链表中包含三个指针，parent 指向其父 Fiber 节点，child 指向其子 Fiber 节点，sibling 指向其兄弟 Fiber 节点。一个 Fiber 节点对应一个任务节点"},{"id":"b40b06853ea21f5b268225415b22d328","isRootIndexFile":false,"isIndexFile":false,"filename":"Hooks.md","basename":"Hooks","path":"/home/runner/work/qxtang.github.io/qxtang.github.io/框架/React","content":"Hooks为什么 hooks类组件性能消耗较大，类组件需要创建实例，而且不能销毁函数组件性能消耗小，不需要创建实例，得到返回的 react 元素后就直接把中间量全部都销毁复用状态逻辑：Hook 使你在无需修改组件结构的情况下复用状态逻辑，可以将含有 state 的逻辑从组件中抽象出来，这将可以让这些逻辑容易被测试，在组件之间复用状态逻辑很难，如果要增加职责的话，就要加一层 HOC，容易形成“嵌套地狱”，一个套一个复杂 class 组件会变得难以理解，比如 componentDidMount 和 componentWillUnmount 是区分开的，Hook 可以将组件中相互关联的部分拆分成更小的函数class 比普通函数更难理解和使用，尤其是 this代码组织上，hooks 将业务逻辑聚合后，整个工程可阅读性大大增加友好渐进式的，项目中可以同时使用 class 和 hooksclass 组件的缺点大型组件难拆分和重构，难测试业务逻辑分散在组件的各个方法之中，导致重复逻辑或关联逻辑组件类引入了复杂的编程模式，比如 render props 和高阶组件难以理解的 class，理解 JavaScript 中 this 的工作方式hook 为什么不能放在循环、条件、嵌套函数执行（为什么顺序调用对 React Hooks 很重要？）Not Magic, just ArraysHook 通过数组实现的，每次 useState 都会改变下标，React 需要利用调用顺序来正确更新相应的状态，否则会引起调用顺序的错乱，从而造成意想不到的错误能确保 Hook 在每一次渲染中都按照同样的顺序被调用，让 React 能够在多次的 useState 和 useEffect 调用之间保持 hook 状态的正确React 依靠 Hook 调用的顺序来知道哪个 state 对应哪个 useState，Hook 的调用顺序在每次渲染中都是相同的，只要 Hook 的调用顺序在多次渲染之间保持一致，React 就能正确地将内部 state 和对应的 Hook 进行关联Hook 需要在我们组件的最顶层调用Hook 重渲染时是依赖于固定顺序调用，来保证被正确识别，依赖数组来维护，有一个 setter 数组和一个索引，该索引在每个 hooks 被调用时递增，并在组件 render 时重置用数组解构语法来命名 useState() 返回的 state 变量，但这些变量不会连接到 React 组件上，数据的存储是独立于组件之外的步骤：初始化：创建两个空数组 setters 与 states，创建一个指针设置为 0首次渲染：每当 useState() 被调用时，如果它是首次渲染，它会通过 push 将一个 setter 方法（绑定了指针“cursor”位置）放进 setters 数组中，同时，也会将另一个对应的状态放进 states 数组中去后续渲染：每次的后续渲染都会重置指针“cursor”的位置，并会从每个数组中读取对应的值处理设置事件：每个 setter 对应一个指针位置的引用，当触发任何 setter 调用的时候，会去改变状态数组中对应索引的值开发工作中可以使用 eslint 配置相关规则发现这一错误hooks 实现为什么用数组不用 map使用 key 值取映射 hook 的话，自定义的 hook 被多个组件调用的话，很难不保证之前有没有同名的 key 在其他组件内用 Symbol：不能很好地复用了，因为 key 值的唯一性使得总是同一个 key 调用了 hookReact 如何区分 Class 组件和 Function 组件instanceof 检查这个函数/类是否是 React.Component 的继承类检查 函数/类.prototype.isReactComponent 属性hooks 特性Effect 拿到的总是定义它的那次渲染中的 props 和 state，在任意一次渲染中，props 和 state 是始终保持不变的，它们都属于一次特定的渲染，同样，每次渲染都有它自己的 Effects可通过 ref 来保存值，实现在所有的渲染帧中共享React 会记住我们设置的 effect 函数，并且会在每次 DOM 更改后、浏览器绘制屏幕后，去调用，这使得应用更流畅，不会阻塞屏幕的更新，上一次的 effect 会在重新渲染后被清除依赖项不要对 React 撒谎：effect 中用到的所有组件内的值都应该包含在依赖中可以使用 setState 的函数形式，获取上一次调用对应 setter 时传的状态值如果某些函数仅在 effect 中调用，可以把它们的定义移到 effect 中，这样可以不再需要去考虑依赖如果一个函数没有使用组件内的任何值，可以把它提到组件外面去定义成纯函数，然后就可以自由地在 effects 中使用（或者把它包装成 useCallback）useEffect 第一个参数，不能返回 Promise，所以不能传递异步函数，可以自己在里面声明再执行定时器的例子// 先点击 alert，再点击几次 add 增加 count，3 秒后弹出的是点击 alert 时的状态function Counter() {  const [count, setCount] = useState(0);  function handleAlertClick() {    setTimeout(() =&gt; {      alert(&#x27;You clicked on: &#x27; + count);    }, 3000);  }  return (    &lt;div&gt;      &lt;p&gt;You clicked {count} times&lt;/p&gt;      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;add&lt;/button&gt;      &lt;button onClick={handleAlertClick}&gt;alert&lt;/button&gt;    &lt;/div&gt;  );}// 而如果是在类组件中，则会正确弹出状态的当前值// 因为类组件的状态保存在实例属性上，状态改变实例不会销毁hooks 缺点useEffect 写函数组件时，必须清楚代码中 useEffect 和 useCallback 的“依赖项数组”的改变时机有时候，useEffect 依赖某个函数的不可变性，这个函数的不可变性又依赖于另一个函数的不可变性，这样便形成了一条依赖链一旦这条依赖链的某个节点意外地被改变了，useEffect 就被意外地触发了过度使用 useMemo 后果useMemo 本身也有开销useMemo 会「记住」一些值，同时在后续 render 时，将依赖数组中的值取出来和上一次记录的值进行比较，如果不相等才会重新执行回调函数，否则直接返回「记住」的值。这个过程本身就会消耗一定的内存和计算资源如果执行的操作开销不大，那么就不需要记住返回值。使用 useMemo 的成本可能会超过重新评估该函数的成本使用前应该先思考三个问题：传递给 useMemo 的函数开销大不大返回的值是否原始值：如果计算出来的是基本类型的值，那么每次比较都是相等的，下游组件就不会重新渲染；如果计算出来的是复杂类型的值（object、array），哪怕值不变，但是地址会发生变化，导致下游组件重新渲染。所以我们也需要「记住」这个值。返回值要保持引用一致性：在编写自定义 Hook 时，因为无法确定外部要如何使用它的返回值。如果返回值被用做其他 Hook 的依赖，并且每次 re-render 时引用不一致（当值相等的情况），就可能会产生 bug。所以如果自定义 Hook 中暴露出来的值是 object、array、函数等，都应该使用 useMemo。以确保当值相同时，引用不发生变化。hooks 常用 APIuseCallback：返回一个记忆函数，缓存了每次渲染时那些回调函数的实例，可以配合 React.memo 起到减少不必要的渲染的作用useMemo：返回一个记忆值，传递一个工厂函数和数组。useMemo 只会在数组其中一个输入发生更改时重新调用工厂函数去计算这个值。此优化有助于避免在每个渲染上进行高开销的计算。useRef：useRef 返回一个可变的 ref 对象，其 current 属性被初始化为传递的参数。返回的对象将存留在整个组件的生命周期中。useRef 在 react hook 中的作用, 正如官网说的，像一个变量，类似于 this，可以存放任何东西，createRef 每次渲染都会返回一个新的引用，而 useRef 每次都会返回相同的引用useImperativeHandle：自定义使用 ref 时公开给父组件的实例值，往往与 forwardRef 一起使用useLayoutEffect：签名与 useEffect 相同，但在所有 DOM 变化后同步触发Hook 使用规则和注意约定以 use 开头并且紧跟大写字母（因为约定的力量在于：我们不用细看实现，也能通过命名来了解一个它是什么）只在最顶层使用 Hook，不要在循环，条件或嵌套函数中调用 Hook，能确保 Hook 在每一次渲染中都按照同样的顺序被调用只在 React 函数中调用 Hook，不要在普通的 JavaScript 函数中调用 Hook，确保组件的状态逻辑在代码中清晰可见（eslint 通过判断一个方法是不是大坨峰命名来判断它是否是 React 函数）自定义 hooks一种自然遵循 Hook 设计的约定，而并不是 React 的特性必须以 “use” 开头，不遵循的话，由于无法判断某个函数是否包含对其内部 Hook 的调用，React 将无法自动检查你的 Hook 是否违反了 Hook 的使用规则在两个组件中使用相同的 Hook 不会共享 state，自定义 Hook 是一种重用状态逻辑的机制，所以每次使用自定义 Hook 时，其中的所有 state 和副作用都是完全隔离的useEffect 为什么不能传入异步函数理由是 effect function 应该返回一个销毁函数，如果 useEffect 第一个参数传入 async，返回值则变成了 Promise，会导致 react 在调用销毁函数的时候报错：function.apply is undefined为什么这样设计：useEffect 的返回值是要在卸载组件时调用的，React 需要在 mount 的时候马上拿到这个值，不能有延迟解决：使用 IIFE 或者声明异步函数再执行，推荐使用 IIFE 写法，因为声明的异步函数可能有外部依赖无法及时更新useEffect(() =&gt; {  (async () =&gt; {    const res = await fetch(SOME_API);    setValue(res.data);  })();}, []);编写自定义 hook useAsyncEffect// 自定义hookfunction useAsyncEffect(effect: () =&gt; Promise&lt;void | (() =&gt; void)&gt;, dependencies?: any[]) {  return useEffect(() =&gt; {    const cleanupPromise = effect();    return () =&gt; {      cleanupPromise.then((cleanup) =&gt; cleanup &amp;&amp; cleanup());    };  }, dependencies);}// 使用useAsyncEffect(async () =&gt; {  const count = await fetchData();  setCount(count);}, [fetchData]);useEffect 实现防抖useEffect(() =&gt; {  const timer = setTimeout(async () =&gt; {    await fetchData(deps);  }, 500);  return () =&gt; clearTimeout(timer);}, [deps]);不能直接向 useEffect 传递防抖函数，因为 useEffect 常依赖 props 或者 useState 返回的值，当两种值改变后，都会触发 Function 组件重新渲染，那么 useEffect 又会重新执行一遍，生成一个新的防抖后的函数参考https://overreacted.io/zh-hans/a-complete-guide-to-useeffect/"},{"id":"6114bfb11d1305bea2c3cf9b91a6c7e9","isRootIndexFile":false,"isIndexFile":true,"filename":"index.md","basename":"React","path":"/home/runner/work/qxtang.github.io/qxtang.github.io/框架/React","content":"ReactAPIRefs安全访问 DOM 或某个组件实例不得不直接访问时才使用，否则容易造成混乱useRef 还可以用来保存多帧共享的数据Context当不想在组件树中通过逐层传递 props 或者 state 的方式来传递数据时，可以使用 Context 来实现跨层级的组件数据传递React.createContext：创建一个上下文的容器（组件），defaultValue 可以设置共享的默认数据Provider（生产者）：用于生产共享数据Consumer（消费者）：专门消费 Provider 的数据。Consumer 需要嵌套在生产者下面，才能通过回调的方式拿到共享的数据，当然也可以单独使用，那就只能消费到上文提到的 defaultValue其他React.PureComponent：与 React.Component 完全相同，但是在 shouldComponentUpdate 中实现了 props 和 state 的浅比较，可以提高性能React.memo：高阶组件，与 React.PureComponent 类似，用于包裹函数组件，通过记忆结果来提高性能React.createRef：创建一个 ref，它可以通过 ref 属性附加到 React 元素React.forwardRef：创建一个 React 组件，将它接收的 ref 属性转发给组件树中的另一个组件。接受渲染函数作为参数。React 将用 props 和 ref 作为两个参数来调用这个函数。此函数应返回 React 节点React.lazy：定义动态加载的组件。有助于减少包大小，用来延迟加载在初始渲染期间未使用的组件，要求被&lt;React.Suspense&gt;组件包裹。这是指定加载指示器的方式React.Suspense：指定加载指示器createPortal：将子节点渲染到父组件以外的 DOM 节点PureComponent 缺点：PureComponent 创建了默认的 shouldComponentUpdate 行为，这个默认的 shouldComponentUpdate 行为会一一比较 props 和 state 中所有的属性，只有当其中任意一项发生改变是，才会进行重绘PureComponent 使用浅比较判断组件是否需要重绘，即比较指针的异同所以如果 props 和 state 是引用对象，比如对象、数组，修改属性或元素，不会导致重绘异步加载示例：const Box = React.lazy(() =&gt; import(&#x27;./components/Box&#x27;));&lt;Suspense fallback={&lt;div&gt;loading...&lt;/div&gt;}&gt;{show &amp;&amp; &lt;Box /&gt;}&lt;/Suspense&gt;;import()：es2020 的规范import() 表达式加载模块并返回一个 promise，该 promise resolve 为一个包含其所有导出的模块。我们可以在代码中的任意位置调用这个表达式webpack 碰到之后会将其拆出来成一个 chunk，可以使用魔术注释自定义 chunk 名称，需要加载时会通过异步请求来加载这个 chunk对应的 babel 语法插件：babel-plugin-syntax-dynamic-import异常处理设置边界包裹组件，实现 componentDidCatch为什么不要在 render 中声明组件每次渲染都会声明的一个新的组件，组件的一些非受控状态就会丢失，比如聚焦状态，浏览器选中文字状态实现组件之间代码重用，为什么推荐组合、HOC，而不是继承React 希望组件是按照最小可用思想来进行封装，一个组件只做一件事情，符合单一职责原则函数式编程中，函数组合是组合两个或多个函数以产生新函数的过程。将函数组合在一起就像将一系列管道拼接在一起，让我们的数据流过生命周期1、挂载卸载过程constructor()：必须写 super(),否则会导致 this 指向错误componentWillMount()：即将过时不要使用componentDidMount()：dom 节点已经生成，可以在这里调用 ajax 请求componentWillUnmount()：在这里移除事件订阅和定时器2、更新过程componentWillReceiveProps(nextProps)：即将过时不要使用，接受父组件改变后的 props 需要重新渲染shouldComponentUpdate(nextProps,nextState)：性能优化componentWillUpdate(nextProps,nextState)：即将过时不要使用componentDidUpdate(prevProps,prevState)render()：插入 jsx 生成的 dom 结构，diff 算法比较更新前后的新旧 DOM 树，找到最小的有差异的节点，重新渲染在 Fiber 中，reconciliation 阶段进行了任务分割，涉及到 暂停 和 重启，因此可能会导致 reconciliation 中的生命周期函数在一次更新渲染循环中被 多次调用 的情况，产生一些意外错误新版的建议生命周期如下：class Component extends React.Component {  // 替换 `componentWillReceiveProps`  // 初始化和 update 时被调用  // 静态函数，无法使用 this  static getDerivedStateFromProps(nextProps, prevState) {}  // 判断是否需要更新组件  // 可以用于组件性能优化  shouldComponentUpdate(nextProps, nextState) {}  // 组件被挂载后触发  componentDidMount() {}  // 替换  componentWillUpdate;  // 可以在更新之前获取最新 dom 数据  getSnapshotBeforeUpdate() {}  // 组件更新后调用  componentDidUpdate() {}  // 组件即将销毁  componentWillUnmount() {}  // 组件已销毁  componentDidUnmount() {}}生命周期使用建议：在 constructor 初始化 state在 componentDidMount 中进行事件监听，并在 componentWillUnmount 中解绑事件在 componentDidMount 中进行数据的请求，而不是在 componentWillMount需要根据 props 更新 state 时，使用 getDerivedStateFromProps(nextProps, prevState)可以在 componentDidUpdate 监听 props 或者 state 的变化在 componentDidUpdate 使用 setState 时，必须加条件，否则会死循环getSnapshotBeforeUpdate(prevProps, prevState) 可以在更新之前获取最新的渲染数据，它的调用是在 render 之后，update 之前shouldComponentUpdate: 默认每次调用 setState，一定会最终走到 diff 阶段，但可以通过 shouldComponentUpdate 的生命钩子返回 false 来直接阻止后面的逻辑执行，通常是用于做条件渲染，优化渲染的性能react 性能优化是哪个周期函数shouldComponentUpdate用来判断是否需要调用 render 方法重新描绘 dom因为 dom 的描绘比较消耗性能如果能在 shouldComponentUpdate 方法中能够写出更优化的逻辑，可以提高性能事件处理React 没有直接将事件绑定到元素上，而是在 document 处监听所有支持的事件冒泡到 document 上的事件不是原生浏览器事件，而是 React 自己实现的合成事件为了解决跨浏览器兼容性问题，React 将 浏览器原生事件 封装为 合成事件提供了与原生事件相同的接口，屏蔽了底层浏览器的细节差异，保证了行为一致性这样 React 在更新 DOM 的时候不需要考虑如何去处理绑定在 DOM 上的事件监听器，达到优化性能目的react 合成事件是什么，和原生事件的区别React 合成事件机制，React 并不是将 click 事件直接绑定在 dom 上面，而是采用事件冒泡的形式冒泡到 document 上面，然后 React 将事件封装给正式的函数如果 DOM 上绑定了过多的事件处理函数，页面响应以及内存占用可能会受影响为了避免这类 DOM 事件滥用，同时屏蔽底层不同浏览器之间的事件系统差异，React 实现了一个中间层当用户在为 onClick 添加函数时，React 并没有将 Click 事件绑定在 DOM 元素上，而是在 document 处监听所有支持的事件，当事件发生并冒泡至 document 处时，React 将事件内容封装交给中间层constructor 中 super 与 props 参数一起使用的目的是什么ES6 规定，在子类的 constructor 中必须先调用 super 初始化父类才能引用 this在调用方法之前，子类构造函数无法使用 this 引用 super()为什么一定要 import “react”JSX 实际上是 React.createElement 的语法糖，jsx 会被 babel 翻译成 React.createElementreact 性能优化重写 shouldComponentUpdate 来避免不必要的 dom 操作使用 production 版本的 react.js使用 key 来帮助 React 识别列表中所有子组件的最小变化React.memoPureComponentuseMemo、useCallbackReact 编程模型宿主树用于展示 UI会随时间变化稳定性，宿主树相对稳定通用性，宿主树可以被拆分为外观和行为一致的 UI 模式宿主实例宿主树的节点渲染器渲染器决定如何与特定的宿主环境通信以及如何管理它的宿主实例让开发者能以一种更好的方式操控宿主实例，而不用在意低级视图 API 范例React 元素最小的构建单元一个普通的 JavaScript 对象，用来描述一个宿主实例React 元素也能形成一棵树React 元素并不是永远存在的，它们总是在重建和删除之间不断循环React 元素具有不可变性。不能改变 React 元素中的子元素或者属性，如果想要在稍后渲染一些不同的东西，需要从头创建新的 React 元素树来描述它类似电影中放映的每一帧入口告诉 React ，将特定的 React 元素树渲染到真正的宿主实例中去，例如，React DOM 的入口就是 ReactDOM.render()组件即返回 React 元素的函数一致性React 将所有的工作分成了“渲染阶段”和“提交阶段”。渲染阶段是当 React 调用你的组件然后进行协调的时段，在此阶段进行干涉是安全的，提交阶段就是 React 操作宿主树的时候，而这个阶段永远是同步的批量更新React 会在组件内所有事件触发完成后再进行批量更新，避免浪费的重复渲染上下文事实上，当 React 渲染时，维护了一个上下文栈副作用React 会推迟执行 effect 直到浏览器重新绘制屏幕有一个极少使用的 Hook 能够让你选择退出这种行为并进行一些同步的工作，请尽量避免使用它：useLayoutEffect自定义 Hooks自定义 Hooks 让不同的组件共享可重用的状态逻辑。注意状态本身是不共享的。每次调用 Hook 都只声明了其自身的独立状态。渲染器react-dom、react-dom/server、 react-native、 react-test-renderer 都是常见的渲染器不管你的目标平台是什么，react 包都是可用的，从 react 包中导出的一切，比如 React.Component、React.createElement、 React.Children 和 Hooks，都是独立于目标平台的渲染器包则暴露特定平台的 API，例如 ReactDOM.render()react 包仅仅是让你使用 React 的特性，但是它不知道这些特性是如何实现的。渲染器包(react-dom、react-native 等)提供了 React 特性的实现以及平台特定的逻辑每个渲染器都在已创建的类上设置了一个特殊的字段，这个字段叫做 updater"},{"id":"5c5c812375fd1db2efe2bddded241844","isRootIndexFile":false,"isIndexFile":false,"filename":"react-router.md","basename":"react-router","path":"/home/runner/work/qxtang.github.io/qxtang.github.io/框架/React","content":"react-routerLink 组件和 a 标签区别Link 做了 3 件事情：有 onclick 就执行 onclickclick 的时候阻止 a 标签默认事件、不会跳转和刷新页面否则取得跳转 href（to 属性），执行跳转，此时只是链接变了，并没有刷新页面switch 标签作用有 switch 标签包裹，则其中的在路径相同的情况下，只匹配第一个，这个可以避免重复匹配无 switch 标签包裹，则其中的在路径相同的情况下全都会匹配。更严重的是，还会匹配上级路径withRouter 作用让被修饰的组件可以从属性中获取 history、location、match路由组件可以直接获取这些属性，而非路由组件就必须通过 withRouter 修饰后才能获取这些属性"},{"id":"b1a8f8bc02c01ca5bc970fd1d44d493d","isRootIndexFile":false,"isIndexFile":false,"filename":"setState.md","basename":"setState","path":"/home/runner/work/qxtang.github.io/qxtang.github.io/框架/React","content":"setState为什么不要在 render 中 setState？setState 会触发 render，造成死循环setState 如何深合并方法一：使用展开运算符方法二：先直接赋值，最后再调一次 setState({})setState 执行过程将传递给 setState 的对象合并到组件的当前状态构建一个新的虚拟 dom将新树与旧树比较，计算出新旧树的节点差异，确定需要更新的真实 dom调用 render 方法更新 UIsetState 同步还是异步与调用时的环境相关在 合成事件 和 生命周期钩子中，setState 是异步的，会把多次调用进行合并，如果需要马上同步去获取新值，setState 可以传入第二个参数，在回调中即可获取最新值在 原生事件 和 setTimeout、setInterval、promise 等异步操作中，setState 是同步的，可以马上获取更新后的值，原因: 原生事件是浏览器本身的实现，与事务流无关，而 setTimeout 是放置于定时器线程中延后执行，此时事务流已结束，因此也是同步原因：在 React 的 setState 函数实现中，会根据一个变量 isBatchingUpdates 判断是直接更新 this.state 还是放到队列中回头再说，而 isBatchingUpdates 默认是 false，也就表示 setState 会同步更新 this.state但是，有一个函数 batchedUpdates，这个函数会把 isBatchingUpdates 修改为 true，而当 React 在调用事件处理函数之前就会调用这个 batchedUpdates就是由 React 控制的事件处理过程 setState 不会同步更新 this.statesetState 在 react 生命周期和合成事件会批量覆盖执行当遇到多个 setState 调用的时候会提取单次传递 setState 对象，将它们进行合并（类似 Object.assign，遇到相同 key 会覆盖前面的 key）合成事件：react 为了解决跨平台，兼容性问题，自己封装了一套事件机制，代理了原生的事件，像在 jsx 中常见的 onClick、onChange批量更新机制在 合成事件 和 生命周期钩子 中，setState 更新队列时，存储的是合并状态(Object.assign)。因此前面设置的 key 值会被后面所覆盖，最终只会执行一次更新setState 函数型式由于 Fiber 及 合并 的问题，官方推荐可以传入 函数 的形式。setState(fn)，在 fn 中返回新的 state 对象即可，例如 this.setState((state, props) =&gt; newState)；使用函数型式，可以用于避免 setState 的批量更新的逻辑，传入的函数将会被 顺序调用setState 合并，在 合成事件 和 生命周期钩子 中多次连续调用会被优化为一次当组件已被销毁，如果再次调用 setState，React 会报错警告，通常有两种解决办法：将数据挂载到外部，通过 props 传入，如放到 Redux 或 父级中在组件内部维护一个状态量 (isUnmounted)，componentWillUnmount 中标记为 true，在 setState 前进行判断"},{"id":"a999cfa0f63e25631e3ae0382b46eabe","isRootIndexFile":false,"isIndexFile":false,"filename":"渲染原理.md","basename":"渲染原理","path":"/home/runner/work/qxtang.github.io/qxtang.github.io/框架/React","content":"渲染原理待完善协调（Reconciler）过程当根节点为不同类型的元素时，React 会拆卸原有树并建立新树当对比两个相同类型的 React 元素时，React 会保留 DOM 节点，仅比对及更新有改变的属性当一个组件更新时，组件实例会保持不变，因此可以在不同的帧保持 state 一致。React 将更新该组件实例的 props 以保证与最新的元素保持一致，并且调用该实例的 componentWillReceiveProps()、componentWillUpdate()、componentDidUpdate()当子元素拥有 key 时，React 使用 key 来匹配原有树上的子元素以及最新树上的子元素，使得树的转换效率得以提高Key 应该具有稳定，可预测，以及列表内唯一的特质，不稳定的 key（比如通过 Math.random() 生成的）会导致许多组件实例和 DOM 节点被不必要地重新创建，这可能导致性能下降和子组件中的状态丢失也可以使用元素在数组中的下标作为 key。这个策略在元素不进行重新排序时比较合适，如果有顺序修改，diff 就会变慢"}]},{"id":"e1bb2da53c15eeacf0aa43254e7c6176","isRootIndexFile":false,"isIndexFile":false,"filename":"HOC、Hooks、Mixin.md","basename":"HOC、Hooks、Mixin","path":"/home/runner/work/qxtang.github.io/qxtang.github.io/框架","content":"HOC、Hooks、Mixin三种实现状态逻辑复用的技术Mixinmixin 缺点会相互依赖，相互耦合，不利于代码维护方法可能会相互冲突，难以追溯React 现在已经不再推荐使用 MixinHOC高阶组件就是一个函数，且该函数接受一个组件作为参数，并返回一个新的增强组件高阶组件自身不是 React API 的一部分，它是一种基于 React 的组合特性而形成的设计模式和编程技巧常见的有 react-redux 里的 connect 和 react-router 中的 withRouter作用：复用组件逻辑，操作状态和参数，渲染劫持HOC 缺点：嵌套地狱：可能出现多层包裹组件的情况，多层抽象同样增加了复杂度和理解成本命名冲突：如果高阶组件多次嵌套，没有使用命名空间的话会产生冲突，然后覆盖老属性HOC 场景和应用权限控制性能监控，包裹组件的生命周期，进行统一埋点日志打点双向绑定组合渲染、条件渲染可以借助 ES7 提供的 Decorators （装饰器）来让写法变得优雅，安装并配置 babel 插件：babel-plugin-transform-decorators-legacy使用注意：不要在 render 方法内创建高阶组件，会导致组件每次都会被卸载后重新挂载不要改变原始组件，高阶组件应该是没有副作用的纯函数，这样破坏了对高阶组件的约定，也改变了高阶组件的初衷，使用高阶组件是为了增强而非改变Hooks 缺点写法上有限制（不能出现在条件、循环中）破坏了 PureComponent、React.memo 浅比较的性能优化效果（为了取最新的 props 和 state，每次 render 都要重新创建事件处函数）在闭包场景可能会引用到旧的 state、props 值React.memo 并不能完全替代 shouldComponentUpdate（因为拿不到 state change，只针对 props change）useState 使用一个元组来返回 value 和 setter，需要输入两次相同的名称来定义一个 state，导致代码看起来很长且笨重参考https://juejin.cn/post/6844903815762673671"},{"id":"f8ba3590330d2ed2455fe2c83dfb642f","isRootIndexFile":false,"isIndexFile":false,"filename":"Redux.md","basename":"Redux","path":"/home/runner/work/qxtang.github.io/qxtang.github.io/框架","content":"Redux一个数据管理中心，可以保证数据健壮性、可追溯和可预测性与 React 无关，独立运行于任何 JavaScript 环境整个应用只有唯一的状态树，所有状态维护在一个 Store 中规定只能通过一个纯函数（Reducer）来描述修改核心组件Store：整个程序的状态/对象树保存在 Store 中，一个工程只有一个 store。具有以下方法供使用：getState 获取 statedispatch 触发 action，更新 statesubscribe 订阅数据变更，注册监听器State：数据Action：用来描述发生了什么事情的对象。作为一个行为载体，用于映射相应的 Reducer，可以成为数据的载体，将数据从应用传递至 store 中，是 store 唯一的数据源Action CreatorReducer：确定状态将如何变化的地方。描述如何修改数据的纯函数，Action 属于行为名称，而 Reducer 便是修改行为的实质定义 ActionReact 中的 Action 必须具有 type 属性该属性指示正在执行的类型必须将它们定义为字符串常量，并且还可以向其添加更多的属性Reducer 的作用纯函数，规定应用程序的状态怎样因响应 action 而改变通过接受先前的状态和 action 来工作，返回一个新的状态它根据操作的类型确定需要执行哪种更新，然后返回新的值如果不需要完成任务，会返回原来的状态为什么 reducer 中不能做异步操作（为什么是纯函数）使用纯函数才能保证相同输入得到相同输出，保证状态的可预测，如果有副作用，那么返回的 state 就不确定redux 的设计思想就是不产生副作用，数据更改的状态可回溯，所以 redux 中处处都是纯函数React-ReduxProvider: 从最外部封装了整个应用，将 store 通过 context 传入组件中connect：一个高阶组件，负责连接 React 和 Redux，可以方便在 React 组件中使用 Redux异步 Action 方案使用 redux-thunk、redux-saga、dva 等工具redux-thunk 在一个 action 中返回一个函数执行异步操作，异步操作结束后，再去 dispatch 另一个 actionredux-saga：generator 风格dva：基于 redux-saga源码实现创建一个状态中心（state），通过纯函数来对状态中心的数据进行修改，然后将修改后的结果以发布订阅的方式通知到所有订阅者，从而达到一个共享状态的效果Redux 的核心是函数式编程，使用无副作用的同步函数 action 来触发 reducer 对数据进行修改Redux 的创建函数是 createStore，这个函数的作用是创建一个 store 对象，其中关键步骤是将 reducer 利用闭包存储在函数内导出了 subscribe 函数，subscribe 函数内部将订阅者添加到一个订阅者列表中，等待通知导出了 dispatch 函数，在 dispatch 内部执行了 reducer 函数，并将 action 作为参数传入到 reducer 中将 reducer 函数的返回结果（新的 state）存在 currentState 中，同时通知所有的订阅者 state 已经更新订阅者可以通过 getState 得到最新的 stateRedux 中间件的原理就是 Decorator 装饰器模式，将中间件经过一些装饰器（中间件）装饰以后，返回一个增强型的 dispatchconnect 实现获取 state: connect 通过 context 获取 Provider 中的 store，通过 store.getState 获取整个 store tree 上所有 state将 state 和 action 通过 props 的方式传入到原组件内部，wrapWithConnect 返回一个 ReactComponent 对象 Connect，Connect 重新 render 外部传入的原组件 WrappedComponent，并把 connect 中传入的 mapStateToProps, mapDispatchToProps 与组件上原有的 props 合并后，通过属性的方式传给 WrappedComponent监听 store tree 变化：connect 缓存了 store tree 中 state 的状态，通过当前 state 状态和变更前 state 状态进行比较，从而确定是否调用 this.setState 触发 Connect 及其子组件的重新渲染const connect = (mapStatetoProps, mapActionstoProps) =&gt; (WrapperComponent) =&gt; {  return class Connect extends Component {    static contextType = storeContext; // provide 定义的 context 对象    constructor(props) {      super();    }    componentWillMount() {      const store = this.context;      store.subscribe(this._updateProps);      this._updateProps(); // 初始化    }    _updateProps = () =&gt; {      const store = this.context;      // 传入state和props      const stateProps = mapStatetoProps ? mapStatetoProps(store.getState(), this.props) : {};      // 传入dispatch和props      const actionProps = mapActionstoProps ? mapActionstoProps(store.dispatch, this.props) : {};      //整合props，传给接收的组件      this.setState({        allProps: {          ...stateProps,          ...actionProps,          ...this.props,        },      });    };    render() {      return &lt;WrapperComponent {...this.state.allProps} /&gt;;    }  };};"},{"id":"3553975a46c992a32da3df54ac64a2b2","isRootIndexFile":false,"isIndexFile":true,"filename":"index.md","basename":"框架","path":"/home/runner/work/qxtang.github.io/qxtang.github.io/框架","content":"框架React 与 Vue 异同React 是手动挡，Vue 是自动挡异：react 是函数式思想，all in js ，jsx 语法，js 操控 cssreact 是单向数据流react 每当应用的状态被改变时，全部子组件都会重新渲染。当然，这可以通过 shouldComponentUpdate 这个生命周期方法来进行控制，如果为 true 继续渲染、false 不渲染，但 Vue 将此视为默认的优化react 对 ts 更友好一些vue 是响应式思想，也就是基于数据可变的。把 html、js、css、组合到一起，也可以通过标签引擎组合到一个页面中vue 是双向绑定Vue 宣称可以更快地计算出 Virtual DOM 的差异，这是由于它在渲染过程中，会跟踪每一个组件的依赖关系，不需要重新渲染整个组件树同：使用 Virtual DOM，都有 jsx，性能好都是数据驱动视图什么是 mvvmModel-View-ViewModel 的缩写mvvm 是一种设计思想Model 层代表数据模型，也可以在 Model 中定义数据修改和操作的业务逻辑View 代表 UI 组件，它负责将数据模型转化成 UI 展现出来ViewModel 是一个同步 View 和 Model 的对象在 MVVM 架构下，View 和 Model 之间并没有直接的联系，而是通过 ViewModel 进行交互什么是受控组件受控：value 和 state 绑在一起的非受控：可通过浏览器 api 获取值单向数据流规定数据只能由外层组件向内层组件进行传递和更新组件的 props 是只读的让组件之间的关系变得简单、可预测、所有状态的改变可记录、可跟踪，源头易追溯否则容易导致数据紊乱、出现不可控操作如果数据在兄弟子组件之间共享，那么数据应该存储在父组件，并同时传递给需要数据的两个子组件什么是双向绑定数据与视图的响应式设计。具体表现为：View 的改变（填写表单）能实时让 Model 发生变化，而 Model 的变化也能实时更新 View什么是单向绑定所有数据只有一份，一旦数据变化，就去更新页面(只有 data--&gt;DOM，没有 DOM--&gt;data)用户在页面作出更新，需要用户手动收集(双向绑定是自动收集)，在合并到原有的数据中双向绑定、单向绑定的优缺点单向绑定：数据流也是单向的，对于复杂应用来说是实施统一状态管理（如 redux）的前提双向绑定：在一些需要实时反应用户输入的场合会非常方便（如多级联动菜单）。但常认为复杂应用中这种便利比不上引入状态管理带来的优势。因为不知道状态什么时候发生改变，是谁造成的改变，数据变更也不会通知"},{"id":"464e637f0da9231bc777743987827f47","isRootIndexFile":false,"isIndexFile":false,"filename":"spa 路由原理.md","basename":"spa 路由原理","path":"/home/runner/work/qxtang.github.io/qxtang.github.io/框架","content":"spa 路由原理基本原理页面切换实质是切换 url，监听 url 变化，从而渲染不同的页面组件。hash 模式hash 包含在 URL 中，但不包括在请求中，用来指导浏览器动作，修改 hash 不会刷新页面hash 模式下，井号之前的内容才会被包含在请求中，因此对于后端来说，即使没有做到对路由的全覆盖，也不会返回 404 错误原理是监听 hashchange 事件执行对应回调history 模式历史记录、网页标题修改：HTML5 特性 pushState 和 replaceState监听 window 对象的 popState 事件执行对应回调更新页面，一个文档的 history 对象出现变化时（在浏览器某些行为下触发，比如点击后退、前进按钮或者调用 history.back()、history.forward()、history.go()方法），就会触发 popstate 事件history 模式下，前端的 URL 和实际向后端发起请求的 URL 一致。服务端如果缺少对该页面请求的处理，就会返回 404 错误需要服务器的支持：需要在服务端增加一个覆盖所有情况的候选资源：比如 URL 匹配不到任何资源时，则返回同一个 index.html 页面，这个页面就是前端应用的入口页面更推荐用 history 模式，history 模式更利于 seo 优化，url 也比较美观"},{"id":"c8cacf58206b6565ea69383e6fbdf7b4","isRootIndexFile":false,"isIndexFile":false,"filename":"虚拟 Dom 与 diff.md","basename":"虚拟 Dom 与 diff","path":"/home/runner/work/qxtang.github.io/qxtang.github.io/框架","content":"虚拟 Dom 与 diff虚拟 dom使用 javascript 对象表示 DOM 结构的树形数据结构这个树结构包含整个 DOM 结构的信息真实 DOM 的内存表示，一种编程概念为框架带来了跨平台的能力，抽象了原本的渲染过程，实现了跨平台的能力结合 diff 算法，可以减少 JavaScript 操作真实 DOM 的带来的性能消耗并不是所有情况使用虚拟 DOM 都提高性能，是针对在复杂的的项目使用。如果简单的操作，使用虚拟 DOM，要创建虚拟 DOM 对象等等一系列操作，还不如普通的 DOM 操作优点：跨平台直接操作/频繁操作 DOM 的性能差操作虚拟 DOM 不会立马进行重绘回流操作，一次性比较并修改真实 DOM 中需要改的部分，再操作 dom缺点：无法进行极致优化：在一些性能要求极高的应用中虚拟 DOM 无法进行针对性的极致优化，比如 VScode 采用直接手动操作 DOM 的方式进行极端的性能优化diff算法描述一种对比算法，对比出是哪个虚拟节点更改了，找出这个虚拟节点，并只更新这个虚拟节点所对应的真实节点，而不用更新其他数据没发生改变的节点，实现精准更新真实 DOM，进而提高效率在某一时间节点调用 React 的 render() 方法，会创建一棵由 React 元素组成的树。在下一次 state 或 props 更新时，相同的 render() 方法会返回一棵不同的树。React 需要基于这两棵树之间的差别来判断如何有效率的更新 UI 以保证当前 UI 与最新的树保持同步新旧虚拟 DOM 对比的时候，Diff 算法比较只会在同层级进行，不会跨层级比较。所以 Diff 算法是深度优先算法，时间复杂度 O(n)diff 过程把树形结构按照层级分解，只比较同级元素给列表结构的每个单元添加唯一的 key 属性，方便比较同一类型的元素：保留 DOM 节点，仅比对及更新有改变的属性元素类型不同：拆卸原有的树并且建立起新的树如果有子节点，对子节点进行递归key 的作用Keys 是一个辅助标识，用于追踪列表中被修改的元素在 diff 算法中，会借助元素的 key 值来判断该元素是不是新创建的，而减少不必要的重新渲染key 为什么不能用下标组件实例是基于它们的 key 来决定是否更新以及复用如果 key 是一个下标，那么修改顺序时会修改当前的 key导致非受控组件的 state（比如输入框）可能相互篡改，会出现无法预期的变动参考https://juejin.cn/post/6844903806132568072https://juejin.cn/post/6990582632270528525https://juejin.cn/post/6994959998283907102https://www.zhihu.com/question/31809713https://juejin.cn/post/6844903607913938951"}]},{"id":"fb9a19d530d65e394c0a161b3d801ad0","isRootIndexFile":false,"isIndexFile":false,"filename":"AST 抽象语法树.md","basename":"AST 抽象语法树","path":"/home/runner/work/qxtang.github.io/qxtang.github.io","content":"AST 抽象语法树解析器 Parser把 js 源码转化为抽象语法树（AST）常用解析器https://github.com/babel/babel/tree/master/packages/babel-parserhttps://github.com/acornjs/acorn解析步骤两步：词法分析、语法分析词法分析把字符串形式的代码转换为 令牌（tokens）流，可以把令牌看作是一个扁平的语法片段数组例如：// 源n * n;// 词法分析结果[  { type: { ... }, value: &quot;n&quot;, start: 0, end: 1, loc: { ... } },  { type: { ... }, value: &quot;*&quot;, start: 2, end: 3, loc: { ... } },  { type: { ... }, value: &quot;n&quot;, start: 4, end: 5, loc: { ... } },]每一个 type 有一组属性来描述该令牌：const token = {  type: {    label: &#x27;name&#x27;,    keyword: undefined,    beforeExpr: false,    startsExpr: true,    rightAssociative: false,    isLoop: false,    isAssign: false,    prefix: false,    postfix: false,    binop: null,    updateContext: null,  },};语法分析根据词法分析的结果，也就是令牌 tokens，将其转换成 AST// 源function square(n) {  return n * n;}// ATSconst ast = {  type: &#x27;FunctionDeclaration&#x27;,  id: {    type: &#x27;Identifier&#x27;,    name: &#x27;square&#x27;,  },  params: [    {      type: &#x27;Identifier&#x27;,      name: &#x27;n&#x27;,    },  ],  body: {    type: &#x27;BlockStatement&#x27;,    body: [      {        type: &#x27;ReturnStatement&#x27;,        argument: {          type: &#x27;BinaryExpression&#x27;,          operator: &#x27;*&#x27;,          left: {            type: &#x27;Identifier&#x27;,            name: &#x27;n&#x27;,          },          right: {            type: &#x27;Identifier&#x27;,            name: &#x27;n&#x27;,          },        },      },    ],  },};应用IDE 使用，如代码风格检测(eslint 等)、代码的格式化，代码高亮，代码错误等等代码的混淆压缩转换代码工具，如 babelvue 模板编译过程prettierbabel-plugin-import将 antd 组件 import 语句转换成按需引入写法的 babel 插件参考https://segmentfault.com/a/1190000016231512https://juejin.cn/post/6844903725228621832"},{"id":"e3db49d633625ac1552e7dca23fb879e","isRootIndexFile":false,"isIndexFile":false,"filename":"AST抽象语法树.md","basename":"AST抽象语法树","path":"/home/runner/work/qxtang.github.io/qxtang.github.io","content":"AST 抽象语法树参考https://segmentfault.com/a/1190000016231512https://juejin.cn/post/6844903725228621832解析器 Parser把 js 源码转化为抽象语法树（AST）常用解析器https://github.com/babel/babel/tree/master/packages/babel-parserhttps://github.com/acornjs/acorn解析步骤两步：词法分析、语法分析词法分析把字符串形式的代码转换为 令牌（tokens）流，可以把令牌看作是一个扁平的语法片段数组例如：// 源n * n;// 词法分析结果[  { type: { ... }, value: &quot;n&quot;, start: 0, end: 1, loc: { ... } },  { type: { ... }, value: &quot;*&quot;, start: 2, end: 3, loc: { ... } },  { type: { ... }, value: &quot;n&quot;, start: 4, end: 5, loc: { ... } },]每一个 type 有一组属性来描述该令牌：const token = {  type: {    label: &#x27;name&#x27;,    keyword: undefined,    beforeExpr: false,    startsExpr: true,    rightAssociative: false,    isLoop: false,    isAssign: false,    prefix: false,    postfix: false,    binop: null,    updateContext: null,  },};语法分析根据词法分析的结果，也就是令牌 tokens，将其转换成 AST// 源function square(n) {  return n * n;}// ATSconst ast = {  type: &#x27;FunctionDeclaration&#x27;,  id: {    type: &#x27;Identifier&#x27;,    name: &#x27;square&#x27;,  },  params: [    {      type: &#x27;Identifier&#x27;,      name: &#x27;n&#x27;,    },  ],  body: {    type: &#x27;BlockStatement&#x27;,    body: [      {        type: &#x27;ReturnStatement&#x27;,        argument: {          type: &#x27;BinaryExpression&#x27;,          operator: &#x27;*&#x27;,          left: {            type: &#x27;Identifier&#x27;,            name: &#x27;n&#x27;,          },          right: {            type: &#x27;Identifier&#x27;,            name: &#x27;n&#x27;,          },        },      },    ],  },};应用IDE 使用，如代码风格检测(eslint 等)、代码的格式化，代码高亮，代码错误等等代码的混淆压缩转换代码工具，如 babelvue 模板编译过程prettierbabel-plugin-import将 antd 组件 import 语句转换成按需引入写法的 babel 插件"},{"id":"8578439a28ea7be119c5e0f09881c164","isRootIndexFile":false,"isIndexFile":false,"filename":"demo.md","basename":"demo","path":"/home/runner/work/qxtang.github.io/qxtang.github.io","content":"H1H2H3段落段落段落段落段落段落段落段落段落段落段落段落段落段落段落段落段落段落段落段落段落段落段落段落段落段落段落段落段落段落段落段落段落段落段落段落段落段落段落段落段落段落段落段落段落段落段落段落段落段落段落段落段落段落段落段落段落段落段落段落段落段落段落段落段落段落段落段落段落段落段落段落段落段落段落段落段落段落段落段落段落段落段落段落段落段落段落段落段落段落段落段落段落段落段落段落段落段落段落段落段落段落段落段落段落段落段落段落段落段落段落段落段落段落段落段落段落段落段落段落段落段落段落段落段落段落段落段落段落段落段落段落段落段落段落段落段落段落段落段落段落段落段落段落段落段落段落段落段落段落段落段落段落段落段落Here is a footnote reference [1]* 要显示原本用于格式化 Markdown 文档的字符，请在字符前面添加反斜杠字符 \\H2029th链接链接（当前页面打开）https://www.baidu.com/marked强调斜体斜体加粗行内代码console.log(&#x27;hello&#x27;);引用First itemSecond itemThird itemFourth itemFirst itemSecond itemThird itemIndented itemIndented itemFourth item First item Second item Third item Fourth itemImageinfonotetipwarningdangerHere is the footnote. ↩︎"},{"id":"index","isRootIndexFile":true,"isIndexFile":true,"filename":"index.md","basename":"index","path":"/home/runner/work/qxtang.github.io/qxtang.github.io","content":"✒ 工作与日常学习笔记via：doc-builder"},{"id":"906880e21cbf1c394f3f24b9b0a64b83","isRootIndexFile":false,"isIndexFile":false,"filename":"事件循环.md","basename":"事件循环","path":"/home/runner/work/qxtang.github.io/qxtang.github.io","content":"事件循环是什么js 是设计成单线程的，为了更好的处理异步任务，所以设计了事件循环机制js 为什么是单线程与 js 的用途有关如果 js 被设计了多线程，如果有一个线程要修改一个 dom 元素，另一个线程要删除这个 dom 元素，渲染器就不知道以哪个线程为准，DOM 渲染的结果不可预期多线程具有复杂性，编码的复杂性会增高为了利用多核 CPU 的计算能力，HTML5 提出 Web Worker 标准，允许 JavaScript 脚本创建多个线程，但是子线程完全受主线程控制，且不得操作 DOM。所以，这个新标准并没有改变 JavaScript 单线程的本质同步任务和异步任务JavaScript 单线程任务分为同步任务和异步任务JavaScript 有一个主线程（js 引擎线程）和调用栈（执行栈），所有的任务都会被放到调用栈等待主线程执行，同步任务会在调用栈中按顺序依次执行，异步任务会在异步任务有了结果后，将注册的回调函数放入任务队列中，等待主线程空闲的时候（调用栈被清空），被读取到栈内等待主线程的执行在遇到异步任务时（setTimeout、DOM 事件、ajax 等），会转交给浏览器的其他工作线程（事件触发线程、定时器线程）执行，执行完之后将回调函数放入到任务队列事件触发线程管理一个任务队列，调用栈中的代码调用某些异步 API 时会在任务队列中添加事件，异步任务触发条件达成，将回调事件放到任务队列中当主线程的任务执行完了（执行栈空了），js 会去询问事件队列有没有回调函数需要执行（所以 setTimeout 0 会等到最后才执行）如此循环往复，形成事件循环机制事件循环不一定每轮都伴随着重渲染，但是如果有微任务，一定会伴随着微任务执行宏任务和微任务异步任务队列又分微任务队列和宏任务队列宏任务是由宿主发起的，而微任务由 JavaScript 自身发起宏任务（多为运行环境 api）：script 标签中的代码、UI 渲染、UI 交互、setTimeout/setInterval/setImmediate、DOM 事件、postMessage、ajax 请求、requestAnimationFrame宏任务代表一个个离散的、独立工作单元，运行完任务后，浏览器可以继续其他调度，如重新渲染页面的 UI 或执行垃圾回收微任务（多为语法）：Promise.then\\catch\\finally、MutationObserver、async/await、process.nextTick（NodeJS）微任务更新应用程序的状态，但必须在浏览器任务继续执行其他任务之前执行，浏览器任务包括重新渲染页面的 UI。微任务的案例包括 promise 回调函数、DOM 发生变化等。微任务需要尽可能快地、通过异步方式执行，同时不能产生全新的微任务。微任务使得我们能够在重新渲染 UI 之前执行指定的行为，避免不必要的 UI 重绘，UI 重绘会使应用程序的状态不连续两者区别：宏任务：DOM 渲染后触发微任务：DOM 渲染前触发当满足执行条件时，宏任务(macroTask) 和 微任务(microTask) 会各自被放入对应的队列：宏队列(Macrotask Queue) 和 微队列(Microtask Queue) 中等待执行事件循环流程先会执行主进程栈中的内容，栈中的内容执行后执行微任务，微任务清空后再执行宏任务，先取出一个宏任务，再去执行微任务，然后在取宏任务清微任务这样不停的循环while (true) {  queue = getNextQueue(); // 如果是多队列情况则取一个队列  task = queue.pop(); // 取第一个任务  execute(task); // 执行任务  // 如果有微任务那么执行所有的微任务  while (microTasks.hasTasks()) {    doMicroTask();  }  // 浏览器渲染阶段  if (isRepaintTime()) {    // 动画队列有任务 那么执行所有动画 task(requestAnimationFrame)    animationTasks = animationQueue.copyTasks();    for (task in animationTasks) {      doAnimationTask(task);    }    // 绘制    repaint();  }}当主线程结束，从宏任务队列中，按照入队顺序，找到第一个执行的宏任务，放入调用栈，开始执行执行完该宏任务下所有同步任务后，即调用栈清空后，该宏任务被推出宏任务队列，然后微任务队列开始按照入队顺序，依次执行其中的微任务，直至微任务队列清空当微任务队列清空后，一个事件循环结束接着从宏任务队列中，找到下一个执行的宏任务，开始第二个事件循环，直至宏任务队列清空为止当微任务队列处理完成并清空时，事件循环会检查是否需要更新 UI 渲染，如果是，则会重新渲染 UI 视图单次循环迭代中，最多处理一个宏任务（其余的在队列中等待），而队列中的所有微任务都会被处理为什么微任务执行更早微任务是语法规定的宏任务执行时间一般比较长宏任务是由浏览器规定的（web api）每一次宏任务开始之前一定是伴随着一次 event loop 结束的，而微任务是在一次 event loop 结束前执行的页面渲染每次当一次事件循环结束后，即一个宏任务执行完成后以及微任务队列被清空后，浏览器就会进行一次页面更新渲染。通常我们浏览器页面刷新频率是 60fps，也就是意味着 16.67ms 要刷新一次，因此我们也要尽量保证一次事件循环控制在 16.67ms 之内，这也是我们需要做代码性能优化的一个原因。requestAnimationFrame 在重新渲染屏幕之前执行，非常适合用来做动画resize 和 scroll 事件其实自带节流，它只在 Event Loop 的渲染阶段去派发事件到 EventTarget 上执行 setTimeout/setInterval 时发生了什么JS 引擎线程通知定时触发器线程，间隔一个时间后，会触发一个回调事件， 而定时触发器线程在接收到这个消息后，会在等待的时间后，将回调事件放入到由事件触发线程所管理的事件队列中执行 XHR/fetch 时发生了什么JS 引擎线程通知异步 http 请求线程，发送一个网络请求，并制定请求完成后的回调事件， 而异步 http 请求线程在接收到这个消息后，会在请求成功后，将回调事件放入到由事件触发线程所管理的事件队列中参考https://juejin.cn/post/6844904165462769678https://juejin.cn/post/6844903919789801486"},{"id":"91cddc44e8c0f27fe5a0290f334ada7e","isRootIndexFile":false,"isIndexFile":false,"filename":"单元测试.md","basename":"单元测试","path":"/home/runner/work/qxtang.github.io/qxtang.github.io","content":"单元测试概念是指对软件中的最小可测试单元进行检查和验证当通过手动重新运行来测试代码时，很容易漏掉一些东西对于单元测试中单元的含义，一般来说，要根据实际情况去判定其具体含义，如 C 语言中单元指一个函数，Java 里单元指一个类，图形化的软件中可以指一个窗口或一个菜单等。总的来说，单元就是人为规定的最小的被测功能模块。单元测试是在软件开发过程中要进行的最低级别的测试活动，软件的独立单元将在与程序的其他部分相隔离的情况下进行测试自动化测试测试是独立于代码的以各种方式运行我们的函数，并将结果与预期结果进行比较行为驱动开发（BDD）规范先行，实现在后简单来说就是首先写一些暂时无法通过的测试，然后去实现它们包含了三部分内容：测试、文档和示例前端常用单元测试框架mocha、Jest 提供了单元测试所需的各种 API，你可以使用它们来对你的代码进行单元测试参考https://zh.javascript.info/testing-mocha"},{"id":"c806b6f5f1e6d1c68f72fae33a8626eb","isRootIndexFile":false,"isIndexFile":false,"filename":"图标方案.md","basename":"图标方案","path":"/home/runner/work/qxtang.github.io/qxtang.github.io","content":"图标方案https://juejin.cn/post/6844903517564436493"},{"id":"c271045a3b943be978d1785dadf28253","isRootIndexFile":false,"isIndexFile":false,"filename":"微前端.md","basename":"微前端","path":"/home/runner/work/qxtang.github.io/qxtang.github.io","content":"微前端微前端不一定是一种新技术，也不必太复杂。只要我们保证代码隔离和团队自治，无论我们采用何种技术栈，我们都可以达到相同的效果由来工程越来越大，打包越来越慢团队人员多，产品功能复杂，代码冲突频繁、影响面大在后端服务开发中，为了解决庞大的一整块后端服务带来的变更与扩展方面的限制，出现了微服务架构把应用程序设计成一系列松耦合的细粒度服务允许使用不同的编程语言来编写不同服务前端也出现这样的问题，即，一种由独立交付的多个应用组成整体的架构风格。将前端应用分解成一些更小更简单的能够独立开发、测试、部署的小块，而在用户看来仍然是内聚的单个产品比起一整块的前端代码库，微前端架构下的代码库倾向于更小/简单、更容易开发传统开发的缺点历史项目，祖传代码交付压力，当时求快就近就熟，当时求稳导致技术栈落后，甚至强行混用多种技术栈，耦合混乱，不敢动，牵一发动全身每个微前端都应具备有自己的持续交付流水线（包括构建、测试并部署到生产环境），且要能独立部署，不必过多考虑其它代码库的状态意义技术栈无关，主框架不限制接入应用的技术栈，微应用具备完全自主权独立开发、独立部署，微应用仓库独立，前后端可独立开发，部署完成后主框架自动完成同步更新增量升级，在面对各种复杂场景时，我们通常很难对一个已经存在的系统做全量的技术栈升级或重构，而微前端是一种非常好的实施渐进式重构的手段和策略独立运行时，每个微应用之间状态隔离，运行时状态不共享微前端架构旨在解决单体应用在一个相对长的时间跨度下，由于参与的人员、团队的增多、变迁，从一个普通应用演变成一个巨石应用后，随之而来的应用不可维护的问题。这类问题在企业级 Web 应用中尤其常见。技术方案package 集成将每个微前端发布为一个 npm 包，并让容器应用程序将所有微前端应用作为依赖项这意味着只要有一个包更新，即使是小版本，宿主也要重新构建一次。不建议使用这种方案iframe优点：隔离得很彻底缺点：速度慢，浏览器处理 iframe 要启动更多的进程；页面刷新难以保存状态，路由、历史记录等等使用 umd 包通过 script 标签引入放在 cdn 上的资源，可以始终保持最新，子应用更新不需要通知宿主具有完全的灵活性，宿主可以控制什么时候载入每个应用，以及渲染应用时额外传参数vite 库模式：https://cn.vitejs.dev/guide/build.html#library-mode微前端架构存在的一些普遍问题下载量独立构建的 JavaScript 文件可能导致重复的公共依赖，从而增加用户的下载量例如，如果每个微应用都包括自己的 React 副本，那么用户就得多次下载 React环境差异在本地开发时无法把所有微应用和对应的后端都启动起来，不得不在本地进行环境的简化。如果开发环境和生产环境不严谨一致，容易造成问题。如果开发者想要完全模拟生产环境，会比较耗时治理复杂性要管理更多的东西：更多的代码库、更多的工具、更多的构建管道、更多的服务器、更多的域名等"},{"id":"d101024edcca4d6dff270c2fb6d8b6bd","isRootIndexFile":false,"isIndexFile":false,"filename":"文件上传&下载.md","basename":"文件上传&下载","path":"/home/runner/work/qxtang.github.io/qxtang.github.io","content":"文件上传&amp;下载下载流式文件axios 请求配置 responseType 设为 blob使用开源工具 FileSaver 进行保存判断文件类型使用开源工具：https://github.com/sindresorhus/file-typeinput 元素 accept 属性只根据文件后缀名进行拦截，用户手动修改可以绕过可以通过读取文件中的二进制数据来识别正确的文件类型：https://juejin.cn/post/6971935704938971173对于某一些类型的文件，起始几个字节内容都是固定的，根据这几个字节的内容可以判断文件类型，可通过 FileReader API 来读取实现大文件并发上传参考：https://mp.weixin.qq.com/s/-iSpCMaLruerHv7717P0Wg并发控制结合 Blob.slice获取待上传文件计算文件 md5 值发起 get 请求判断文件是否已存在不存在则执行上传，并发上传分块，并通知后端实现大文件并行下载参考：https://mp.weixin.qq.com/s?__biz=MzI2MjcxNTQ0Nw==&amp;mid=2247490849&amp;idx=1&amp;sn=9d062c04baeb629d9b69a9fb4e7c3599&amp;scene=21使用 http 范围请求的特性先发送一个 head 类型的请求，从响应头中读取 Content-Length，获取文件大小参考https://juejin.cn/post/6980142557066067982https://juejin.cn/post/6989413354628448264"},{"id":"c7291e11fd38fa3a59efe315b9a3ac69","isRootIndexFile":false,"isIndexFile":false,"filename":"柯里化.md","basename":"柯里化","path":"/home/runner/work/qxtang.github.io/qxtang.github.io","content":"柯里化把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术意义让人们将关注的重点聚焦到函数本身，而不因冗余的数据参数分散注意力，单一参数的纯函数是最简单的，目的单纯、职责单一、灵活且通用减少耦合增强其可维护性缺点过度使用会占用较大的堆栈空间经过柯里化之后，函数的通用性有所降低，但是适用性有所提高实现// 手写柯里化const add = function (a, b, c) {  return a + b + c;};function curry(fn) {  return function curryFun(...args) {    if (args.length &lt; fn.length) {      return function () {        return curryFun([...args, ...arguments]);      };    }    return fn(...args);  };}const curried = curry(add);const a = curried(1)(9)(3);const b = curried(2, 8)(6);console.log({ a, b });参考https://zh.javascript.info/currying-partials"},{"id":"1478f616d95f169a35afbf80de6d5b7c","isRootIndexFile":false,"isIndexFile":false,"filename":"设计稿多端适配方案.md","basename":"设计稿多端适配方案","path":"/home/runner/work/qxtang.github.io/qxtang.github.io","content":"设计稿多端适配方案如何让不同尺寸的屏幕能以正常比例呈现设计稿？动态修改 font-size + rem 方案动态修改 html 标签 font-size，样式单位统一用 rem，数值为设计稿尺寸除以 basevar fn = function () {  var designWidth = 1920; // 设计稿尺寸  var base = 16; // 1rem 的占比，不要小于 12  var html = document.getElementsByTagName(&#x27;html&#x27;)[0];  var clientWidth = document.body.clientWidth || document.documentElement.clientWidth;  html.style.fontSize = (clientWidth / designWidth) * base + &#x27;px&#x27;;};document.addEventListener(&#x27;DOMContentLoaded&#x27;, function () {  fn();});window.onresize = function () {  fn();};弊端和根元素 font-size 值强耦合，系统字体放大或缩小时，会导致布局错乱html 文件头部需插入一段 js 代码相较之下，vw 单位兼容性比 rem 稍差，ios8、安卓 4.4 及以上才完全支持。这也是为什么之前 rem 布局一直更流行的原因。目前 ios8、安卓 4.4 以下的用户已经非常少了，caniuse 上面显示，在中国这部分用户只有 1.2%，比例已经非常低了设计稿 px 转 vw 方案（推荐）1vw 表示屏幕宽度的 1%把所有需要适配屏幕大小等比缩放的元素都使用 vw 做为单位。不需要缩放的元素使用 px 做单位举个例子。设计师交付的设计稿宽度是 750px，设计稿上一个标题的 fontSize 标注尺寸是 32px。(32/750)*100% = 4.27% ，换句话说这个标题的字号占屏幕宽度的占比是 4.27%，不管任何屏幕都是如此。4.27% 即 4.27vw。可以使用 post-css 专门的插件做转换，或使用预处理样式语言中的函数@baseScreenWidth: 320;.px2vw(@name, @px) {  @{name}: (@px / @baseScreenWidth) * 100vw;}@function px2vw($px) {  @return $px * 100vw / 750;}// 以iphone7尺寸@2x 750像素宽的视觉稿为例@function vw($px) {  @return ($px / 750) * 100vw;}// 假设一个div元素在视觉稿中，宽度为120px，字体大小为12pxdiv {  width: vw(120);  font-size: vw(12);}dpr 是什么设备像素比，通过 window.devicePixelRatio 获取是设备上物理像素和设备独立像素（dips）的比例，window.devicePixelRatio = 物理像素 / dips简单的讲其实就是 dpr 决定了 css 1px 等于多少屏幕物理像素物理像素显示器上最小的物理显示单元，在操作系统的调度下，每一个设备像素都有自己的颜色值和亮度值设备独立像素（dips）也叫密度无关像素，可以认为是计算机坐标系统中得一个点，这个点代表一个可以由程序使用的虚拟像素（比如: css 像素），然后由相关系统转换为物理像素viewport用于定义视口的各种行为：视口宽度、初始缩放、最小最大缩放比例、是否允许用户手动缩放"}]