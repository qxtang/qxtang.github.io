[{"id":"c60ace825dfbfff92f5899606e2459ab","dirname":"前端","filename":"","basename":"","path":"/home/runner/work/qxtang.github.io/qxtang.github.io","children":[{"id":"4a0b5ccf4d13dfe7fd4a141360f94ce0","dirname":"CSS","filename":"","basename":"","path":"/home/runner/work/qxtang.github.io/qxtang.github.io/前端","children":[{"id":"addc9af4595edb210c98610f6f3bd530","isRootIndexFile":false,"isIndexFile":false,"filename":"Flex 布局.md","basename":"Flex 布局","path":"/home/runner/work/qxtang.github.io/qxtang.github.io/前端/CSS","content":"Flex 布局意义相比以前 display + position + float 的方式布局，Flex 可以更简便地实现多种页面布局flex: 1 的意思？是 flex-grow, flex-shrink 和 flex-basis 的简写，默认值为 0 1 auto。后两个是可选属性定义项目的放大比例容器属性flex-direction决定主轴方向flex-wrap让 Flex 项目换行排列默认子元素都排在一条线上nowrap(默认)：所有子元素单行排列wrap：所有子元素多行排列，按从上到下的顺序wrap-reverse：所有子元素多行排列，按从下到上的顺序flex-flowflex-direction 属性和 flex-wrap 属性的简写形式.box {  flex-flow: &lt; &#x27;flex-direction&#x27; &gt; || &lt; &#x27;flex-wrap&#x27; &gt;;}justify-content定义了项目在主轴上的对齐方式及额外空间的分配方式.box {  justify-content: flex-start | flex-end | center | space-between | space-around | space-evenly;}align-items定义项目在交叉轴上的对齐方式.box {  align-items: stretch | flex-start | flex-end | center | baseline;}align-content定义了在交叉轴方向的对齐方式及额外空间分配，类似于主轴上 justify-content 的作用.box {  align-content: stretch | flex-start | flex-end | center | space-between | space-around;}align-content 与 align-items 的区别？align-content 只适用多行的 flex 容器，也就是 flex 容器中的子项不止一行时该属性才有效果当 flex 容器在交叉轴上有多余的空间时，将子项作为一个整体（属性值为：flex-start、flex-end、center 时）进行对齐效果如下：子元素属性order控制元素在容器中的先后顺序从小到大顺序排列，可以为负值，默认为 0flex-grow正整数，定义项目的放大比例flex-shrink定义了元素的缩小比例，默认为 1即如果空间不足，该元素将被挤压0 表示不缩小，负值无效flex-basis定义元素在分配额外空间之前的缺省尺寸属性值可以是长度（20%，10rem 等）或者关键字 auto，默认值 autoflexflex-grow, flex-shrink 和 flex-basis 的简写，默认值：0 1 auto，后两个可选align-self定义项目的对齐方式，可覆盖 align-items，默认 auto"},{"id":"eae392087397b37c08ef46f26c990033","isRootIndexFile":false,"isIndexFile":true,"filename":"index.md","basename":"CSS","path":"/home/runner/work/qxtang.github.io/qxtang.github.io/前端/CSS","content":"CSS选择器优先级!important内联样式ID 选择器类选择器属性选择器伪类选择器标签选择器元素选择器/关系选择器/伪元素选择器相邻兄弟选择器/子选择器/后代选择器通配符选择器 *可继承 与 不可继承属性可继承：font-family font-weight font-size color text-align line-height visibility其余不可继承displaynone 元素不显示，并且会从文档流中移除block 块类型。默认宽度为父元素宽度，可设置宽高，换行显示inline 行内元素类型。默认宽度为内容宽度，不可设置宽高，同行显示inline-block 默认宽度为内容宽度，可以设置宽高，同行显示list-item 像块类型元素一样显示，并添加样式列表标记table 此元素会作为块级表格来显示inherit 规定应该从父元素继承 display 属性的值隐藏元素的方法display: none: 渲染树不会渲染对象visibility: hidden: 元素在页面中仍占据空间，但是不会响应绑定的监听事件opacity: 0: 元素在页面中仍然占据空间，并且能够响应元素绑定的监听事件position: absolute: 通过使用绝对定位将元素移除可视区域内，以此来实现元素的隐藏z-index: 负值:来使其他元素遮盖住该元素，以此来实现隐藏transform: scale(0,0): 将元素缩放为 0，元素仍在页面中占据位置，但是不会响应绑定的监听事件层叠上下文z-index 属性仅在定位元素上有效果，定义了 position 属性且值为非 static 值的元素产生层叠上下文：设置 position 为非 static 值CSS3 新特性选择器 nth-child边框圆角渐变色颜色透明度多列布局弹性布局过渡、动画flex媒体查询一行的时候居中，多行的时候左对齐利用行内元素的特点，父元素 text-align: center，子元素设为行内元素，设置 text-align: leftBFC全称为块级格式化上下文提供了一个环境，元素在这个环境中按照一定规则进行布局一个环境中的元素不会影响到其它环境中的布局比如浮动元素会形成 BFC，浮动元素内部子元素的主要受该浮动元素影响，两个浮动元素之间是互不影响的可以说 BFC 就是一个作用范围，把它理解成是一个独立的容器，并且这个容器里的布局与这个容器外毫不相干触发 BFC 的条件：根元素或其它包含它的元素浮动元素 (元素的 float 不是 none)绝对定位元素 (元素具有 position 为 absolute 或 fixed)内联块 (元素具有 display: inline-block)表格单元格 (元素具有 display: table-cell，HTML 表格单元格默认属性)表格标题 (元素具有 display: table-caption, HTML 表格标题默认属性)具有 overflow 且值不是 visible 的块元素弹性盒（flex 或 inline-flex）display: flow-rootcolumn-span: all行级块级区别块级可设置宽高，单独成行行内元素设置宽高无效，宽高由内容撑起盒模型标准盒模型：高宽仅为内容（默认，box-sizing: content-box）怪异盒模型：高宽包括内容+边框+内边距（box-sizing: border-box）水平居中内行元素使用 text-align: centermargin: auto元素为绝对定位使用 left:0; right:0; margin: auto使用 flex垂直居中单行文字使用 lineheight使用 flex绝对定位元素：bottom:0; top:0; margin:auto绝对定位元素：top:50%; margin-top:-(元素高度一半)各个单位区别 rem、em、vh、px画一条 0.5px 的直线height: 1px;transform: scale(0.5);link 与 @import 的区别link 功能较多，可以定义 RSS，定义 Rel 等作用，而 @import 只能用于加载 css当解析到 link 时，页面会同步加载所引的 css，而 @import 所引用的 css 会等到页面加载完才被加载@import 需要 IE5 以上才能使用link 可以使用 js 动态引入，@import 不行渐进增强和优雅降级渐进增强：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。优雅降级：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。margin 重叠问题兄弟级的垂直块之间，margin 这个属性上下边距，会发生重叠的情况，float 浮动或 display: inline-block父子级的块之间，子级的上下 margin 会与父级上下 margin 重叠，父级加 overflow: hidden 或加 padding 或加 border，子级加 position: absolute相邻盒子高度自动同步flex不使用 flex 布局，使用 table 布局让左右两侧 div 元素高度一致：https://codepen.io/qxtang/pen/RwxdXqewhite-space: pre-wrap字符串变量中包含\\n换行符，只需在 css 样式中加入whiteSpace: 'pre-wrap'即可实现解析\\n换行符https://blog.csdn.net/Zckguiying/article/details/88641357width 特殊值max-content：元素内容固有的合适宽度min-content：元素内容固有的最小宽度https://www.zhangxinxu.com/wordpress/2016/05/css3-width-max-contnet-min-content-fit-content/z-index 什么情况下会失效元素的 position 属性需要是 relative\\absolute\\fixed父元素 position 为 relative 时，子元素的 z-index 失效元素设置了 float 属性，导致失效为什么需要清除浮动？清除浮动的方式定义非 IE 浏览器下，容器不设高度且子元素浮动时，容器高度不能被内容撑开内容会溢出到容器外面而影响布局浮动引起的问题父元素高度无法被撑开，影响与父元素同级的元素与浮动元素同级的非浮动元素会跟随其后与浮动元素同级的非浮动元素会跟随其后怎么清除浮动clear: both;br 标签清浮动，br 标签存在一个属性：clear。这个属性能够清除浮动，在 br 标签中设置属性 clear，并赋值 all。即能清除掉浮动。positionabsolute 绝对定位，相对父元素relative 生成相对定位的元素，相对于其原来的位置进行定位。元素的位置通过 left、top、right、bottom 属性进行规定fixed 绝对定位，相对于屏幕视⼝static 默认值，没有定位，元素出现在正常的文档流中sticky 粘性定位 基于用户的滚动位置来定位伪类和伪元素伪类：当已有元素处于某种状态时，为其添加对应的样式伪元素：伪元素用于创建一些原本不在文档树中的元素，并为其添加样式"}]},{"id":"ea46b6ad2dbb5eb6e187c6e60fb9af92","dirname":"Javascript","filename":"","basename":"","path":"/home/runner/work/qxtang.github.io/qxtang.github.io/前端","children":[{"id":"d930c75e6c41afbbfa8335f27b5b4e04","isRootIndexFile":false,"isIndexFile":false,"filename":"Promise.md","basename":"Promise","path":"/home/runner/work/qxtang.github.io/qxtang.github.io/前端/Javascript","content":"Promise描述解决 es5 回调地狱实例化 Promise：传入一个函数，代码在这个函数中执行，这个函数接收两个参数 resolve 和 reject，当作函数来执行设置成功：在函数中调用 resolve 函数把 Promise 的状态变为成功，通过参数把结果传递出去，能在这个 Promise 对象的 then 方法中获取结果，then 方法可以链式调用多次，then 方法接受一个函数作为参数，这个函数的参数就是 resolve 传递出来的结果设置失败：在函数中调用 reject 函数把 Promise 的状态变为失败，用法同 resolve，能在这个 Promise 对象的 catch 方法中获取结果无论结果如何都会走 finally 方法Promise.all：接受一个数组作为参数（都是 Promise 实例），调用 Promise.all 的时候，这些实例会一起开始执行，返回一个结果数组，只有全部实例的状态是成功，结果的状态才会是成功，只要有一个失败，结果就是失败Promise.race：接受一个数组作为参数（都是 Promise 实例），返回一个结果数组，调用 Promise.race 的时候，传进去的实例是竞赛关系，哪个结果获得的快，就返回哪个结果Promise.resolve()：直接返回一个成功状态的 Promise 对象，接受一个参数，这个参数可以是：成功的结果\\Promise 实例\\不带有参数Promise.reject()：失败，同上Promise 实现链式调用原理每个方法其实都是返回一个新的 Promise 对象promise.catch 是不是微任务是的"},{"id":"be88105a7585cfc75cc22465286da5bf","isRootIndexFile":false,"isIndexFile":false,"filename":"Proxy 和 Reflect.md","basename":"Proxy 和 Reflect","path":"/home/runner/work/qxtang.github.io/qxtang.github.io/前端/Javascript","content":"Proxy 和 Reflect通过 Proxy 创建对象的代理对象，在代理对象中使用 Reflect 达到对于 JavaScript 原始操作的拦截Proxy 为什么需要 Reflect 来配合简化 Proxy 的创建统一将 Object 的一些明显属于语言内部的方法（比如 Object.defineProperty），放到 Reflect 对象上。现阶段，某些方法同时在 Object 和 Reflect 对象上部署，未来的新方法将只部署在 Reflect 对象上。也就是说，从 Reflect 对象上可以拿到语言内部的方法。统一某些 Object 方法的返回结果，让其变得更合理。比如，Object.defineProperty(obj, name, desc)在无法定义属性时，会抛出一个错误，而 Reflect.defineProperty(obj, name, desc)则会返回 false让 Object 操作都统一变成函数行为。某些 Object 操作是命令式，比如 name in obj 和 delete obj[name]，而 Reflect.has(obj, name)和 Reflect.deleteProperty(obj, name)让它们变成了函数行为Reflect 对象的方法与 Proxy 对象的方法一一对应，只要是 Proxy 对象的方法，就能在 Reflect 对象上找到对应的方法。这就让 Proxy 对象可以方便地调用对应的 Reflect 方法，完成默认行为，作为修改行为的基础。也就是说，不管 Proxy 怎么修改默认行为，你总可以在 Reflect 上获取默认行为Proxy 的局限性一些内置对象具有“内部插槽”，对这些对象的访问无法被代理let map = new Map();let proxy = new Proxy(map, {});proxy.set(&#x27;test&#x27;, 1); // Error解决：let map = new Map();let proxy = new Proxy(map, {  get(target, prop, receiver) {    let value = Reflect.get(...arguments);    return typeof value == &#x27;function&#x27; ? value.bind(target) : value;  },});proxy.set(&#x27;test&#x27;, 1);alert(proxy.get(&#x27;test&#x27;)); // 1私有字段私有字段是通过内部插槽实现的，在调用 getName() 时，this 的值是代理后的 user，它没有带有私有字段的插槽class User {  #name = &#x27;Guest&#x27;;  getName() {    return this.#name;  }}let user = new User();user = new Proxy(user, {});alert(user.getName()); // Error解决：// 该解决方案也有缺点：它将原始对象暴露给该方法，可能使其进一步传递并破坏其他代理功能class User {  #name = &#x27;Guest&#x27;;  getName() {    return this.#name;  }}let user = new User();user = new Proxy(user, {  get(target, prop, receiver) {    let value = Reflect.get(...arguments);    return typeof value == &#x27;function&#x27; ? value.bind(target) : value;  },});alert(user.getName()); // Guest无法拦截严格相等性检查 ===使用示例// 要包装的对象let target = {};// 代理配置const handler = {  // 拦截写入  set(target, prop, val, receiver) {    return Reflect.set(target, prop, val, receiver);  },  // 拦截读取  get(target, prop, receiver) {    return Reflect.get(target, prop, receiver);  },};// 代理对象let proxy = new Proxy(target, handler);可撤销 Proxylet object = {  data: &#x27;Valuable data&#x27;,};let { proxy, revoke } = Proxy.revocable(object, {});alert(proxy.data); // Valuable datarevoke();alert(proxy.data); // Error"},{"id":"2f8752d329f016d074d1bcd83e7c6f1e","isRootIndexFile":false,"isIndexFile":true,"filename":"index.md","basename":"Javascript","path":"/home/runner/work/qxtang.github.io/qxtang.github.io/前端/Javascript","content":"JavascriptString 原生方法substr(start[, length])：deprecated，同 slice/substringsplit([separator[, limit]])：按照给定规则分割字符串，返回一个由分割出来的子字符串组成的数组 '1,2,3' =&gt; [1, 2, 3]substring(indexStart[, indexEnd])：返回字符串在开始索引到结束索引之间的一个子集，或从开始索引直到字符串末尾的一个子集slice(beginIndex[, endIndex])：提取字符串一部分，返回一个新的字符串，不会改动原字符串Array 原生方法push(element1, ..., elementN)：在数组末端添加一个/多个元素，返回添加结果数组 length，改变原数组pop()：删除数组最后一个元素，返回该元素，改变原数组shift()：删除数组第一个元素，返回该元素，改变原数组unshift(element1, ..., elementN)：在数组的第一个位置添加元素，返回添加新元素后的数组 length，改变原数组join([separator])：以指定参数作为分隔符，将所有数组成员连接为一个字符串返回，如果不提供参数，默认用逗号分隔，[1, 2, 3] =&gt; '1,2,3'slice([begin[, end]])：提取数组的一部分，返回一个新数组，不改变原数组splice(start[, deleteCount[, item1[, item2[, ...]]]])：删除原数组的一部分成员，并可以在删除的位置添加新的成员，返回被删除的元素，改变原数组遍历迭代方法：for in 顺序遍历一个对象自有的、继承的、可枚举的、非 Symbol 的属性。对于每个不同的属性，语句都会被执行如果只考虑对象本身的属性，而不是它的原型，那么使用 getOwnPropertyNames() 或 hasOwnProperty() 来确定属性是否是对象本身的。for of ES6 新增，替代 for in 和 forEach，可以遍历 Array，String，Map，Set 等可迭代数据结构forEach 遍历数组每一项，没有返回值，对原数组没有影响，注意：在 forEach 中用 return 不会返回，break 不会跳出，函数会继续执行map 返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值flat 将嵌套的数组“拉平”，变成一维的数组，返回一个新数组，不改变原数组，默认只会“拉平”一层，如果想要“拉平”多层的嵌套数组，可以将 flat() 方法的参数写成一个整数flatMap 对原数组的每个成员执行一个函数（相当于 map），然后对返回值组成的数组执行 flat() 方法。返回一个新数组，不改变原数组，只能展开一层数组filter 返回通过过滤的元素，不改变原数组some 检测数组中某个元素是否满足指定条件，返回 boolean 值，不改变原数组every 检测数组中所有元素是否符合指定条件，返回 boolean 值，不改变原数组reduce 接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值reduceRight 同 reduce，方向相反find 返回通过测试（函数内判断）的数组的第一个元素的值forEach、for in、for of 区别forEach 更多的用来遍历数组for in 一般常用来遍历对象或 jsonfor of 数组对象都可以遍历，遍历对象需要通过和 Object.keys()for in 循环出的是 key，for of 循环出的是 value类数组对象拥有 length 属性，length-0 可隐式转换为 number 类型var a = { 1: &#x27;gg&#x27;, 2: &#x27;love&#x27;, 4: &#x27;meimei&#x27;, length: 5 };类数组对象转数组：Array.prototype.slice.call(arrLike);Array.from(arrLike);内置对象BigIntURL 对象ErrorMathDateRegExpProxy\\ReflectURL 对象：提供用于创建和解析 URLDOM 变动观察器（Mutation observer）：观察 DOM 元素，并在检测到更改时触发回调ES6 新特性箭头函数Promise扩展运算符和解构赋值对象和数组解构let const模板字符串函数的参数默认值classfor of 和 for in模块尾调用优化 TCOvar let constlet 和 const 具有块级作用域，var 不存在块级作用域const 声明常量，不能修改，声明的对象，属性可以被修改用 var 重复声明不会报错，但 let 和 const 会var 会使变量提升，变量可以在 var 声明之前使用。let 和 const 不会使变量提升，提前使用会报错深浅拷贝浅拷贝: 以赋值形式拷贝引用对象，仍指向同一个地址，修改时原对象也会受到影响，实现：Object.assign 或 展开运算符深拷贝：JavaScript 包含基本类型 和 引用类型基本类型按值访问、引用类型按引用访问直接复制引用类型的值，实际上是同一个内存地址的指针，修改新的变量，原变量也会被修改手写深拷贝：function deepCopy(obj) {  // 判断是否是简单数据类型，  if (typeof obj == &#x27;object&#x27;) {    // 复杂数据类型    var result = obj.constructor == Array ? [] : {};    for (let i in obj) {      result[i] = typeof obj[i] == &#x27;object&#x27; ? deepCopy(obj[i]) : obj[i];    }  } else {    // 简单数据类型 直接赋值    var result = obj;  }  return result;}Generator 函数function 关键字与函数名之间有一个星号函数体内部使用 yield 表达式返回一个指向内部状态的指针对象，是一个遍历器对象调用遍历器对象的 next 方法，使指针移向下一个状态内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个 yield 表达式（或 return 语句）为止next 方法返回一个对象，它的 value 属性是当前 yield 表达式的值，done 属性的值表示遍历是否结束async/awaitasync 用来声明函数，告诉解释器这是一个异步函数，只有 async 声明的函数里面才能用 awaitawait 等待一个 promise 执行结束，可以返回 promise 对象 resolve 出来的结果如果 await 等待的这个 Promise 对象出错或者结果为 reject，可以通过 try catch 捕获到错误实现原理：Generator 函数的语法糖将 Generator 函数和自动执行器，包装在一个函数里async function fn(args) {  // ...}// 等同于function fn(args) {  return spawn(function* () {    // ...  });}spawn 函数就是自动执行器，spawn 函数的实现：function spawn(genF) {  return new Promise(function (resolve, reject) {    const gen = genF();    function step(nextF) {      let next;      try {        next = nextF();      } catch (e) {        return reject(e);      }      if (next.done) {        return resolve(next.value);      }      Promise.resolve(next.value).then(        function (v) {          step(function () {            return gen.next(v);          });        },        function (e) {          step(function () {            return gen.throw(e);          });        }      );    }    step(function () {      return gen.next(undefined);    });  });}apply、call、bind都是用来改变函数 this 的指向区别：apply 和 call 的区别是 call 方法接受的是若干个参数列表，而 apply 接收的是一个包含多个参数的数组bind 方法创建新的函数，在 bind 被调用时，这个新函数的 this 被指定为 bind 的第一个参数，而其余参数将作为新函数的参数，供调用时使用，bind 与 apply/call 一样都能改变函数 this 指向，但 bind 并不会立即执行函数，而是返回一个绑定了 this 的新函数，你需要再次调用此函数才能达到最终执行手写：// callFunction.prototype.myCall = function (context, ...args) {  if (typeof this !== &#x27;function&#x27;) {    throw new Error(&#x27;Type error&#x27;);  }  // 判断 context 是否传入，如果没有传就设置为 window  context = context || window;  // 使用 Symbol 来保证属性唯一  // 保证不会重写用户自己原来定义在 context 中的同名属性  const fnSymbol = Symbol();  // 将被调用的方法设置为 context 的属性  // this 即为我们要调用的方法  context[fnSymbol] = this;  // 将执行结果返回  try {    return context[fnSymbol](...args);  } finally {    // 最后删除手动增加的属性方法    delete context[fnSymbol];  }};var foo = {  value: 1,};function bar() {  console.log(this.value);}bar.call(foo); // 1bar.myCall(foo); // 1// apply// 与 call 相比仅获取参数方式不同// bindFunction.prototype.myBind = function (context, ...args) {  if (typeof this !== &#x27;function&#x27;) {    throw new Error(&#x27;Type error&#x27;);  }  const fn = this;  return function Fn() {    return fn.apply(      this instanceof Fn ? this : context,      // 当前的这个 arguments 是指 Fn 的参数      args.concat(...arguments)    );  };};作用域用来管理引擎如何在当前作用域以及嵌套子作用域中根据标识符名称（变量名或者函数名）进行变量查找作用域类型：全局作用域和函数作用域块级作用域解决 ES5 的问题：内层变量可能覆盖外层变量用来计数的循环变量泄露为全局变量作用域链当访问一个变量时，编译器在执行这段代码时，会首先从当前的作用域中查找是否有这个标识符，如果没找到，就去父作用域查找，如果父作用域还没找到继续向上查找，直到全局作用域为止，作用域链，就是由当前作用域与上层作用域的一系列变量对象组成，保证了当前执行的作用域对符合访问权限的变量和函数的有序访问词法作用域和动态作用域JavaScript 采用词法作用域，也就是静态作用域函数的作用域在函数定义的时候就决定了而与词法作用域相对的是动态作用域，函数的作用域是在函数调用的时候才决定var value = 1;function foo() {  console.log(value);}function bar() {  var value = 2;  foo();}bar();// 1执行上下文当函数执行时，会创建一个称为执行上下文的内部对象一个执行上下文定义了一个函数执行时的环境，函数每次执行时对应的执行上下文都是独一无二的，所以多次调用一个函数会导致创建多个执行上下文，当函数执行完毕，执行上下文被销毁参数传递参数如果是基本类型是按值传递，如果是引用类型按共享传递但是当值是一个复杂的数据结构的时候，拷贝就会产生性能上的问题按值传递把函数外部的值复制给函数内部的参数，就和把值从一个变量复制到另一个变量一样共享传递在传递对象的时候，传递对象的引用的副本假设 arg 是一个对象参数，修改 arg.value，可以通过引用找到原值，但是直接修改 arg，并不会修改原值arguments一个类数组对象，存储传入函数的全部参数callee 属性：当前函数的引用妙用：递归、参数累加为什么 arguments 是类数组：BE 本人也承认 arguments 的设计是因为当时只花了十天所以整得太糙了为什么 ES6 不推荐 arguments.callee()：访问 arguments 是个很昂贵的操作，因为它是个很大的对象，每次递归调用时都需要重新创建。影响浏览器的性能，还会影响闭包当一个函数必须调用自身的时候，假如它是函数表达式则给它命名，或者使用函数声明，避免使用 calleedelete 机制使用 delete 操作符不会直接释放内存，与 V8 引擎有关最有效的方式，应该是将不需要的属性设置为 undefined在实际业务中可以考虑使用 Map 来代替 object，map 包装对象有 delete 方法，比以上方式都快设置一个对象所有属性不能修改Object.preventExtensions()Object.seal() 封闭一个对象，阻止添加新属性并将所有现有属性标记为不可配置，当前属性的值只要原来是可写的就可以改变Object.freeze() 使用 Object.freeze() 冻结的对象中的现有属性值是不可变的。用 Object.seal() 密封的对象可以改变其现有属性值代理对参考：https://zh.javascript.info/string所有常用的字符都是一个 2 字节的代码。大多数欧洲语言，数字甚至大多数象形文字中的字母都有 2 字节的表示形式但 2 字节只允许 65536 个组合，这对于表示每个可能的符号是不够的。所以稀有的符号被称为“代理对”的一对 2 字节的符号编码代理对在 JavaScript 被创建时并不存在，因此无法被编程语言正确处理这些符号的 length 是 2：alert(&#x27;𝒳&#x27;.length); // 2，大写数学符号alert(&#x27;😂&#x27;.length); // 2，部分 emoji 表情alert(&#x27;𩷶&#x27;.length); // 2，罕见的中国象形文字并发控制实现async function asyncPool(poolLimit, array, iteratorFn) {  const ret = []; // 存储所有的异步任务  const executing = []; // 存储正在执行的异步任务  for (const item of array) {    // 调用iteratorFn函数创建异步任务    const p = Promise.resolve().then(() =&gt; iteratorFn(item, array));    ret.push(p); // 保存新的异步任务    // 当poolLimit值小于或等于总任务个数时，进行并发控制    if (poolLimit &lt;= array.length) {      // 当任务完成后，从正在执行的任务数组中移除已完成的任务      const e = p.then(() =&gt; executing.splice(executing.indexOf(e), 1));      executing.push(e); // 保存正在执行的异步任务      if (executing.length &gt;= poolLimit) {        await Promise.race(executing); // 等待较快的任务执行完成      }    }  }  return Promise.all(ret);}function multiRequest(urls = [], maxNum) {  // 请求总数量  const len = urls.length;  // 根据请求数量创建一个数组来保存请求的结果  const result = new Array(len).fill(false);  // 当前完成的数量  let count = 0;  return new Promise((resolve, reject) =&gt; {    // 请求maxNum个    while (count &lt; maxNum) {      next();    }    function next() {      let current = count++;      // 处理边界条件      if (current &gt;= len) {        // 请求全部完成就将promise置为成功状态, 然后将result作为promise值返回        !result.includes(false) &amp;&amp; resolve(result);        return;      }      const url = urls[current];      console.log(`开始 ${current}`, new Date().toLocaleString());      fetch(url)        .then((res) =&gt; {          // 保存请求结果          result[current] = res;          console.log(`完成 ${current}`, new Date().toLocaleString());          // 请求没有全部完成, 就递归          if (current &lt; len) {            next();          }        })        .catch((err) =&gt; {          console.log(`结束 ${current}`, new Date().toLocaleString());          result[current] = err;          // 请求没有全部完成, 就递归          if (current &lt; len) {            next();          }        });    }  });}WeakMap\\Map 区别Map 的键可以是任意类型，WeakMap 只接受对象作为键（null 除外），不接受其他类型的值作为键WeakMap 的键名所指向的对象，不计入垃圾回收机制，设计目的在于，有时想在某个对象上面存放一些数据，但是这会形成对于这个对象的引用。一旦不再需要这两个对象，就必须手动删除这个引用，否则垃圾回收机制就不会释放对象占用的内存Map 的键跟内存地址绑定，只要内存地址不一样，就视为两个键；WeakMap 的键是弱引用，键所指向的对象可以被垃圾回收，此时键是无效的Map 的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键；WeakMap 的键是弱引用，键所指向的对象可以被垃圾回收，此时键是无效的escape\\encodeURI\\encodeURIComponent 区别escape 和它们不是同一类，是对字符串进行编码(而另外两种是对 url)，作用是让它们在所有电脑上可读encodeURI\\encodeURIComponent 唯一区别就是编码的字符范围encodeURIComponent 比 encodeURI 编码的范围更大扩展运算符的应用取出参数对象中的所有可遍历属性，拷贝到当前对象之中合并对象，覆盖对象属性将一个数组转为用逗号分隔的参数序列，且每次只能展开一层数组console.log(...[1, 2, 3]);// 1 2 3console.log(...[1, [2, 3, 4], 5]);// 1 [2, 3, 4] 5合并数组字符串转真数组[...&#x27;hello&#x27;]; // [ &quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot; ]转任何部署了 Iterator 接口的对象为真数组位运算计算机对二进制数据进行的运算，加减乘除等，叫位运算JavaScript 为什么要进行变量提升js 引擎在代码执行前有一个解析的过程，创建了执行上下文，初始化了一些代码执行时需要用到的对象当访问一个变量时，会到当前执行上下文中的作用域链中去查找提高性能 容错性更好解析和执行解析: 检查语法，并对函数进行预编译。解析的时候会先创建一个全局执行上下文环境，先把代码中即将执行的变量、函数声明都拿出来，变量先赋值为 undefined，函数先声明好可使用。在一个函数执行之前，也会创建一个函数执行上下文环境，跟全局执行上下文类似，不过函数执行上下文会多出 this、arguments 和函数的参数执行: 按照代码的顺序依次执行严格模式文件顶部添加 'use strict' 开启意义：消除 Javascript 语法的不合理、不严谨之处，减少怪异行为消除代码运行的不安全之处，保证代码运行的安全提高编译器效率，增加运行速度为未来新版本的 Javascript 做好铺垫区别：禁止使用 with 语句禁止 this 关键字指向全局对象对象不能有重名的属性DOM api创建新节点createDocumentFragment() //创建一个 DOM 片段createElement() //创建一个具体的元素createTextNode() //创建一个文本节点添加、移除、替换、插入appendChild() //添加removeChild() //移除replaceChild() //替换insertBefore() //插入查找getElementsByTagName()getElementsByName()getElementById()document.querySelector()document.querySelectorAll()手写 Ajaxvar xhr = new XMLHttpRequest();xhr.onreadystatechange = function () {  // 通信成功时，状态值为4  if (xhr.readyState === 4) {    if (xhr.status === 200) {      console.log(xhr.responseText);    } else {      console.error(xhr.statusText);    }  }};xhr.onerror = function (e) {  console.error(xhr.statusText);};xhr.open(&#x27;GET&#x27;, &#x27;http://www.example.com/page.php&#x27;, true);xhr.send(null);XMLHttpRequest.readyState 返回一个整数，表示实例对象的当前状态。该属性只读。它可能返回以下值。0，XMLHttpRequest 实例已经生成，但是实例的 open() 方法还没有被调用。1，open() 方法已经调用，但是实例的 send() 方法还没有调用，仍然可以使用实例的 setRequestHeader() 方法，设定 HTTP 请求的头信息。2，实例的 send() 方法已经调用，并且服务器返回的头信息和状态码已经收到。3，正在接收服务器传来的数据体（body ）。这时，如果实例的 responseType 属性等于 text 或者空字符串，responseText 属性就会包含已经收到的部分信息。4，服务器返回的数据已经完全接收，或本次接收已经失败。"},{"id":"ec0bab315a90916ea4a01590407e1da7","isRootIndexFile":false,"isIndexFile":false,"filename":"原型链和继承.md","basename":"原型链和继承","path":"/home/runner/work/qxtang.github.io/qxtang.github.io/前端/Javascript","content":"原型链和继承原型链描述原型：每一个对象（null 除外）在创建的时候会关联另一个对象，这个对象就是原型，每一个对象都会从原型继承属性或方法，就是 prototype 属性由相互关联的原型组成的链状结构就是原型链原型对象上的属性和方法，能被对应构造函数创建的实例共享，这是 JavaScript 继承机制的基本设计JavaScript 对象通过 prototype 指向父类对象，直到指向 Object 对象，Object 原型指向 null 为止，这样就形成了一个原型指向的链条访问实例的某个属性或方法，会首先在对象内寻找，找不到，才在对象的原型里去找，一直找到底instanceof、isPrototypeOf：判断是否处于原型链Object.hasOwnProperty()：检查对象自身中是否含有该属性for in 可以搜索原型属性函数对象的 prototype --&gt; 实例原型实例（普通对象）的 __proto__ --&gt; 实例原型原型的 constructor --&gt; 关联的构造函数实例原型的原型 --&gt; ObjectObject 的原型 --&gt; null，Object.prototype.__proto__ === null此时原型链停止查找null 表示“没有对象”，即该处不应该有值。所以 Object.prototype.__proto__ 的值为 null 跟 Object.prototype 没有原型，其实表达了一个意思原型对象 和 构造函数定义一个函数数据类型\\普通函数\\类的时候，自带一个 prototype 属性指向函数的原型对象当函数经过 new 调用时，这个函数就成为了构造函数，返回一个新的实例，这个实例有一个 __proto__ 属性，指向构造函数的原型对象声明方法为什么要用 prototype为了在类的各个实例间共享通过该构造函数生成的实例所拥有的方法都是指向一个函数的索引，可以节省内存不使用 prototype 定义的方法相当于类的静态方法，可以直接使用，不需要 new使用 prototype 定义的方法相当于类的实例方法，必须 new 后才能使用prototype 和 proto 和 constructor 的关系prototype 用于访问函数的原型对象。它是函数所独有的，它是从一个函数指向一个对象。它的含义是函数的原型对象，任何函数在创建的时候，其实会默认同时创建该函数的 prototype 对象__proto__ 用于访问对象实例的原型对象（或者使用 Object.getPrototypeOf()）__proto__ 是对象独有的__proto__ 作用就是当访问一个对象的属性时，如果该对象内部不存在这个属性，那么就会去它的 __proto__ 属性所指向的那个对象（可以理解为父对象）里找，如果父对象也不存在这个属性，则继续往父对象的 __proto__ 属性所指向的那个对象（可以理解为爷爷对象）里找，如果还没找到，则继续往上找，直到原型链顶端 null 空对象constructor 属性也是对象才拥有的，它是从一个对象指向一个函数，含义就是指向该对象的构造函数typeof 和 instanceof 区别typeof：判断一个变量的类型instanceof：判断一个变量是否是某个对象的实例instanceof 原理：能在实例的 原型对象链 中找到该构造函数的 prototype 属性所指向的 原型对象，就返回 truenew 干了什么new 操作符新建了一个空对象，这个对象原型指向构造函数的 prototype，执行构造函数后返回这个对象。创建一个空对象将构造函数的作用域赋给新对象，根据原型链，设置空对象的 __proto__ 为构造函数的 prototype构造函数的 this 指向这个对象，执行构造函数的代码（为这个新对象添加属性）判断函数的返回值类型，如果是引用类型，就返回这个引用类型的对象手写 new：function myNew(context, ...args) {  const obj = new Object();  obj.__proto__ = context.prototype;  const res = context.apply(obj, args);  return typeof res === &#x27;object&#x27; ? res : obj;}继承许多面向对象语言都支持两种继承方式: 接口继承 和 实现继承JavaScript 没有提供传统面向对象语言中的类式继承，而是通过原型委托的方式来实现对象与对象之间的继承JavaScript 也没有在语言层面提供对抽象类和接口的支持接口继承只继承方法签名，而实现继承则继承实际的方法在 JavaScript 中无法实现接口继承，只支持实现继承，而且其实现继承主要是依靠原型链来实现的以对象字面量方式创建原型方法会破坏之前的原型链，因为这相当于重写了原型链ES6 和 ES5 继承区别https://gist.github.com/zachrey/b3633b357134201e7d39d1c7d8c438fdES5 的继承一般是通过原型链模式或者构造函数模式来实现继承，ES5 的 Sub 构造函数的 prototype 指向的是 Function.prototype而 ES6 实现的继承，Sub.prototype 的会指向 Parentthis 的构造顺序是不一样的，ES5 的继承是先构造子对象然后再产生父对象，然后将父对象里面的属性复制到子对象中。而 ES6 是先使用 super()创建 父对象，然后再创建子对象。所以 this 的构造顺序不同。原型链继承直接通过原型继承属性和方法Son.prototype = new Father();缺点：原型中包含引用值的时候，会在所有实例间共享，修改子类引用类型属性会影响到父类子类型在实例化时不能给父类型的构造函数传参盗用构造函数为了解决原型包含引用值导致的继承问题（含引用类型值的原型属性会被所有实例共享）在子类型构造函数的内部调用父类型构造函数优点是可以在子类构造函数中向父类构造函数传参function Father() {  this.colors = [&#x27;red&#x27;, &#x27;blue&#x27;, &#x27;green&#x27;];}function Son() {  Father.call(this);  // 继承了Father，且向父类型传递参数}缺点：必须在构造函数中定义方法，因此函数不能重用子类也不能访问父类原型上定义的方法组合继承原型链继承和盗用构造函数继承的结合使用原型链实现对原型属性和方法的继承通过盗用构造函数来实现对实例属性的继承既通过在原型上定义方法实现了函数复用，又能够保证每个实例都有它自己的属性function Father(name) {  this.name = name;  this.colors = [&#x27;red&#x27;, &#x27;blue&#x27;, &#x27;green&#x27;];}Father.prototype.sayName = function () {  alert(this.name);};function Son(name, age) {  // 继承属性  Father.call(this, name);  this.age = age;}// 继承方法Son.prototype = new Father();Son.prototype.constructor = Son;Son.prototype.sayAge = function () {  alert(this.age);};原型式继承即相当于 ES6 的 Object.create()方法适合不需要单独创建构造函数，但仍然需要在对象间共享信息的场合创建一个临时构造函数将传入的对象赋值给这个构造函数的原型然后返回这个临时类型的一个实例function object(o) {  function F() {}  F.prototype = o;  return new F();}寄生式继承类似工厂模式创建一个实现继承的函数，以某种方式增强对象，然后返回这个对象适合主要关注对象，而不在乎类型和构造函数的场景通过寄生式继承给对象添加函数会导致函数难以重用，与构造函数模式类似var book = { name: &#x27;js book&#x27;, likeBook: [&#x27;html book&#x27;, &#x27;css book&#x27;] };function createBook(obj) {  // 通过原型方式创建新的对象  var o = new inheritObject(obj);  // 拓展新对象  o.getName = function (name) {    console.log(name);  };  // 返回拓展后的新对象  return o;}寄生组合继承组合继承的问题：会调用两次父类型构造函数，创建子类原型时、在子类构造函数内部通过借用构造函数来继承属性通过原型链的混成形式来继承方法不必为了指定子类型的原型而调用超类型的构造函数，我们所需要的无非就是超类型原型的一个副本而已function Father(foo) {  this.foo = foo;}Father.prototype.printFoo = function () {  console.log(this.foo);};function Son(bar) {  this.bar = bar;  Father.call(this);}Son.prototype = Object.create(Super.prototype);Son.prototype.constructor = Son;ES6 的 extendsclass Father {  constructor(foo) {    this.foo = foo;  }  printFoo() {    console.log(this.foo);  }}class Son extends Father {  constructor(foo, bar) {    super(foo);    this.bar = bar;  }}参考https://github.com/mqyqingfeng/blog/issues/2"},{"id":"af07a9408354f15afe7ab7f38c079349","isRootIndexFile":false,"isIndexFile":false,"filename":"垃圾回收.md","basename":"垃圾回收","path":"/home/runner/work/qxtang.github.io/qxtang.github.io/前端/Javascript","content":"垃圾回收各大浏览器通常用采用的垃圾回收有两种：标记清除、引用计数标记清除（主流）垃圾收集器在运行时给存储在内存中的所有变量加上标记因为只要上下文中的代码在运行，就有可能用到它们从根部出发将能触及到的对象的标记清除还存在标记的变量被视为准备删除的变量销毁带标记的变量引用计数如果一个对象没有被其他对象引用，那它将被垃圾回收机制回收跟踪记录每个值被引用的次数当声明了一个变量并将一个引用类型赋值给该变量时，则这个值的引用次数就是 1相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数就减 1当这个引用次数变成 0 时，则说明没有办法再访问这个值了，因而就可以将其所占的内存空间给收回来缺点：循环引用会造成对象无法被回收如何避免垃圾回收对象尽量复用数组优化：将 [] 赋值给一个数组对象，但是这种方式又创建了一个新的空对象，且将原来的数组对象变成了一小片内存垃圾，实际上，将数组长度赋值为 0（arr.length = 0）也能达到清空数组的目的，并且同时能实现数组重用，减少内存垃圾的产生引起内存泄漏的操作全局变量闭包dom 清除，事件绑定未清除未清除的计时器setTimeout 的第一个参数使用字符串而非函数引用循环：在两个对象彼此引用且彼此保留时，就会产生一个引用循环console.log 打印了太大的变量React 组件卸载后，存在异步回调中调用 setState手动释放内存fn = null【null：空指针对象】"},{"id":"06bce512407c5f4bd04b3f949113a5a7","isRootIndexFile":false,"isIndexFile":false,"filename":"尾调用和尾递归.md","basename":"尾调用和尾递归","path":"/home/runner/work/qxtang.github.io/qxtang.github.io/前端/Javascript","content":"尾调用和尾递归尾调用指某个函数的最后一步是调用另一个函数函数调用会在内存形成一个&quot;调用记录&quot;，又称&quot;调用帧&quot;（call frame），保存调用位置和内部变量等信息所有的调用记录，就形成一个&quot;调用栈&quot;（call stack）尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用记录，因为调用位置、内部变量等信息都不会再用到了应用：优化递归尾递归函数调用自身，称为递归。如果尾调用自身，就称为尾递归递归耗费内存，因为需要保存多个调用记录，容易发生栈溢出错误但对于尾递归，只存在一个调用记录，所以不会发生栈溢出改写方法把所有用到的内部变量改写成函数的参数可以使用柯里化，将多参数的函数转换成单参数的形式// 没有尾递归 复杂度 O(n)function factorial(n) {  if (n === 1) return 1;  return n * factorial(n - 1);}factorial(5);// 改写为尾递归 复杂度 O(1)function factorial(n, total) {  if (n === 1) return total;  return factorial(n - 1, n * total);}factorial(5, 1);// 柯里化function currying(fn, n) {  return function (m) {    return fn.call(this, m, n);  };}function tailFactorial(n, total) {  if (n === 1) return total;  return tailFactorial(n - 1, n * total);}const factorial = currying(tailFactorial, 1);factorial(5);// 使用 es6 默认参数function factorial(n, total = 1) {  if (n === 1) return total;  return factorial(n - 1, n * total);}factorial(5);尾调用仅在严格模式下生效因为在正常模式下，函数内部有两个变量，可以跟踪函数的调用栈：arguments、func.caller尾调用优化发生时，函数的调用栈会改写，因此上面两个变量就会失真。严格模式禁用这两个变量，所以尾调用模式仅在严格模式下生效"},{"id":"ded0767aa1b832ff6b0c1fffa4f8bd93","isRootIndexFile":false,"isIndexFile":false,"filename":"数据类型.md","basename":"数据类型","path":"/home/runner/work/qxtang.github.io/qxtang.github.io/前端/Javascript","content":"数据类型基本类型：number、string、boolean、undefined、null、Symbol、BigInt引用类型：Object、Array、Function、内置对象（Date、Math 等）BigInt内置对象，提供了对任意长度整数的支持，表示任意大的整数Number.MAX_SAFE_INTEGER（2^53 - 1）是 Javascript 中可以用 Number 表示的最大数字，在这个数范围内不会出现精度丢失（⼩数除外），超过这个范围，js 会出现计算不准确的情况它提供了一种方法来表示大于 Number.MAX_SAFE_INTEGER 的整数BigInt 不支持一元加法BigInt 出现之前需要依靠第三方库创建 bigint：在一个整数字面量后面加 n 或者调用 BigInt 函数const bigint = 1234567890123456789012345678901234567890n;const sameBigint = BigInt(&#x27;1234567890123456789012345678901234567890&#x27;);const bigintFromNumber = BigInt(10); // 与 10n 相同内存管理基本数据类型保存在栈内存中，因为基本数据类型占用空间小、大小固定，通过按值来访问，属于被频繁使用的数据引用数据类型存储在堆内存中，因为引用数据类型占据空间大、占用内存不固定。如果存储在栈中，将会影响程序运行的性能引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体栈内存是一种特殊的线性表，它具有后进先出的特性存放基本类型，占据空间小、大小固定堆内存存放引用类型（在栈内存中存一个基本类型值保存对象在堆内存中的地址，用于引用这个对象）占据空间大、大小不固定类型判断typeof：判断基本类型、函数。不能判断 Null、Object、Array，因为都返回 objectinstanceof：判断对象类型，不能判断基本数据类型，机制是判断在对象原型链中能否找到该类型的原型Object.prototype.toString.call：所有类型都能判断，还有 Error 对象，Date 对象等判断数组Array.isArrayarr.__proto__ === Array.prototypearr instanceof ArrayObject.prototype.toString.callnull 和 undefined 区别null 表示没有对象，即该处不应该有值undefined 表示缺少值，即此处应该有值，但没有定义typeof null 为 objecttypeof undefined 为 undefinednull 和 undefined 转换成 number 数据类型时，null 转成 0 undefined 转成 NaNObject.is 与 ===\\== 区别== 会强转，Object.is 不会强转===\\== 将数字 -0 和 +0 视为相等，而将 Number.NaN 与 NaN 视为不相等，Object.is 反之Number.isNaN 与 isNaN 区别NaN 是一个值，当算术运算返回一个未定义的或无法表示的值时产生，typeof NaN 为 numberisNaN：确定一个值是否为 NaN/只要不是 number 就会返回 trueisNaN 会对传入的值使用 toNumber 转换一次，例如 isNaN('') 为 true，'' 隐式转换为 0Number.isNaN：只有传入的值为 NaN 时才返回 trueNaN == NaN 为什么是 falseNaN 的意思是 Not a Number，那么不是数字的字符肯定不是一个，而是一个范围，一个集合。就好像 A 不是数字，B 也不是数字，但是 A 肯定不是 B 一样。所以综上 NaN 其实是不等于它自身的== 强转规则类型相同直接比较是否在对比 null 和 undefined，是的话就会返回 true是否为 string 和 number，是的话就将 string 转 number其中一方是否为 boolean，是的话就 boolean 转 number其中一方是否为 object 且另一方为 string、number 或者 symbol，是的话就把 object 转为原始类型再进行判断object 转原始类型（ToPrimitive 方法）：先检查该值是否有 valueOf() 方法如果有并且返回基本类型值，就使用该值进行强制类型转换。如果没有就使用 toString() 的返回值来进行强制类型转换如果 valueOf() 和 toString() 均不返回基本类型值，会产生 TypeError 错误其他值到布尔类型的值的转换规则以下这些是 false，除此以外都是 true：undefinednull+0、-0 和 NaN&quot;&quot;精度丢失与浮点数在计算机内部（用二进制存储）的表示方法有关JS 采用 IEEE 754 标准的 64 位双精度浮点数表示法，这个标准是 20 世纪 80 年代以来最广泛使用的浮点数运算标准，为许多 CPU 与浮点运算器所采用，也被很多语言如 java、python 采用。这个标准，会让大部分的十进制小数都不能用二进制浮点数来精确表示（比如转成二进制就会变成无限小数）。所以一般情况下，你输入的十进制小数仅由实际存储在计算机中的近似的二进制浮点数表示。然而，许多语言在处理的时候，在一定误差范围内（通常极小）会将结果修正为正确的目标数字，而不是像 JS 一样将存在误差的真实结果转换成最接近的小数输出解决：使用 Number.EPSILON（误差范围）Number.EPSILON 表示 1 与 Number 可表示的大于 1 的最小的浮点数之间的差值function isEqual(a, b) {  return Math.abs(a - b) &lt; Number.EPSILON;}console.log(isEqual(0.1 + 0.2, 0.3)); // true0.1 + 0.2 为什么不等于 0.3本质是：二进制模拟十进制进行计算时的精度问题进制转换：js 在做数字计算的时候，0.1 和 0.2 被转成二进制后无限循环，但是 js 采用的 IEEE 754 二进制浮点运算，最大可以存储 53 位有效数字，于是大于 53 位后面的会全部截掉，将导致精度丢失对阶运算：由于指数位数不相同，运算时需要对阶运算，阶小的尾数要根据阶差来右移（0 舍 1 入），尾数位移时可能会发生数丢失的情况，影响精度0.2 + 0.3 为什么没有这个问题？："},{"id":"f2fc1eb33e1e781281ddf26e44f4c8f6","isRootIndexFile":false,"isIndexFile":false,"filename":"模块.md","basename":"模块","path":"/home/runner/work/qxtang.github.io/qxtang.github.io/前端/Javascript","content":"模块实现：常用 IIFE 实现模块化：匿名函数自调用，将数据和行为封装到一个函数内部，外部依赖通过参数传入常见规范：ES6 模块（esm）、CommonJS、CMD、AMD什么是 Tree Shaking删除无用代码的算法，集成在 webpack 和 rollup 等打包工具中CommonJS通用环境，比如 nodejs，不局限于浏览器每个模块提供一个 module 变量一个文件一个模块可以动态引入，所以不支持树摇特点：语法相对简单，浏览器不直接支持AMD明确基于浏览器基本退出了历史舞台RequireJS 是 AMD 的一个实现特点：异步加载、同一个文件定义一个模块ESMesm 是 javascript 的标准功能，是语言规范，是官方明确的发展方向，cjs 只是 esm 出来之前的临时解决方案而已相比 cjs 的好处是可以使用 tree shaking，支持静态分析模块脚本自动采用严格模式模块顶层的 this 关键字返回 undefinedesm 是编译时加载，也就是只有所有 import 的模块都加载完成，才会开始执行，这有利于引擎的静态分析，加载的过程会先于代码的执行，却也导致 import 导入语句不能在函数或者 if 语句中执行。es2020 提案引入 import() 函数，用来动态加载模块，并且可以用在函数和 if 语句中模块缓存：同一个模块如果加载多次，只会执行一次export 导出的是值引用，当模块内部的值被修改时，esm 可以获取到被修改后的值，cjs 获取不到CommonJS，ESM 区别都属于不同的模块规范，require 属于 CommonJS 规范，import 属于 ES modulerequire 支持动态导入，import 不支持它们都是一种模块规范，例如 Node 使用的就是 CommonJS 规范。ES module 则是语言标准上的模块规范 区别：CommonJS 模块使用 require() 和 module.exports，ES6 模块使用 import 和 exportCommonJS 模块输出的是一个值的浅拷贝，ES6 模块输出的是值的引用CommonJS 模块是运行时加载，ES6 模块是编译时输出接口，是因为 CommonJS 加载的是一个对象（即 module.exports 属性），该对象只有在脚本运行完才会生成，而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成CommonJS 模块的 require() 是同步加载模块，ES6 模块的 import 命令是异步加载，有一个独立的模块依赖的解析阶段ES6 模块之中，顶层的 this 指向 undefined；CommonJS 模块的顶层 this 指向当前模块UMD通用模块定义规范（Universal Module Definition）可以通过运行时或者编译时让同一个代码模块在使用 CommonJs、CMD 甚至是 AMD 的项目中运行。未来同一个 JavaScript 包运行在浏览器端、服务端甚至是 APP 端都只需要遵守同一个写法就行了是前端实现跨平台技术需求发展下的产物它没有自己专有的规范，是集结了 CommonJs、CMD、AMD 的规范于一身，一个简单实现的例子：((root, factory) =&gt; {  if (typeof define === &#x27;function&#x27; &amp;&amp; define.amd) {    // AMD    define([&#x27;jquery&#x27;], factory);  } else if (typeof exports === &#x27;object&#x27;) {    // CommonJS    var $ = requie(&#x27;jquery&#x27;);    module.exports = factory($);  } else {    // 没有模块环境，直接挂载在全局对象上    root.testModule = factory(root.jQuery);  }})(this, ($) =&gt; {  return {    name: &#x27;我是一个umd模块&#x27;,  };});/*  定义一个 IIFE，  在定义模块的时候检测当前使用环境和模块的定义方式，  将各种模块化定义方式转化为同样一种写法，\t先判断当前环境如果支持 AMD，则使用 require.js 提供的 define 函数定义模块，\t再判断是否 cjs，如果是则使用 cjs 相应的模块定义方法进行模块定义，  如果还需要兼容其他类型的模块系统也是类似思路去兼容，  最后如果没有模块环境，直接挂载在全局对象上，这个传进来的全局对象 this，其值可能是 window 或者 global，视运行环境而定*/"},{"id":"8edba4a27acf83aaa2f5bef514b3530b","isRootIndexFile":false,"isIndexFile":false,"filename":"闭包.md","basename":"闭包","path":"/home/runner/work/qxtang.github.io/qxtang.github.io/前端/Javascript","content":"闭包函数 A 返回了一个函数 B，并且函数 B 中使用了函数 A 的变量，函数 B 就被称为闭包，函数 A 的执行上下文没有被释放闭包中的变量不保存在栈内存中，而是保存在堆内存中。这也就解释了函数调用之后之后为什么闭包还能引用到函数内的变量能够访问已经被销毁的执行上下文的活动对象的函数、有权访问另一个函数作用域中的变量的函数函数做为参数传递或在尾部 return，并且子函数在外调用，形成闭包，子函数所在的父函数的作用域不会被释放，子函数的作用域中仍然保留着父级的单变量对象和作用域链，因此可以继续访问到父级的变量对象应用：设计私有的方法和变量优点：可以避免全局变量的污染缺点：常驻内存会增大内存使用量，会躲掉垃圾回收机制，使用不当很容易造成内存泄露闭包实现累加function A() {  let start = 0;  function B() {    return ++start;  }  return B;}const inc = A();console.log(inc());console.log(inc());console.log(inc());如何优化闭包通过解除对匿名函数的引用，可以将匿名函数占用的内存安全释（将闭包创建的函数赋值为 null）function outerFun(outerArg) {  return function () {    console.log(&#x27;这里是内部匿名函数&#x27;);    console.log(&#x27;可以访问包含函数的变量&#x27;, outerArg);  };}// 创建一个函数，是 outerFun 中返回的匿名函数var create = outerFun(&#x27;hi&#x27;);// 释放对匿名函数的引用create = null;如果没有对匿名函数的引用，匿名函数执行完之后自动销毁，就可以做到减少占用内存的问题利用匿名函数，制造私有作用域（块级作用域），这样匿名函数执行完之后可以将引用的活动对象销毁"}]},{"id":"7f158862ca7d85cf3d2524cb2658cc79","dirname":"NodeJS","filename":"","basename":"","path":"/home/runner/work/qxtang.github.io/qxtang.github.io/前端","children":[{"id":"8fdbdd3f464fed8281bc6fc45d8dbb80","isRootIndexFile":false,"isIndexFile":true,"filename":"index.md","basename":"NodeJS","path":"/home/runner/work/qxtang.github.io/qxtang.github.io/前端/NodeJS","content":"NodeJS特点它是一个 Javascript 运行环境依赖于 Chrome V8 引擎进行代码解释事件驱动、非阻塞 I/O 模型（简单讲就是每个函数都是异步的）单进程，单线程应用场景高并发连接场景异步机制、事件驱动整个过程没有阻塞新用户的连接，也不需要维护已有用户的连接。基于这样的机制，理论上陆续有用户请求连接，NodeJS 都可以进行响应，因此 NodeJS 能支持比 Java、PHP 程序更高的并发量，虽然维护事件队列也需要成本I/O 阻塞Java、PHP 也有办法实现并行请求（子线程），但 NodeJS 通过回调函数（Callback）和异步机制会做得很自然开发 RESTful API优缺点优点：高并发场景适合 I/O 密集型应用缺点：不适合 CPU 密集型应用，由于 JavaScript 单线程的原因，如果有长时间运行的计算（比如大循环），会导致 CPU 时间片不能释放，使得后续 I/O 无法发起只支持单核 CPU，不能充分利用 CPU可靠性低，一旦代码某个环节崩溃，整个系统都崩溃npm 太自由，开源组件库质量参差不齐，更新快，向下不兼容解决方案：Nginx 反向代理，负载均衡，开多个进程，绑定多个端口开多个进程监听同一个端口，使用 cluster 模块；使用比如 pm2 之类的工具异常处理try catch，缺点明显，无法处理异步代码块内出现的异常，比如 setTimeout使用 event 原生模块，监听 error 事件原生模块的 callback 函数一般都会抛出错误（第一个参数）包结构package.json：包描述文件bin：用于存放可执行二进制文件的目录lib：用于存放 JavaScript 代码的目录doc：用于存放文档的目录test：用于存放单元测试用例的代码cluster 原理pipe 原理洋葱圈模型每次当有一个请求进入的时候，每个中间件都会被执行两次每个中间件都接收了一个 next 参数，在 next 函数运行之前的中间件代码会在一开始就执行，next 函数之后的代码会在内部的中间件全部运行结束之后才执行，就像一根筷子穿过一个洋葱，同一层皮会被筷子穿过两次实现思路this.middleware 是中间件集合的数组koa-compose 模块的 compose 方法用来构建执行顺序// middleware 用来保存中间件app.use = (fn) =&gt; {  this.middleware.push(fn);  return this;};// compose 组合函数来规定执行次序function compose(middleware) {  // context：上下文，next：传入的接下来要运行的函数  return function (context, next) {    function dispatch(i) {      index = i;      // 中间件      let fn = middleware[i];      if (!fn) return Promise.resolve();      try {        // 我们这边假设和上文中的例子一样，有A、B、C三个中间件        // 通过dispatch(0)发起了第一个中间件A的执行        // A中间件执行之后，next作为dispatch(1)会被执行        // 从而发起了下一个中间件B的执行，然后是中间件C被执行        // 所有的中间件都执行了一遍后，执行Promise.resolve()        // 最里面的中间件C的await next()运行结束，会继续执行console.log(&quot;C2&quot;)        // 整个中间件C的运行结束又触发了Promise.resolve        // 中间件B开始执行console.log(&quot;B2&quot;)        // 同理，中间件A执行console.log(&quot;A2&quot;)        return Promise.resolve(          fn(context, () =&gt; {            return dispatch(i + 1);          })        );      } catch (err) {        return Promise.reject(err);      }    }    return dispatch(0);  };}node 多线程如何实现、如何通信与调度策略Node.js 如何处理 ES6 模块https://www.ruanyifeng.com/blog/2020/08/how-nodejs-use-es6-module.htmlNode.js 遇到.mjs 文件，就认为它是 ES6 模块，默认启用严格模式如果不希望将后缀名改成.mjs，可以在项目的 package.json 文件中，指定 type 字段为 module此时 import 路径要加上 .js 拓展名，否则会报错这时还要使用 CommonJS 模块，那么需要将 CommonJS 脚本的后缀名都改成.cjsES6 模块的 import 命令可以加载 CommonJS 模块，但是只能整体加载，不能只加载单一的输出项。// 正确import packageMain from &#x27;commonjs-package&#x27;;// 报错import { method } from &#x27;commonjs-package&#x27;;pm2、forever"},{"id":"f68779691e0f658547d161fe3f05a6a7","isRootIndexFile":false,"isIndexFile":false,"filename":"node 模块.md","basename":"node 模块","path":"/home/runner/work/qxtang.github.io/qxtang.github.io/前端/NodeJS","content":"node 模块模块规范Node 模块系统借鉴 CommonJS 来实现CommonJS 对模块的定义主要分为：模块引用、模块定义和模块标识 3 个部分模块引用存在 require() 方法，这个方法接受模块标识，引入一个模块的 API 到当前上下文中模块定义提供 exports 对象，用于导出当前模块的方法或者变量，并且它是唯一导出的出口存在一个 module 对象，它代表模块自身，而 exports 是 module 的属性在 Node 中，一个文件就是一个模块，将方法挂载在 exports 对象上作为属性即可定义导出的方式模块标识就是传递给 require() 方法的参数符合小驼峰命名的字符串，或者以.、..开头的相对路径，或者绝对路径可以没有文件名后缀.js模块实现在 Node 中引入模块，需要经历 3 个步骤：路径分析、文件定位、编译执行Node 模块分为两类：Node 提供的模块（核心模块）、用户编写的模块（文件模块）两种类型区别核心模块部分在 Node 源代码的编译过程中，编译进了二进制执行文件。在 Node 进程启动时，部分核心模块已被直接加载进内存中，所以这部分核心模块引入时，文件定位和编译执行这两个步骤可以省略掉，并且在路径分析中优先判断，所以它的加载速度是最快的文件模块则是在运行时动态加载，需要完整的路径分析、文件定位、编译执行过程，速度比核心模块慢缓存优先特性Node 对引入过的模块都会进行缓存，以减少二次引入时的开销，Node 缓存的是编译和执行之后的对象路径分析标识符的分类：核心模块、.或..开始的相对路径、以/开始的绝对路径、非路径形式核心模块：核心模块的优先级仅次于缓存加载；它在 Node 的源代码编译过程中已经编译为二进制代码，加载过程最快路径形式：1、转为真实路径；2、将编译执行后的结果存放到缓存中；自定义模块（非路径形式，可能是一个包的形式）：这类模块的查找是最费时的，也是所有方式中最慢的一种文件定位扩展名分析：允许在标识符中不包含文件扩展名，会按.js、.json、.node 的次序补足扩展名，依次尝试，调用了 fs 模块同步阻塞式地判断文件是否存在，所以如果是 .node 和 .json 文件，在传递给 require() 的标识符中带上扩展名，会加快一点速度可能没有查找到对应文件，如果得到一个目录，此时将目录当做一个包来处理，查找 package.json 的 main 属性，同样进行拓展名分析如果 package.json 和 main 字段没有找到，则寻找文件夹下的 index 文件，同样进行拓展名分析最后都没找到则抛出查找失败的异常编译执行.js 文件：通过 fs 模块同步读取文件后编译执行.node 文件：这是用 C/C++ 编写的扩展文件，通过 dlopen() 方法加载最后编译生成的文件.json 文件：通过 fs 模块同步读取文件后，用 JSON.parse() 解析返回结果其余扩展名：它们都被当做 .js 文件载入每一个编译成功的模块都会将其文件路径作为索引缓存在 Module._cache 对象上，以提高二次引入的性能模块内部全局变量的由来:require、exports、module、__filename、__dirname等变量的由来：在编译的过程中，Node 对获取的 JavaScript 文件内容进行了头尾包装。在头部添加了 (function (exports, require, module, __filename, __dirname) {\\n，在尾部添加了 \\n})这样每个模块文件之间都进行了作用域隔离"},{"id":"8f09317cfe38fa2e2d656e25a98f039e","isRootIndexFile":false,"isIndexFile":false,"filename":"nodejs 事件循环.md","basename":"nodejs 事件循环","path":"/home/runner/work/qxtang.github.io/qxtang.github.io/前端/NodeJS","content":"nodejs 事件循环执行顺序如下：timers：计时器，执行 setTimeout 和 setInterval 的回调pending callbacks：执行延迟到下一个循环迭代的 I/O 回调idle, prepare：队列的移动，仅系统内部使用poll 轮询：检索新的 I/O 事件；执行与 I/O 相关的回调。事实上除了其他几个阶段处理的事情，其他几乎所有的异步都在这个阶段处理。check：执行 setImmediate 回调，setImmediate 在这里执行close callbacks: 执行 close 事件的 callback，一些关闭的回调函数，如：socket.on('close', ...)什么是事件循环通过将操作转移到系统内核中来执行非阻塞 I/O 操作（尽管 JavaScript 是单线程的）当这些操作之一完成时，内核会告诉 Node.js，以便可以将适当的回调添加到轮询队列中以最终执行。"}]},{"id":"e26377f01f43ebcc8b63fd1168710356","dirname":"Typescript","filename":"","basename":"","path":"/home/runner/work/qxtang.github.io/qxtang.github.io/前端","children":[{"id":"88e6a4b5e6ea3b429fe0c6375020d9b3","isRootIndexFile":false,"isIndexFile":true,"filename":"index.md","basename":"Typescript","path":"/home/runner/work/qxtang.github.io/qxtang.github.io/前端/Typescript","content":"Typescript强类型 Javascript 超集，支持 ES6 语法，支持面向对象，不直接在浏览器上运行，需要编译器编译成 Javascript 来运行，对 js 进行静态类型检查使工程更严谨、增强可维护性、ide 提示参数校验，利于团队规范有学习成本基础类型number、string、boolean、Array、object、Symbol、Tuple、enum、never、void、null、undefined、anyany 和 unknown 的区别：any 直接放弃类型检查（我不在乎它的类型）unkonwn，类型安全的 any，会对 unknown 类型的变量执行类型检查类型断言不确定类型的时候访问其中一个类型的属性或方法时使用断言类型断言对运行没有影响，仅供编译器使用向编译器提供我们所希望的分析代码的提示表示断言的两种方式：1：&lt;类型&gt;变量 2：变量 as 类型 （在 tsx 中只能使用这种方式）接口可以定义对象、数组、函数、类等为一个变量类型进行命名，定义契约可以相互继承可以继承类可选属性与额外检查装饰器是一种特殊类型的声明，它能被附加在类、方法、属性、访问符、参数上装饰器使用 @expression 这种方式，expression 求值后必须为一个函数，它在运行时调用，被装饰器声明的信息作为参数传入Declare在 .ts 中使用第三方库时没有 .d.ts 声明文件的时候，我们可以通过 declare 来写声明文件可以声明该模块，甚至可以直接声明一个值为 any 的同名的变量，然后我们就可以在代码中直接使用该三方库了tsconfig.json该文件存在于 Typescript 项目的根目录里，其作用是指定相关选项告诉 ts 编译器如何编译 ts 文件所有选项：https://www.tslang.cn/docs/handbook/compiler-options.htmlinfer 的含义声明一个类型变量并且对它进行使用type ReturnType&lt;T&gt; = T extends (...args: any[]) =&gt; infer R ? R : any;project referencesTypeScript 3.0 新功能，允许将 TypeScript 程序构建为更小的部分缩短构建时间，实现组件之间的逻辑分离，以更好方式组织代码https://www.tslang.cn/docs/handbook/project-references.htmlhttps://blog.csdn.net/qiwoo_weekly/article/details/126295762意义：假设 a 模块和 b 模块都很大，编译要很久，但是两者的关联不是特别大。a 模块下的变动基本和 b 模块下的没啥关系，但是 a 变了，b 也要重新编译，b 变了 a 也要重新编译，很没必要使用：模块下各自创建一个 tsconfig.json，要求 compilerOptions.composite 设置为 true在根目录的 tsconfig.json 里加上一个 references 的配置，引入 a 模块 和 b 模块{  &quot;references&quot;: [    {      &quot;path&quot;: &quot;packages/a&quot;    },    {      &quot;path&quot;: &quot;packages/b&quot;    }  ]}执行 tsc --build 进行编译dts 文件使用 js 编写的库的类型声明文件用 ts 写的模块在发布时仍然是用 js 发布，这就导致一个问题：ts 那么多类型数据都没了，所以需要一个 d.ts 文件来标记某个 js 库里面导出对象的类型调用时编辑器能根据这个文件给出提示可以通过 npm 安装对应类库的类型包，https://www.npmjs.com/~types，类型包会安装在 ./node_modules/@types 文件夹中重载定义以多种方式调用的函数定义一组带有参数和返回类型的函数用于实现不同参数输入并且对应不同参数输出的函数function getMessage(id: number): Message | undefined;function getMessage(type: MessageType): Message[];function getMessage(query: any): any {  if (typeof query === &#x27;number&#x27;) {    return data.find((message) =&gt; message.id === query);  } else {    return data.filter((message) =&gt; message.type === query);  }}定义一个 interface，如何依据 a 参数的值来决定 b 参数是否可选？使用联合类型type IParams = { type: &#x27;a&#x27; } | { type: &#x27;b&#x27;; params: string };const a: IParams = { type: &#x27;a&#x27; };const b: IParams = { type: &#x27;b&#x27;, params: &#x27;&#x27; };三斜线指令理解成 import，必须放在文件最顶部已经不推荐"},{"id":"2206d2b37f42da1adaa694678f5ab1a7","isRootIndexFile":false,"isIndexFile":false,"filename":"最佳实践.md","basename":"最佳实践","path":"/home/runner/work/qxtang.github.io/qxtang.github.io/前端/Typescript","content":"最佳实践接口命名以大写字母 I 开头，来自：http://wiki.eclipse.org/Naming_Conventions#Classes_and_Interfacestype 类型以大写字母 T 开头类型定义文件(.d.ts)如何放置临时类型，在使用时定义组件个性化类型，定义在 ts(x) 文件中范围/全局数据，定义在 global.d.ts 文件中，并在 tsconfig.json 配置让其生效"},{"id":"d1a53b4db0dc8c329637406aea552fc0","isRootIndexFile":false,"isIndexFile":false,"filename":"模板字面量类型.md","basename":"模板字面量类型","path":"/home/runner/work/qxtang.github.io/qxtang.github.io/前端/Typescript","content":"模板字面量类型TypeScript 4.1 版本新功能提供了连接字符串字面量的能力可以把非字符串基本类型的字面量转换为对应的字符串字面量类型// css 的 margin、padding 属性type Direction = &#x27;left&#x27; | &#x27;right&#x27; | &#x27;top&#x27; | &#x27;bottom&#x27;;type CssPadding = `padding-${Direction}`;type MarginPadding = `margin-${Direction}`;// 实用例子type EventName&lt;T extends string&gt; = `${T}Changed`;type Concat&lt;S1 extends string, S2 extends string&gt; = `${S1}-${S2}`;type ToString&lt;T extends string | number | boolean | bigint&gt; = `${T}`;type T0 = EventName&lt;&#x27;foo&#x27;&gt;; // &#x27;fooChanged&#x27;type T1 = Concat&lt;&#x27;Hello&#x27;, &#x27;World&#x27;&gt;; // &#x27;Hello-World&#x27;type T2 = ToString&lt;&#x27;阿宝哥&#x27; | 666 | true | -1234n&gt;; // &quot;阿宝哥&quot; | &quot;true&quot; | &quot;666&quot; | &quot;-1234&quot;当类型占位符的实际类型是联合类型（A ｜ B ｜ C）的话，就会被自动展开type T3 = EventName&lt;&#x27;foo&#x27; | &#x27;bar&#x27; | &#x27;baz&#x27;&gt;;// &quot;fooChanged&quot; | &quot;barChanged&quot; | &quot;bazChanged&quot;type T4 = Concat&lt;&#x27;top&#x27; | &#x27;bottom&#x27;, &#x27;left&#x27; | &#x27;right&#x27;&gt;;// &quot;top-left&quot; | &quot;top-right&quot; | &quot;bottom-left&quot; | &quot;bottom-right&quot;"},{"id":"dbb1c8bc7bec09221e4d874f78412724","isRootIndexFile":false,"isIndexFile":false,"filename":"泛型.md","basename":"泛型","path":"/home/runner/work/qxtang.github.io/qxtang.github.io/前端/Typescript","content":"泛型类型变量，由尖括号包裹可以作用在函数、类、接口上可以被约束支持默认类型使用场景函数、接口或类，需要处理多种数据类型时函数、接口或类，在多个地方使用该数据类型时泛型约束确保属性存在没有进行约束，访问属性，会报错：function trace&lt;T&gt;(arg: T): T {  console.log(arg.size); // Error: Property &#x27;size doesn&#x27;t exist on type &#x27;T&#x27;}使用 extends 关键字进行约束：interface Sizeable {  size: number;}function trace&lt;T extends Sizeable&gt;(arg: T): T {  console.log(arg.size);}检查对象上的键是否存在限制输入的属性名包含在 keyof 返回的联合类型中：// 确保参数 key 一定是对象中含有的键function getProperty&lt;T, K extends keyof T&gt;(obj: T, key: K): T[K] {  return obj[key];}条件类型以一个条件表达式进行类型关系检测，从而在两种类型中选择其一：// 若 T 能够赋值给 U，那么类型是 X，否则为 YT extends U ? X : Y通常还会结合 infer 关键字，实现类型抽取：interface Dictionary&lt;T = any&gt; {  [key: string]: T;}type StrDict = Dictionary&lt;string&gt;;type DictMember&lt;T&gt; = T extends Dictionary&lt;infer V&gt; ? V : never;type StrDictMember = DictMember&lt;StrDict&gt;; // string"}]},{"id":"33ad97dd1c1de1c20e8d0ee982f532b8","dirname":"性能优化","filename":"","basename":"","path":"/home/runner/work/qxtang.github.io/qxtang.github.io/前端","children":[{"id":"6cf99ad7581315b326dd02ee831d434d","isRootIndexFile":false,"isIndexFile":true,"filename":"index.md","basename":"性能优化","path":"/home/runner/work/qxtang.github.io/qxtang.github.io/前端/性能优化","content":"性能优化gzip只对文本文件有效，比如 js、css，流文件无效，比如图片需要浏览器和服务端的同时支持浏览器支持：请求头中添加 accept-encoding，标识对压缩的支持，说明自己接受哪些压缩方法服务端支持：能够返回经过 gzip 压缩的文件，响应头添加 content-encoding: gzip，这个字段用于说明数据的压缩方法服务器实时压缩：可通过配置 nginx 开启，express 框架中有一个 compression 中间件，也可以开启 gzip构建时压缩：可在前端构建时使用 compression-webpack-plugin 插件，减少耗费服务器 CPU 和时间开销https://segmentfault.com/a/1190000012800222Javascript缓存 dom 查找结果用 innerHTML 代替 DOM 操作，减少 DOM 操作次数不频繁修改 DOM如果要修改 DOM 的多个样式可以用 cssText 一次性将要改的样式写入，或将样式写到 class 里，再修改 DOM 的 class 名称// badconst el = document.querySelector(&#x27;.myDiv&#x27;);el.style.borderLeft = &#x27;1px&#x27;;el.style.borderRight = &#x27;2px&#x27;;el.style.padding = &#x27;5px&#x27;;// goodconst el = document.querySelector(&#x27;.myDiv&#x27;);el.style.cssText += &#x27;border-left: 1px; border-right: 2px; padding: 5px;&#x27;;// cssText 会覆盖已存在的样式，所以使用 +=列表绑定事件，使用事件委托如无必要，不要重写原生方法，因为原生方法底层是用 C/C++实现的，速度更快CSS 能做的事情，尽量不用 JS 来做使用 requestAnimationFrameCSS避免 css 表达式比如 calc减少选择层级，最高不超过 3 层尽量使用 class 选择器，避免使用标签选择器少使用后代选择器，后代选择器开销高避免对可继承的属性重复定义避免使用通配规则器 *，只对需要的元素进行处理属性值为 0 时，不加单位webpack压缩 js、css 代码webpack 按需加载，React.lazy + import()，Webpack 4 之后，只需要用异步语句 require.ensure(&quot;./xx.js&quot;) 或 import(&quot;./xx.js&quot;) 方式引入模块，就可以实现模块动态加载，遇到异步引入语句时会为该模块单独生成一个 chunk配置 external，将通用库抽离，不打包进 bundle，比如 jquery、lodash，使用 CDN，并开启强缓存配置 babel 动态 polyfill，只针对不支持的浏览器引入 polyfill配置 file-loader 的 limit 选项，小图转 base64开启 tree-shaking 删除多余代码antd 按需加载，babel-plugin-importwebpack 拆包优化第三方库按需加载动态 polyfill 方案​polyfill.io​​（Polyfill Service）（推荐）是一个 script 资源：https://cdn.polyfill.io/v2/polyfill.js识别请求中的 User Agent，判断浏览器是否支持某些特性，然后下发不同的 Polyfillbabel-polyfillReact 16 官方推荐包体积 200k+，难以单独抽离 Map、Set；项目里 react 是单独引用的 cdn，如果要用它需要单独构建一份放 react 前加载babel-plugin-transform-runtime能只 polyfill 用到的类或方法，相对体积较小不能 polyfill 原型上的方法，不适用于业务项目的复杂开发环境其他不常修改的资源（jquery），开启强缓存，配置响应头 Cache-Control 与 Expires减少 http 请求次数：雪碧图、小图片使用字体图标代替css 放顶部、js 放底部，非关键性的脚本（比如百度统计），script 标签加上 defer 或者 async单页应用首屏加载放个 loading，优化用户感知，利用一些过渡效果、骨架屏使用 link 标签的 rel 属性，设置 prefetch、preload（preload 将会把资源得下载顺序权重提高，使得关键数据提前下载好，优化页面打开速度）注意项目中是否使用了字体，字体加载也会让首屏加载变得很慢减少 cookie 的体积使用公共 CDN，好处：如果其他网站刚好也用过同一个资源，浏览器会有缓存服务端开启 gzip（gzip 只对文本文件有效，比如 js、css，流文件无效，比如图片）路由懒加载图片懒加载使用字体图标 iconfont 代替图片图标，不会失真，生成的文件体积小将静态资源放在其他域名的原因（CDN）：浏览器对于相同域名有并发请求数限制请求时不会发送 cookie，节省流量cookie 会发送给二级域名，所以这些静态资源不放在二级域名，放在单独一级域名script 标签的 defer 和 async没有 defer 或 async 属性，浏览器会立即加载并执行相应的脚本async：立即下载，下载完立即执行，不确定顺序执行。对于完全独立的脚本来才去使用 async，比如谷歌统计百度统计。一定会在页面的 load 事件前执行，但不确定在 DOMContentLoaded 事件触发前后执行。defer：立即下载，将延迟到整个页面都解析完毕后再运行js 为什么放最下面？当文档加载过程中遇到 js 文件，html 文档会挂起渲染（加载解析渲染同步）的线程，不仅要等待文档中 js 文件加载完毕，还要等待解析执行完毕，才可以恢复 html 文档的渲染线程，因为 js 有可能会修改 DOM，比如 document.write，这意味着，在 js 执行完成前，后续所有资源的下载可能是没有必要的，这是 js 阻塞后续资源下载的原因。所以平时的代码中，js 是放在 html 文档末尾的css 为什么放最上面？css 不会阻塞 DOM 的解析，但会阻塞 DOM 渲染css 是由单独的下载线程异步下载的但会阻塞 render 树渲染（渲染时需等 css 加载完毕，因为 render 树需要 css 信息）如何判断一个页面卡顿的原因内存泄漏，由于疏忽或者程序的某些错误造成未能释放已经不再使用的内存的情况（比如不再使用的变量额外创建）Chrome devTools Performance 查看内存情况打开 Chrome 的无痕模式，这样做的目的是为了屏蔽掉 Chrome 插件对我们之后测试内存占用情况的影响"},{"id":"c11d2c8e36934046c73bfc440376402d","isRootIndexFile":false,"isIndexFile":false,"filename":"首屏加载优化.md","basename":"首屏加载优化","path":"/home/runner/work/qxtang.github.io/qxtang.github.io/前端/性能优化","content":"首屏加载优化在 root 节点中写一些东西&lt;!-- 不美观 --&gt;&lt;div class=&quot;root&quot;&gt;Loading...&lt;/div&gt;&lt;div id=&quot;root&quot;&gt;  &lt;!-- 这里画一个 SVG --&gt;&lt;/div&gt;使用 html-webpack-plugin 自动插入 loading：var HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;);var path = require(&#x27;path&#x27;);// 读取写好的 loading 态的 html 和 cssvar loading = {  html: fs.readFileSync(path.join(__dirname, &#x27;./loading.html&#x27;)),  css: &#x27;&lt;style&gt;&#x27; + fs.readFileSync(path.join(__dirname, &#x27;./loading.css&#x27;)) + &#x27;&lt;/style&gt;&#x27;,};var webpackConfig = {  entry: &#x27;index.js&#x27;,  output: {    path: path.resolve(__dirname, &#x27;./dist&#x27;),    filename: &#x27;index_bundle.js&#x27;,  },  plugins: [    new HtmlWebpackPlugin({      filename: &#x27;xxxx.html&#x27;,      template: &#x27;template.html&#x27;,      loading: loading,    }),  ],};&lt;!-- 在模板中引用 --&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;  &lt;head&gt;    &lt;%= htmlWebpackPlugin.options.loading.css %&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;div id=&quot;root&quot;&gt;&lt;%= htmlWebpackPlugin.options.loading.html %&gt;&lt;/div&gt;  &lt;/body&gt;&lt;/html&gt;使用 SplitChunksPlugin 自动拆分业务基础库编译到 ES2015+ 提升代码运行效率大多数项目的做法是，编写 ES6+ 的代码，然后在构建时编译到 ES5 运行，不仅体积大，而且运行速度慢大部分现代浏览器已经原生支持 ES6+把代码编译到 ES6+，然后为少数使用老旧浏览器的用户保留一个 ES5 标准的备胎即可使用 &lt;script type=&quot;module&quot;&gt;，支持这个的浏览器必然支持 ES6，不支持 type module 的浏览器会因为无法识别这个标签，而不去加载老旧浏览器无法识别 nomodule 属性，会自动忽略，从而加载 ES5 标准的代码&lt;script type=&quot;module&quot; src=&quot;main.js&quot;&gt;&lt;/script&gt;&lt;script nomodule src=&quot;main.es5.js&quot;&gt;&lt;/script&gt;骨架屏、react-placeholder 提前撑开页面布局避免出现闪屏"}]},{"id":"202854a467fa8bd1203b04de57f5f58e","dirname":"构建工具","filename":"","basename":"","path":"/home/runner/work/qxtang.github.io/qxtang.github.io/前端","children":[{"id":"6f85932b26cde835858cbc88ecf94e68","dirname":"Webpack","filename":"","basename":"","path":"/home/runner/work/qxtang.github.io/qxtang.github.io/前端/构建工具","children":[{"id":"77ac9fce726c5973108601166c072dda","isRootIndexFile":false,"isIndexFile":false,"filename":"Loader.md","basename":"Loader","path":"/home/runner/work/qxtang.github.io/qxtang.github.io/前端/构建工具/Webpack","content":"LoaderLoader 本质上是导出函数的 JavaScript 模块，可用于实现内容转换，进行各种文件类型的加载与转换，比如 babel-loader 将 jsx 转为 React.createElementwebpack 只认识 JavaScript，Loader 将资源转化成 Webpack 可以理解的内容当 Webpack 在转换某文件类型的时候，会按顺序链式调用每一个 loaderloader 的开发需要遵循一些规范，比如返回值必须是标准的 JS 代码字符串，以保证下一个 loader 能够正常工作编写 loaderhttps://webpack.docschina.org/contribute/writing-a-loader/通常是一个函数module.exports = function (source, sourceMap?, data?) {  // source：为 loader 的输入，可能是文件内容，也可能是上一个 loader 处理结果  // sourceMap：可选参数，代码的 sourcemap 结构  // data：可选参数，其它需要在 Loader 链中传递的信息  return source;};通过 return 语句返回处理结果，除此之外 Loader 还可以调用 callback api 返回更多信息，供下游 Loader 或者 Webpack 本身使用callback 签名：this.callback(  // 异常信息，Loader 正常运行时传递 null 值即可  err: Error | null,  // 转译结果  content: string | Buffer,  // 源码的 sourcemap 信息  sourceMap?: SourceMap,  // 任意需要在 Loader 间传递的值  // 经常用来传递 ast 对象，避免重复解析  data?: any);loader 例子：module.exports = function (source) {  const content = doSomeThing2JsString(source);  // 如果 loader 配置了 options 对象，那么this.query将指向 options  const options = this.query;  // 可以用作解析其他模块路径的上下文  console.log(&#x27;this.context&#x27;);  /*   * this.callback 参数：   * error：Error | null，当 loader 出错时向外抛出一个 error   * content：String | Buffer，经过 loader 编译后需要导出的内容   * sourceMap：为方便调试生成的编译后内容的 source map   * ast：本次编译生成的 AST 静态语法树，之后执行的 loader 可以直接使用这个 AST，进而省去重复生成 AST 的过程   */  this.callback(null, content);  // or return content;};为什么 loader 执行顺序是从右到左webpack 选择了函数式编程的方式，最左侧的 loader 返回值必须是 JS 模块，不然 webpack 无法识别其他语言模块（webpack 只认识 JS 和 JSON）常见 loaderraw-loader：加载文件原始内容（utf-8）image-loader：加载并且压缩图片文件file-loader: 加载文件资源，如 字体 / 图片 等，具有移动/复制/命名等功能、把文件输出到一个文件夹中，在代码中通过相对 URL 去引用输出的文件url-loader: 通常用于加载图片，可以将小图片直接转换为 Date Url，减少请求；和 file-loader 类似，但是能在文件很小的情况下以 base64 的方式把文件内容注入到代码中去babel-loader: 加载 js / jsx 文件， 将 ES6 / ES7 代码转换成 ES5，抹平兼容性问题；ts-loader: 加载 ts / tsx 文件，编译 TypeScript；style-loader: 将 css 代码以 style 标签形式插入"},{"id":"0d16c3d58f2b85b4a6169303822d1b2d","isRootIndexFile":false,"isIndexFile":false,"filename":"Plugin.md","basename":"Plugin","path":"/home/runner/work/qxtang.github.io/qxtang.github.io/前端/构建工具/Webpack","content":"Pluginhttps://www.webpackjs.com/contribute/writing-a-plugin/构建流程中引入自定义的行为，需要理解 webpack 底层的特性来处理相应的钩子通常是一个带有 apply 方法的类在 Webpack 运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果compiler 暴露了和 Webpack 整个生命周期相关的钩子：https://www.webpackjs.com/api/compiler-hooks/compilation 则暴露了与模块和依赖有关的粒度更小的事件钩子：https://www.webpackjs.com/api/compilation-hooks/class MyPlugin {  apply(compiler) {    // 找到合适的事件钩子，实现自己的插件功能    compiler.hooks.emit.tap(&#x27;MyPlugin&#x27;, (compilation) =&gt; {      // compilation: 当前打包构建流程的上下文      console.log(compilation);      // do something...    });  }}常见 PlugindefinePlugin：定义环境变量html-webpack-pluginmini-css-extract-plugin: 分离样式文件，CSS 提取为独立文件，支持按需加载 (替代 extract-text-webpack-plugin)clean-webpack-plugin"},{"id":"221e77f2f876cc679c9968521e7146d2","isRootIndexFile":false,"isIndexFile":true,"filename":"index.md","basename":"Webpack","path":"/home/runner/work/qxtang.github.io/qxtang.github.io/前端/构建工具/Webpack","content":"Webpack模块打包工具，处理浏览器不认识的各种资源，让其能够运行在浏览器基于入口文件，递归解析入口所需要加载的所有资源，然后用不同的 loader 来处理不同类型的文件，用 Plugin 来扩展 webpack 的功能通过分析模块之间的依赖，最终将所有模块打包成一份或者多份代码包，供 HTML 直接引用Webpack 仅提供打包功能和文件处理，通过生态中的各种 Loader 和 Plugin 对代码进行预编译和打包因此 Webpack 具有高度的可拓展性，能更好的发挥社区生态的力量作用模块打包使我们在开发时可以使用新特性和新语法能力扩展：plugin、loader概念Entry: 入口文件，Webpack 会从该文件开始进行分析与编译；Output: 出口路径，打包后创建 bundler 的文件路径以及文件名；Module: 源码目录中的每一个文件，在 Webpack 中任何文件都可以作为一个模块，会根据配置的不同的 Loader 进行加载和打包；Chunk: webpack 打包过程中的产物，在进行模块的依赖分析的时候，代码分割出来的代码块，可以根据配置，将所有模块代码合并成一个或多个代码块，以便按需加载，提高性能；chunk 类型Initial Chunk：基于 Entry 配置项生成的 ChunkAsync Chunk：异步模块引用，如 import() 语句对应的异步 ChunkRuntime Chunk：只包含运行时代码的 ChunkLoader: 模块加载器，进行各种文件类型的加载与转换，比如 babel-loader 将 jsx 转为 React.createElement；Plugin: 拓展插件，可以通过 Webpack 相应的事件钩子，介入到打包过程中的任意环节，从而对代码按需修改；Bundle: webpack 打包出来的文件，webpack 最终输出的东西，可以直接在浏览器运行。在抽离 css(当然也可以是图片、字体文件之类的)的情况下，一个 chunk 是会输出多个 bundle 的，但是默认情况下一般一个 chunk 也只是会输出一个 bundlevendor: 依赖的第三方库文件指纹hash：所有的 bundle 使用同一个 hash 值，跟每一次 webpack 打包的过程有关chunkhash：根据每一个 chunk 的内容进行 hash，同一个 chunk 的所有 bundle 产物的 chunkhash 值是一样的。因此若其中一个 bundle 的修改，同一 chunk 的所有产物 hash 也会被修改contenthash：与文件内容本身相关注意：开发环境热更新下只能使用 hash 或者不使用 hash。在生产环境中我们一般使用 contenthash 或者 chunkhash，因为在热更新模式下，会导致 chunkhash 和 contenthash 计算错误配置示例const path = require(&#x27;path&#x27;);module.exports = {  entry: &#x27;./src/index.js&#x27;,  devtool: &#x27;inline-source-map&#x27;,  devServer: {    static: &#x27;./dist&#x27;,  },  plugins: [    new HtmlWebpackPlugin({      title: &#x27;Output Management&#x27;,    }),  ],  output: {    filename: &#x27;[name].[contenthash].js&#x27;,    path: path.resolve(__dirname, &#x27;dist&#x27;),    clean: true,    publicPath: &#x27;/&#x27;,  },  externals: {    lodash: {      commonjs: &#x27;lodash&#x27;,      commonjs2: &#x27;lodash&#x27;,      amd: &#x27;lodash&#x27;,      root: &#x27;_&#x27;,    },  },  optimization: {    splitChunks: {      cacheGroups: {        vendor: {          test: /[\\\\/]node_modules[\\\\/]/,          name: &#x27;vendors&#x27;,          chunks: &#x27;all&#x27;,        },      },    },  },  module: {    rules: [      {        test: /\\.css$/i,        use: [&#x27;style-loader&#x27;, &#x27;css-loader&#x27;],      },      {        test: /\\.(png|svg|jpg|jpeg|gif)$/i,        type: &#x27;asset/resource&#x27;,      },    ],  },};工作流程初始化初始化配置参数：从配置文件和 Shell 参数中读取与合并得出参数创建编译器对象 Compiler初始化编译环境：包括注入内置插件、注册各种模块工厂、加载配置的插件等开始编译：执行 compiler 对象的 run 方法确定入口：根据配置中的 entry 找出所有的入口文件构建编译模块：从入口文件出发，调用 loader 将模块转译为标准 JS 内容，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理，并在合适的时机点触发广播事件，Plugin 收听这些事件执行相应方法完成模块编译：上一步递归处理所有能触达到的模块后，得到了每个模块被翻译后的内容以及它们之间的 依赖关系图生成输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会写入文件系统：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统以上过程中，Webpack 会在特定的时间点广播出特定的事件，插件在监听到事件后会执行特定逻辑，并且插件可以调用 Webpack 提供的 api 改变 Webpack 的运行结果rollup 和 webpack 区别webpack 支持代码拆分、按需加载rollup 所有资源放在同一个地方，一次性加载，利用 tree-shake 特性来剔除项目中未使用的代码，减少冗余对于应用使用 webpack，对于类库使用 rollup，rollup 适用于基础库的打包，如 vue、react如果你需要代码拆分(Code Splitting)，或者你有很多静态资源需要处理，再或者你构建的项目需要引入很多 CommonJS 模块的依赖，那么 webpack 是个很不错的选择如果您的代码库是基于 ES2015 模块的，而且希望你写的代码能够被其他人直接使用，你需要的打包工具可能是 rollupTree-Shaking基于 ES Module 规范的死码删除技术在运行过程中静态分析模块之间的导入导出，确定 ESM 模块中哪些导出值未曾被其它模块使用，并将其删除，以此实现打包产物的优化实现 Tree Shaking 技术的必要条件在 CommonJs、AMD、CMD 等旧版本的 JavaScript 模块化方案中，导入导出行为是高度动态，难以预测的而 ESM 方案则从规范层面规避这一行为，它要求所有的导入导出语句只能出现在模块顶层，且导入导出的模块名必须为字符串常量所以，ESM 下模块之间的依赖关系是高度确定的，与运行状态无关，编译工具只需要对 ESM 模块做静态分析，就可以从代码字面量中推断出哪些模块值未曾被其它模块使用"},{"id":"6a8be065958c2dbe5dd2fd911d7e09e1","isRootIndexFile":false,"isIndexFile":false,"filename":"分包.md","basename":"分包","path":"/home/runner/work/qxtang.github.io/qxtang.github.io/前端/构建工具/Webpack","content":"webpack 分包为什么分包资源冗余：客户端必须等待整个应用的代码包都加载完毕才能启动运行，但可能用户当下访问的内容只需要使用其中一部分代码缓存失效：将所有资源打成一个包，即使只是修改一个字符，浏览器都需要重新下载整个代码包，缓存命中率低配置 optimization.splitChunksmodule.exports = {  optimization: {    splitChunks: {      // 表示选择哪些 chunks 进行分割，可选值有：async、initial、all      chunks: &#x27;async&#x27;,      // 形成一个新代码块最小的体积，表示新分离出的chunk必须大于等于minSize，默认为30000，约30kb。      minSize: 30000,      // 表示一个模块至少应被minChunks个chunk所包含才能分割。默认为1。      minChunks: 1,      // 表示按需加载文件时，并行请求的最大数目。默认为5。      maxAsyncRequests: 5,      // 表示加载入口文件时，并行请求的最大数目。默认为3。      maxInitialRequests: 3,      // 表示拆分出的chunk的名称连接符。默认为~。如chunk~vendors.js      automaticNameDelimiter: &#x27;~&#x27;,      // 设置chunk的文件名。默认为true。当为true时，splitChunks基于chunk和cacheGroups的key自动命名。      name: true,      // cacheGroups 下可以可以配置多个组，每个组根据test设置条件，符合test条件的模块，就分配到该组。模块可以被多个组引用，但最终会根据priority来决定打包到哪个组中。默认将所有来自 node_modules目录的模块打包至vendors组，将两个以上的chunk所共享的模块打包至default组。      cacheGroups: {        vendors: {          test: /[\\\\/]node_modules[\\\\/]/,          priority: -10,        },        default: {          minChunks: 2,          priority: -20,          reuseExistingChunk: true,        },      },    },  },};默认分包规则同一个 entry 下触达到的模块组织成一个 chunk异步模块（import()或require.ensure()）单独组织为一个 chunkentry.runtime 单独组织成一个 chunkRuntime（运行时代码） 分包Webpack 5 还能根据 entry.runtime 配置单独打包运行时代码runtime除业务代码外，Webpack 编译产物中还需要包含一些用于支持 webpack 模块化、异步加载等特性的支撑性代码，这类代码在 webpack 中被统称为 runtime最佳实践尽量将第三方库拆为独立分包按路由分包，减少首屏资源负载"},{"id":"5a742e6fb38ae9c0d979d1f69259ad4e","isRootIndexFile":false,"isIndexFile":false,"filename":"最佳实践.md","basename":"最佳实践","path":"/home/runner/work/qxtang.github.io/qxtang.github.io/前端/构建工具/Webpack","content":"最佳实践使用 html-webpack-plugin 配置 html 模板文件使用 clean-webpack-plugin 在打包输出前清空文件夹为 css 添加浏览器前缀：postcss-loader autoprefixer使用 mini-css-extract-plugin，把 css 样式从 js 文件中提取到单独的 css 文件中使用 extract-text-webpack-plugin 拆分多个 css使用 file-loader、url-loader 打包 图片、字体、媒体、等文件使用 HotModuleReplacementPlugin 配置 webpack-dev-server 进行热更新合理的配置 mode 参数与 devtool 参数缩小文件的搜索范围，配置 include exclude alias noParse extensions使用 HappyPack 开启多进程 Loader 转换使用 webpack-parallel-uglify-plugin 增强代码压缩使用 webpack 内置的 DllPlugin DllReferencePlugin 抽离第三方模块配置缓存：cache-loader引入 webpack-bundle-analyzer 分析打包后的文件externals：有时我们希望我们通过 script 引入的库，如用 CDN 的方式引入的 jquery，我们在使用时，依旧用 require 的方式来使用，但是却不希望 webpack 将它又编译进文件中参考https://juejin.cn/post/6844904031240863758"},{"id":"d937c989871b6907ced1fcc5663c0d5b","isRootIndexFile":false,"isIndexFile":false,"filename":"构建优化.md","basename":"构建优化","path":"/home/runner/work/qxtang.github.io/qxtang.github.io/前端/构建工具/Webpack","content":"构建优化分析工具webpack-bundle-analyzer：可视化方式看打包的 bundle 中包含哪些模块内容、大小webpackbar：实时显示打包进度实时显示打包进度：可以看到每个 loader 和 plugin 耗时情况speed-measure-webpack-plugin：分析打包速度构建速度优化思路：从 模块搜索时间、解析时间、压缩时间、二次打包时间 入手多进程构建运行在 Node.js 之上的 webpack 是单线程模式的，webpack 打包只能逐个文件处理使用 happypack（废弃）、thread-loader（推荐）仅在耗时的 loader 上使用，如果是小项目，不要开启多进程构建，开启进程需要花费时间，构建反而变慢// 把它放置在其它 loader 之前module.exports = {  module: {    rules: [      {        test: /\\.js$/,        use: [&#x27;thread-loader&#x27;, &#x27;babel-loader&#x27;],      },    ],  },};thread-loader 需要放在 style-loader 之后：因为 thread-loader 后的 loader 没法存取文件也没法获取 webpack 的选项设置利用缓存，提升二次构建速度使用缓存后，node_modules 中会有一个.cache 目录，用于存放缓存内容cache-loader：只对性能开销较大的 loader 使用，保存和读取缓存文件有开销module.exports = {  module: {    rules: [      {        test: /\\.js$/,        use: [&#x27;cache-loader&#x27;, &#x27;babel-loader&#x27;],      },    ],  },};babel-loader 开启缓存，在 babel-loader 后面加上?cacheDirectory=truehard-source-webpack-plugin：用于开启模块的缓存terser-webpack-plugin 开启缓存缩小打包作用域exclude/include：确定 loader 规则范围，node_modules 里的 js 文件基本上都是转译好了的，不需要再次处理，用 include/exclude 来避免不必要的转译优化 resolve.alias：可减少耗时的递归解析操作优化 resolve.extensions：列表要尽可能的小，尽可能减少后缀尝试次数；频率出现高的后缀优先放前面，尽快退出寻找过程；写导入语句时，尽可能带上后缀，避免寻找过程resolve.modules：指明第三方模块的绝对路径，减少不必要的查找优化 resolve.mainFields：一些第三方模块会针对不同环境提供几分代码，位置写在 package.json 文件里，webpack 会根据 mainFields 配置决定优先采用哪份代码优化 module.noParse：对不需要解析的库进行忽略（jquery、echarts），不解析但仍打包到 bundle 中，被忽略掉的文件里不应该包含 import、require、define 等模块化语句动态链接库将第三方库代码和业务代码都打包进一个 bundle，那么处理这个 bundle 文件的插件（比如压缩之类的插件），就没办法不处理里面第三方库内容第三方库代码基本都是成熟的，不用作处理，可以将第三方库代码分离出来配置 externals，每一个库都在 html 文档中引入一个 script 标签，js 文件下载影响性能，而且我们只使用库中的部分功能，script 标签全量引入不合理SplitChunks 在每一次构建会重新构建第三方库，不能有效提升构建速度使用 DllPlugin 和 DLLReferencePlugin（配合使用，webpack 内置插件），会将不频繁更新的第三方库单独打包，当这些第三方库版本没有变化时，不需要重新构建// webpack.dll.js 用于打包第三方库const path = require(&#x27;path&#x27;);const webpack = require(&#x27;webpack&#x27;);module.exports = {  mode: &#x27;production&#x27;,  entry: {    three: [&#x27;jquery&#x27;, &#x27;lodash&#x27;], // 第三方库配置  },  output: {    filename: &#x27;[name].dll.js&#x27;, // [name] 就是在 entry    path: path.resolve(__dirname, &#x27;dist/lib&#x27;),    library: &#x27;[name]&#x27;,  },  plugins: [    new webpack.DllPlugin({      name: &#x27;[name]&#x27;,      path: path.resolve(__dirname, &#x27;dist/lib/[name].json&#x27;), // manifest.json 的存放位置    }),  ],};module.exports = {  plugins: [    // 修改 CleanWebpackPlugin 配置    new CleanWebpackPlugin({      cleanOnceBeforeBuildPatterns: [        &#x27;!lib/**&#x27;, // 在每次清除 dist 目录时，不清理 lib 文件夹      ],    }),    // dll 相关配置    new webpack.DllReferencePlugin({      // 将 manifest 字段配置成第1步中打包出来的 json 文件      manifest: require(&#x27;./dist/lib/three.json&#x27;),    }),  ],};优化构建体积代码分割分离第三方库和业务代码中的基础库，通过 SplitChunks 或动态链接库动态 import减少首屏资源的体积，非首屏的资源在用到的时候再去请求路由配置使用 import() 来引入页面组件，凡是通过 import() 引用的模块都会打包成独立 bundletree shaking使用 esm 模块规范不要使用 export default那么在 mode：production 生产环境，就会自动开启 tree-shaking，移除没有使用到的代码代码压缩mode：production 自动开启uglifyjs-webpack-plugin（废弃） 和 terser-webpack-plugin（推荐）const TerserPlugin = require(&#x27;terser-webpack-plugin&#x27;);module.exports = {  optimization: {    minimizer: [      new TerserPlugin({        parallel: true, // 开启并行压缩，加快构建速度        sourceMap: true, // 使用 source-maps      }),    ],  },};terser 是什么：用于 ES6+ 的 JavaScript 解析器、mangler/compressor（压缩器）工具包。gzipcompression-webpack-pluginconst CompressionWebpackPlugin = require(&#x27;compression-webpack-plugin&#x27;);module.exports = {  plugins: [    new CompressionWebpackPlugin({      test: /\\.(js|css)$/, // 匹配要压缩的文件      algorithm: &#x27;gzip&#x27;,    }),  ],};"}]},{"id":"2191e11d28af1c9b3c1d457b06e71465","isRootIndexFile":false,"isIndexFile":false,"filename":"Vite.md","basename":"Vite","path":"/home/runner/work/qxtang.github.io/qxtang.github.io/前端/构建工具","content":"Vite待完善与 Webpack 区别利用浏览器的能力，将解析依赖和获取 js 模块的工具交给浏览器去做，减少了分析依赖跟源码打包的成本Vite 项目启动时间很快，把部分在 webpack 启动时做的工作，交给了浏览器去做了Vite 首次启动加载慢，因为模块以 ES6 原生的模块加载机制的方式被浏览器加载，没有对代码进行打包跟压缩处理，因此请求数会更多，下载文件也会更大，但仅仅是首次，第二次启动是会有缓存的"}]},{"id":"9ae474f8d5c1cf60ec72eb3315213643","dirname":"框架","filename":"","basename":"","path":"/home/runner/work/qxtang.github.io/qxtang.github.io/前端","children":[{"id":"a06aba56d0eebc458469010d53c0c769","dirname":"React","filename":"","basename":"","path":"/home/runner/work/qxtang.github.io/qxtang.github.io/前端/框架","children":[{"id":"71ac96ef6cb2e14de08b6dcd91b56f80","isRootIndexFile":false,"isIndexFile":false,"filename":"Fiber.md","basename":"Fiber","path":"/home/runner/work/qxtang.github.io/qxtang.github.io/前端/框架/React","content":"Fiber一种基于浏览器的单线程调度算法核心渲染算法的重新实现，React 团队两年多研究结晶，对 reconciliation 的重新编写，重新实现了 reconciler（协调器），递归改循环目标是提高对动画、布局和手势等领域的适用性将更新分解成更小的任务，达到增量渲染，将渲染工作拆分为块并将其分散到多个帧上，更新不会长时间阻止主线程（比如用户输入，动画之类）其他功能包括能够在新更新到来时暂停，中止或重用工作注意：并不会减少总工作量或更新所需的时间为什么 Fiber旧版 React 在处理 UI 时，使用栈递归遍历树结构，整个过程同步无法被打断，如果树结构太大层级很深，会一直占用浏览器主线程，可能导致动画丢帧（JS 线程和 GUI 线程是互斥的）改变了 react 的组件渲染机制，新的架构使原来同步渲染的组件可以异步化，可中途中断渲染，执行更高优先级的任务。释放浏览器主线程，保证任务在浏览器空闲的时候执行Fiber 执行过程浏览器现有 api：requestIdleCallback（闲时调用）可实现异步渲染，但 React 为了兼容大多数浏览器，自己实现了 requestIdleCallback两个阶段：Reconciliation 与 Commit。Reconciliation 阶段对应早期版本的 diff 过程，Commit 阶段对应早期版本的 patch 过程，以 render 为界阶段一（Reconciliation）：生成 Fiber 树，得出需要更新的节点信息。这一步是一个渐进的过程，可以被打断，让优先级更高的任务先执行阶段二（Commit）：需要更新的节点一次批量更新，这个过程不能打断Reconciliation 阶段，如果遇到更高优先级事件，则进行打断，渲染到一半的组件，会从头开始渲染，一些生命周期可能会重新执行，例如：componentWillMountcomponentWillReceivePropsshouldComponentUpdatecomponentWillUpdate这些生命周期函数会在 Commit 阶段调用：componentDidMountcomponentDidUpdatecomponentWillUnmountFiber 树React 在 render 第一次渲染时，会通过 React.createElement 创建一颗 Element 树，称之为 Virtual DOM Tree由于要记录上下文信息，加入了 Fiber，每一个 Element 会对应一个 Fiber Node将 Fiber Node 链接起来的结构为 Fiber TreeFiber Tree 一个重要的特点是链表结构，将递归遍历改为循环遍历，然后配合 requestIdleCallback API, 实现任务拆分、中断与恢复workInProgress Fiber 树在 React 中会同时存在两棵 Fiber 树，当前显示在页面是 current Fiber 树在内存中构建的 Fiber 树称为 workInProgress Fiber 树workingProgress Fiber 这棵树是在内存中构建的，构建完成才统一替换，这样不会产生不完全的真实 dom一旦更新完成，react 会将 current 树替换成 workInProgress Fiber 树，也是 react 提升性能的一部分Fiber 数据结构interface FiberNode {  stateNode: any; // 节点实例  child: any; // 对应子节点  sibling: any; // 对应兄弟节点  return: any; // 对应父节点}Fiber 为什么使用链表React 使用单链表树遍历算法实现在没有递归的情况下遍历树，之前的树形结构不满足中途暂停对异步友好，可以暂停遍历并使阻止堆栈增长之前的虚拟 DOM 是树结构，当任务被打断后，树结构无法恢复之前的任务继续执行，所以需要一种新的数据结构，即链表，链表可以包含多个指针，可以轻易找到下一个节点，继而恢复任务的执行Fiber 采用的链表中包含三个指针，parent 指向其父 Fiber 节点，child 指向其子 Fiber 节点，sibling 指向其兄弟 Fiber 节点。一个 Fiber 节点对应一个任务节点"},{"id":"7cb50eb9ed462e2df578538d307f112f","isRootIndexFile":false,"isIndexFile":false,"filename":"Hooks.md","basename":"Hooks","path":"/home/runner/work/qxtang.github.io/qxtang.github.io/前端/框架/React","content":"Hooks为什么 hooks类组件性能消耗较大，类组件需要创建实例，而且不能销毁函数组件性能消耗小，不需要创建实例，得到返回的 react 元素后就直接把中间量全部都销毁复用状态逻辑：Hook 使你在无需修改组件结构的情况下复用状态逻辑，可以将含有 state 的逻辑从组件中抽象出来，这将可以让这些逻辑容易被测试，在组件之间复用状态逻辑很难，如果要增加职责的话，就要加一层 HOC，容易形成“嵌套地狱”，一个套一个复杂 class 组件会变得难以理解，比如 componentDidMount 和 componentWillUnmount 是区分开的，Hook 可以将组件中相互关联的部分拆分成更小的函数class 比普通函数更难理解和使用，尤其是 this代码组织上，hooks 将业务逻辑聚合后，整个工程可阅读性大大增加友好渐进式的，项目中可以同时使用 class 和 hooksclass 组件的缺点大型组件难拆分和重构，难测试业务逻辑分散在组件的各个方法之中，导致重复逻辑或关联逻辑组件类引入了复杂的编程模式，比如 render props 和高阶组件难以理解的 class，理解 JavaScript 中 this 的工作方式hook 为什么不能放在循环、条件、嵌套函数执行（为什么顺序调用对 React Hooks 很重要？）Not Magic, just ArraysHook 通过数组实现的，每次 useState 都会改变下标，React 需要利用调用顺序来正确更新相应的状态，否则会引起调用顺序的错乱，从而造成意想不到的错误能确保 Hook 在每一次渲染中都按照同样的顺序被调用，让 React 能够在多次的 useState 和 useEffect 调用之间保持 hook 状态的正确React 依靠 Hook 调用的顺序来知道哪个 state 对应哪个 useState，Hook 的调用顺序在每次渲染中都是相同的，只要 Hook 的调用顺序在多次渲染之间保持一致，React 就能正确地将内部 state 和对应的 Hook 进行关联Hook 需要在我们组件的最顶层调用Hook 重渲染时是依赖于固定顺序调用，来保证被正确识别，依赖数组来维护，有一个 setter 数组和一个索引，该索引在每个 hooks 被调用时递增，并在组件 render 时重置用数组解构语法来命名 useState() 返回的 state 变量，但这些变量不会连接到 React 组件上，数据的存储是独立于组件之外的步骤：初始化：创建两个空数组 setters 与 states，创建一个指针设置为 0首次渲染：每当 useState() 被调用时，如果它是首次渲染，它会通过 push 将一个 setter 方法（绑定了指针“cursor”位置）放进 setters 数组中，同时，也会将另一个对应的状态放进 states 数组中去后续渲染：每次的后续渲染都会重置指针“cursor”的位置，并会从每个数组中读取对应的值处理设置事件：每个 setter 对应一个指针位置的引用，当触发任何 setter 调用的时候，会去改变状态数组中对应索引的值开发工作中可以使用 eslint 配置相关规则发现这一错误hooks 实现为什么用数组不用 map使用 key 值取映射 hook 的话，自定义的 hook 被多个组件调用的话，很难不保证之前有没有同名的 key 在其他组件内用 Symbol：不能很好地复用了，因为 key 值的唯一性使得总是同一个 key 调用了 hookReact 如何区分 Class 组件和 Function 组件instanceof 检查这个函数/类是否是 React.Component 的继承类检查 函数/类.prototype.isReactComponent 属性hooks 特性Effect 拿到的总是定义它的那次渲染中的 props 和 state，在任意一次渲染中，props 和 state 是始终保持不变的，它们都属于一次特定的渲染，同样，每次渲染都有它自己的 Effects可通过 ref 来保存值，实现在所有的渲染帧中共享React 会记住我们设置的 effect 函数，并且会在每次 DOM 更改后、浏览器绘制屏幕后，去调用，这使得应用更流畅，不会阻塞屏幕的更新，上一次的 effect 会在重新渲染后被清除依赖项不要对 React 撒谎：effect 中用到的所有组件内的值都应该包含在依赖中可以使用 setState 的函数形式，获取上一次调用对应 setter 时传的状态值如果某些函数仅在 effect 中调用，可以把它们的定义移到 effect 中，这样可以不再需要去考虑依赖如果一个函数没有使用组件内的任何值，可以把它提到组件外面去定义成纯函数，然后就可以自由地在 effects 中使用（或者把它包装成 useCallback）useEffect 第一个参数，不能返回 Promise，所以不能传递异步函数，可以自己在里面声明再执行定时器的例子// 先点击 alert，再点击几次 add 增加 count，3 秒后弹出的是点击 alert 时的状态function Counter() {  const [count, setCount] = useState(0);  function handleAlertClick() {    setTimeout(() =&gt; {      alert(&#x27;You clicked on: &#x27; + count);    }, 3000);  }  return (    &lt;div&gt;      &lt;p&gt;You clicked {count} times&lt;/p&gt;      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;add&lt;/button&gt;      &lt;button onClick={handleAlertClick}&gt;alert&lt;/button&gt;    &lt;/div&gt;  );}// 而如果是在类组件中，则会正确弹出状态的当前值// 因为类组件的状态保存在实例属性上，状态改变实例不会销毁hooks 缺点useEffect 写函数组件时，必须清楚代码中 useEffect 和 useCallback 的“依赖项数组”的改变时机有时候，useEffect 依赖某个函数的不可变性，这个函数的不可变性又依赖于另一个函数的不可变性，这样便形成了一条依赖链一旦这条依赖链的某个节点意外地被改变了，useEffect 就被意外地触发了过度使用 useMemo 后果useMemo 本身也有开销useMemo 会「记住」一些值，同时在后续 render 时，将依赖数组中的值取出来和上一次记录的值进行比较，如果不相等才会重新执行回调函数，否则直接返回「记住」的值。这个过程本身就会消耗一定的内存和计算资源如果执行的操作开销不大，那么就不需要记住返回值。使用 useMemo 的成本可能会超过重新评估该函数的成本使用前应该先思考三个问题：传递给 useMemo 的函数开销大不大返回的值是否原始值：如果计算出来的是基本类型的值，那么每次比较都是相等的，下游组件就不会重新渲染；如果计算出来的是复杂类型的值（object、array），哪怕值不变，但是地址会发生变化，导致下游组件重新渲染。所以我们也需要「记住」这个值。返回值要保持引用一致性：在编写自定义 Hook 时，因为无法确定外部要如何使用它的返回值。如果返回值被用做其他 Hook 的依赖，并且每次 re-render 时引用不一致（当值相等的情况），就可能会产生 bug。所以如果自定义 Hook 中暴露出来的值是 object、array、函数等，都应该使用 useMemo。以确保当值相同时，引用不发生变化。hooks 常用 APIuseCallback：返回一个记忆函数，缓存了每次渲染时那些回调函数的实例，可以配合 React.memo 起到减少不必要的渲染的作用useMemo：返回一个记忆值，传递一个工厂函数和数组。useMemo 只会在数组其中一个输入发生更改时重新调用工厂函数去计算这个值。此优化有助于避免在每个渲染上进行高开销的计算。useRef：useRef 返回一个可变的 ref 对象，其 current 属性被初始化为传递的参数。返回的对象将存留在整个组件的生命周期中。useRef 在 react hook 中的作用, 正如官网说的，像一个变量，类似于 this，可以存放任何东西，createRef 每次渲染都会返回一个新的引用，而 useRef 每次都会返回相同的引用useImperativeHandle：自定义使用 ref 时公开给父组件的实例值，往往与 forwardRef 一起使用useLayoutEffect：签名与 useEffect 相同，但在所有 DOM 变化后同步触发Hook 使用规则和注意约定以 use 开头并且紧跟大写字母（因为约定的力量在于：我们不用细看实现，也能通过命名来了解一个它是什么）只在最顶层使用 Hook，不要在循环，条件或嵌套函数中调用 Hook，能确保 Hook 在每一次渲染中都按照同样的顺序被调用只在 React 函数中调用 Hook，不要在普通的 JavaScript 函数中调用 Hook，确保组件的状态逻辑在代码中清晰可见（eslint 通过判断一个方法是不是大坨峰命名来判断它是否是 React 函数）自定义 hooks一种自然遵循 Hook 设计的约定，而并不是 React 的特性必须以 “use” 开头，不遵循的话，由于无法判断某个函数是否包含对其内部 Hook 的调用，React 将无法自动检查你的 Hook 是否违反了 Hook 的使用规则在两个组件中使用相同的 Hook 不会共享 state，自定义 Hook 是一种重用状态逻辑的机制，所以每次使用自定义 Hook 时，其中的所有 state 和副作用都是完全隔离的useEffect 为什么不能传入异步函数理由是 effect function 应该返回一个销毁函数，如果 useEffect 第一个参数传入 async，返回值则变成了 Promise，会导致 react 在调用销毁函数的时候报错：function.apply is undefined为什么这样设计：useEffect 的返回值是要在卸载组件时调用的，React 需要在 mount 的时候马上拿到这个值，不能有延迟解决：使用 IIFE 或者声明异步函数再执行，推荐使用 IIFE 写法，因为声明的异步函数可能有外部依赖无法及时更新useEffect(() =&gt; {  (async () =&gt; {    const res = await fetch(SOME_API);    setValue(res.data);  })();}, []);编写自定义 hook useAsyncEffect// 自定义hookfunction useAsyncEffect(effect: () =&gt; Promise&lt;void | (() =&gt; void)&gt;, dependencies?: any[]) {  return useEffect(() =&gt; {    const cleanupPromise = effect();    return () =&gt; {      cleanupPromise.then((cleanup) =&gt; cleanup &amp;&amp; cleanup());    };  }, dependencies);}// 使用useAsyncEffect(async () =&gt; {  const count = await fetchData();  setCount(count);}, [fetchData]);useEffect 实现防抖useEffect(() =&gt; {  const timer = setTimeout(async () =&gt; {    await fetchData(deps);  }, 500);  return () =&gt; clearTimeout(timer);}, [deps]);不能直接向 useEffect 传递防抖函数，因为 useEffect 常依赖 props 或者 useState 返回的值，当两种值改变后，都会触发 Function 组件重新渲染，那么 useEffect 又会重新执行一遍，生成一个新的防抖后的函数参考https://overreacted.io/zh-hans/a-complete-guide-to-useeffect/"},{"id":"485cea1b6ac19a7c73c2a1af2256306a","isRootIndexFile":false,"isIndexFile":true,"filename":"index.md","basename":"React","path":"/home/runner/work/qxtang.github.io/qxtang.github.io/前端/框架/React","content":"ReactAPIRefs安全访问 DOM 或某个组件实例不得不直接访问时才使用，否则容易造成混乱useRef 还可以用来保存多帧共享的数据Context当不想在组件树中通过逐层传递 props 或者 state 的方式来传递数据时，可以使用 Context 来实现跨层级的组件数据传递React.createContext：创建一个上下文的容器（组件），defaultValue 可以设置共享的默认数据Provider（生产者）：用于生产共享数据Consumer（消费者）：专门消费 Provider 的数据。Consumer 需要嵌套在生产者下面，才能通过回调的方式拿到共享的数据，当然也可以单独使用，那就只能消费到上文提到的 defaultValue其他React.PureComponent：与 React.Component 完全相同，但是在 shouldComponentUpdate 中实现了 props 和 state 的浅比较，可以提高性能React.memo：高阶组件，与 React.PureComponent 类似，用于包裹函数组件，通过记忆结果来提高性能React.createRef：创建一个 ref，它可以通过 ref 属性附加到 React 元素React.forwardRef：创建一个 React 组件，将它接收的 ref 属性转发给组件树中的另一个组件。接受渲染函数作为参数。React 将用 props 和 ref 作为两个参数来调用这个函数。此函数应返回 React 节点React.lazy：定义动态加载的组件。有助于减少包大小，用来延迟加载在初始渲染期间未使用的组件，要求被&lt;React.Suspense&gt;组件包裹。这是指定加载指示器的方式React.Suspense：指定加载指示器createPortal：将子节点渲染到父组件以外的 DOM 节点PureComponent 缺点：PureComponent 创建了默认的 shouldComponentUpdate 行为，这个默认的 shouldComponentUpdate 行为会一一比较 props 和 state 中所有的属性，只有当其中任意一项发生改变是，才会进行重绘PureComponent 使用浅比较判断组件是否需要重绘，即比较指针的异同所以如果 props 和 state 是引用对象，比如对象、数组，修改属性或元素，不会导致重绘异步加载示例：const Box = React.lazy(() =&gt; import(&#x27;./components/Box&#x27;));&lt;Suspense fallback={&lt;div&gt;loading...&lt;/div&gt;}&gt;{show &amp;&amp; &lt;Box /&gt;}&lt;/Suspense&gt;;import()：es2020 的规范import() 表达式加载模块并返回一个 promise，该 promise resolve 为一个包含其所有导出的模块。我们可以在代码中的任意位置调用这个表达式webpack 碰到之后会将其拆出来成一个 chunk，可以使用魔术注释自定义 chunk 名称，需要加载时会通过异步请求来加载这个 chunk对应的 babel 语法插件：babel-plugin-syntax-dynamic-import异常处理设置边界包裹组件，实现 componentDidCatch为什么不要在 render 中声明组件每次渲染都会声明的一个新的组件，组件的一些非受控状态就会丢失，比如聚焦状态，浏览器选中文字状态实现组件之间代码重用，为什么推荐组合、HOC，而不是继承React 希望组件是按照最小可用思想来进行封装，一个组件只做一件事情，符合单一职责原则函数式编程中，函数组合是组合两个或多个函数以产生新函数的过程。将函数组合在一起就像将一系列管道拼接在一起，让我们的数据流过生命周期1、挂载卸载过程constructor()：必须写 super(),否则会导致 this 指向错误componentWillMount()：即将过时不要使用componentDidMount()：dom 节点已经生成，可以在这里调用 ajax 请求componentWillUnmount()：在这里移除事件订阅和定时器2、更新过程componentWillReceiveProps(nextProps)：即将过时不要使用，接受父组件改变后的 props 需要重新渲染shouldComponentUpdate(nextProps,nextState)：性能优化componentWillUpdate(nextProps,nextState)：即将过时不要使用componentDidUpdate(prevProps,prevState)render()：插入 jsx 生成的 dom 结构，diff 算法比较更新前后的新旧 DOM 树，找到最小的有差异的节点，重新渲染在 Fiber 中，reconciliation 阶段进行了任务分割，涉及到 暂停 和 重启，因此可能会导致 reconciliation 中的生命周期函数在一次更新渲染循环中被 多次调用 的情况，产生一些意外错误新版的建议生命周期如下：class Component extends React.Component {  // 替换 `componentWillReceiveProps`  // 初始化和 update 时被调用  // 静态函数，无法使用 this  static getDerivedStateFromProps(nextProps, prevState) {}  // 判断是否需要更新组件  // 可以用于组件性能优化  shouldComponentUpdate(nextProps, nextState) {}  // 组件被挂载后触发  componentDidMount() {}  // 替换  componentWillUpdate;  // 可以在更新之前获取最新 dom 数据  getSnapshotBeforeUpdate() {}  // 组件更新后调用  componentDidUpdate() {}  // 组件即将销毁  componentWillUnmount() {}  // 组件已销毁  componentDidUnmount() {}}生命周期使用建议：在 constructor 初始化 state在 componentDidMount 中进行事件监听，并在 componentWillUnmount 中解绑事件在 componentDidMount 中进行数据的请求，而不是在 componentWillMount需要根据 props 更新 state 时，使用 getDerivedStateFromProps(nextProps, prevState)可以在 componentDidUpdate 监听 props 或者 state 的变化在 componentDidUpdate 使用 setState 时，必须加条件，否则会死循环getSnapshotBeforeUpdate(prevProps, prevState) 可以在更新之前获取最新的渲染数据，它的调用是在 render 之后，update 之前shouldComponentUpdate: 默认每次调用 setState，一定会最终走到 diff 阶段，但可以通过 shouldComponentUpdate 的生命钩子返回 false 来直接阻止后面的逻辑执行，通常是用于做条件渲染，优化渲染的性能react 性能优化是哪个周期函数shouldComponentUpdate用来判断是否需要调用 render 方法重新描绘 dom因为 dom 的描绘比较消耗性能如果能在 shouldComponentUpdate 方法中能够写出更优化的逻辑，可以提高性能事件处理React 没有直接将事件绑定到元素上，而是在 document 处监听所有支持的事件冒泡到 document 上的事件不是原生浏览器事件，而是 React 自己实现的合成事件为了解决跨浏览器兼容性问题，React 将 浏览器原生事件 封装为 合成事件提供了与原生事件相同的接口，屏蔽了底层浏览器的细节差异，保证了行为一致性这样 React 在更新 DOM 的时候不需要考虑如何去处理绑定在 DOM 上的事件监听器，达到优化性能目的react 合成事件是什么，和原生事件的区别React 合成事件机制，React 并不是将 click 事件直接绑定在 dom 上面，而是采用事件冒泡的形式冒泡到 document 上面，然后 React 将事件封装给正式的函数如果 DOM 上绑定了过多的事件处理函数，页面响应以及内存占用可能会受影响为了避免这类 DOM 事件滥用，同时屏蔽底层不同浏览器之间的事件系统差异，React 实现了一个中间层当用户在为 onClick 添加函数时，React 并没有将 Click 事件绑定在 DOM 元素上，而是在 document 处监听所有支持的事件，当事件发生并冒泡至 document 处时，React 将事件内容封装交给中间层constructor 中 super 与 props 参数一起使用的目的是什么ES6 规定，在子类的 constructor 中必须先调用 super 初始化父类才能引用 this在调用方法之前，子类构造函数无法使用 this 引用 super()为什么一定要 import “react”JSX 实际上是 React.createElement 的语法糖，jsx 会被 babel 翻译成 React.createElementreact 性能优化重写 shouldComponentUpdate 来避免不必要的 dom 操作使用 production 版本的 react.js使用 key 来帮助 React 识别列表中所有子组件的最小变化React.memoPureComponentuseMemo、useCallbackReact 编程模型宿主树用于展示 UI会随时间变化稳定性，宿主树相对稳定通用性，宿主树可以被拆分为外观和行为一致的 UI 模式宿主实例宿主树的节点渲染器渲染器决定如何与特定的宿主环境通信以及如何管理它的宿主实例让开发者能以一种更好的方式操控宿主实例，而不用在意低级视图 API 范例React 元素最小的构建单元一个普通的 JavaScript 对象，用来描述一个宿主实例React 元素也能形成一棵树React 元素并不是永远存在的，它们总是在重建和删除之间不断循环React 元素具有不可变性。不能改变 React 元素中的子元素或者属性，如果想要在稍后渲染一些不同的东西，需要从头创建新的 React 元素树来描述它类似电影中放映的每一帧入口告诉 React ，将特定的 React 元素树渲染到真正的宿主实例中去，例如，React DOM 的入口就是 ReactDOM.render()组件即返回 React 元素的函数一致性React 将所有的工作分成了“渲染阶段”和“提交阶段”。渲染阶段是当 React 调用你的组件然后进行协调的时段，在此阶段进行干涉是安全的，提交阶段就是 React 操作宿主树的时候，而这个阶段永远是同步的批量更新React 会在组件内所有事件触发完成后再进行批量更新，避免浪费的重复渲染上下文事实上，当 React 渲染时，维护了一个上下文栈副作用React 会推迟执行 effect 直到浏览器重新绘制屏幕有一个极少使用的 Hook 能够让你选择退出这种行为并进行一些同步的工作，请尽量避免使用它：useLayoutEffect自定义 Hooks自定义 Hooks 让不同的组件共享可重用的状态逻辑。注意状态本身是不共享的。每次调用 Hook 都只声明了其自身的独立状态。渲染器react-dom、react-dom/server、 react-native、 react-test-renderer 都是常见的渲染器不管你的目标平台是什么，react 包都是可用的，从 react 包中导出的一切，比如 React.Component、React.createElement、 React.Children 和 Hooks，都是独立于目标平台的渲染器包则暴露特定平台的 API，例如 ReactDOM.render()react 包仅仅是让你使用 React 的特性，但是它不知道这些特性是如何实现的。渲染器包(react-dom、react-native 等)提供了 React 特性的实现以及平台特定的逻辑每个渲染器都在已创建的类上设置了一个特殊的字段，这个字段叫做 updater"},{"id":"db3202f3a00c9c196b8dac24ed8817cc","isRootIndexFile":false,"isIndexFile":false,"filename":"react-router.md","basename":"react-router","path":"/home/runner/work/qxtang.github.io/qxtang.github.io/前端/框架/React","content":"react-routerLink 组件和 a 标签区别Link 做了 3 件事情：有 onclick 就执行 onclickclick 的时候阻止 a 标签默认事件、不会跳转和刷新页面否则取得跳转 href（to 属性），执行跳转，此时只是链接变了，并没有刷新页面switch 标签作用有 switch 标签包裹，则其中的在路径相同的情况下，只匹配第一个，这个可以避免重复匹配无 switch 标签包裹，则其中的在路径相同的情况下全都会匹配。更严重的是，还会匹配上级路径withRouter 作用让被修饰的组件可以从属性中获取 history、location、match路由组件可以直接获取这些属性，而非路由组件就必须通过 withRouter 修饰后才能获取这些属性"},{"id":"8c08d295f7d0117ca839b801e201ed9f","isRootIndexFile":false,"isIndexFile":false,"filename":"setState.md","basename":"setState","path":"/home/runner/work/qxtang.github.io/qxtang.github.io/前端/框架/React","content":"setState为什么不要在 render 中 setState？setState 会触发 render，造成死循环setState 如何深合并方法一：使用展开运算符方法二：先直接赋值，最后再调一次 setState({})setState 执行过程将传递给 setState 的对象合并到组件的当前状态构建一个新的虚拟 dom将新树与旧树比较，计算出新旧树的节点差异，确定需要更新的真实 dom调用 render 方法更新 UIsetState 同步还是异步与调用时的环境相关在 合成事件 和 生命周期钩子中，setState 是异步的，会把多次调用进行合并，如果需要马上同步去获取新值，setState 可以传入第二个参数，在回调中即可获取最新值在 原生事件 和 setTimeout、setInterval、promise 等异步操作中，setState 是同步的，可以马上获取更新后的值，原因: 原生事件是浏览器本身的实现，与事务流无关，而 setTimeout 是放置于定时器线程中延后执行，此时事务流已结束，因此也是同步原因：在 React 的 setState 函数实现中，会根据一个变量 isBatchingUpdates 判断是直接更新 this.state 还是放到队列中回头再说，而 isBatchingUpdates 默认是 false，也就表示 setState 会同步更新 this.state但是，有一个函数 batchedUpdates，这个函数会把 isBatchingUpdates 修改为 true，而当 React 在调用事件处理函数之前就会调用这个 batchedUpdates就是由 React 控制的事件处理过程 setState 不会同步更新 this.statesetState 在 react 生命周期和合成事件会批量覆盖执行当遇到多个 setState 调用的时候会提取单次传递 setState 对象，将它们进行合并（类似 Object.assign，遇到相同 key 会覆盖前面的 key）合成事件：react 为了解决跨平台，兼容性问题，自己封装了一套事件机制，代理了原生的事件，像在 jsx 中常见的 onClick、onChange批量更新机制在 合成事件 和 生命周期钩子 中，setState 更新队列时，存储的是合并状态(Object.assign)。因此前面设置的 key 值会被后面所覆盖，最终只会执行一次更新setState 函数型式由于 Fiber 及 合并 的问题，官方推荐可以传入 函数 的形式。setState(fn)，在 fn 中返回新的 state 对象即可，例如 this.setState((state, props) =&gt; newState)；使用函数型式，可以用于避免 setState 的批量更新的逻辑，传入的函数将会被 顺序调用setState 合并，在 合成事件 和 生命周期钩子 中多次连续调用会被优化为一次当组件已被销毁，如果再次调用 setState，React 会报错警告，通常有两种解决办法：将数据挂载到外部，通过 props 传入，如放到 Redux 或 父级中在组件内部维护一个状态量 (isUnmounted)，componentWillUnmount 中标记为 true，在 setState 前进行判断"},{"id":"cac3b3ec2a3a2b1dce70bc6254cb598d","isRootIndexFile":false,"isIndexFile":false,"filename":"渲染原理.md","basename":"渲染原理","path":"/home/runner/work/qxtang.github.io/qxtang.github.io/前端/框架/React","content":"渲染原理待完善协调（Reconciler）过程当根节点为不同类型的元素时，React 会拆卸原有树并建立新树当对比两个相同类型的 React 元素时，React 会保留 DOM 节点，仅比对及更新有改变的属性当一个组件更新时，组件实例会保持不变，因此可以在不同的帧保持 state 一致。React 将更新该组件实例的 props 以保证与最新的元素保持一致，并且调用该实例的 componentWillReceiveProps()、componentWillUpdate()、componentDidUpdate()当子元素拥有 key 时，React 使用 key 来匹配原有树上的子元素以及最新树上的子元素，使得树的转换效率得以提高Key 应该具有稳定，可预测，以及列表内唯一的特质，不稳定的 key（比如通过 Math.random() 生成的）会导致许多组件实例和 DOM 节点被不必要地重新创建，这可能导致性能下降和子组件中的状态丢失也可以使用元素在数组中的下标作为 key。这个策略在元素不进行重新排序时比较合适，如果有顺序修改，diff 就会变慢"}]},{"id":"8aeb97fee6d70890883e5d21f0a70284","dirname":"Vue","filename":"","basename":"","path":"/home/runner/work/qxtang.github.io/qxtang.github.io/前端/框架","children":[{"id":"95d6870156f47122d0948684e216b600","isRootIndexFile":false,"isIndexFile":true,"filename":"index.md","basename":"Vue","path":"/home/runner/work/qxtang.github.io/qxtang.github.io/前端/框架/Vue","content":"Vue参考https://www.cnblogs.com/canfoo/p/6891868.htmlVue 生命周期beforeCreatecreatedbeforeMountmounted：dom 加载完毕，可以进行 ajax 请求和 dom 操作beforeUpdateupdatedbeforeDestroydestroyed组件通信方式props / $emit 适用 父子组件通信parent / children 适用 父子组件通信事件总线 EventBusvuex 状态管理库vue2 如何监测数组变化使用了函数劫持的方式，重写数组的方法，将 data 中的数组进行了原型链重写，指向了自己定义的数组原型方法当调用数组 api 时，可以通知依赖更新。如果数组中包含着引用类型，会对数组中的引用类型再次递归遍历进行监控为什么 vue 实例的 data 属性必须是一个函数js 中，对象为引用类型由于数据对象都指向同一个 data 对象，在一个组件中修改 data 时，其他重用的组件中的 data 会同时被修改使用返回对象的函数，每次都创建一个新对象，引用地址不同，则不会出现这个问题nextTick用于在下次 DOM 更新循环结束之后执行延迟回调在修改数据之后立即使用这个方法，获取更新后的 DOM理解：nextTick，是将回调函数延迟在下一次 dom 更新数据后调用，简单的理解是：当数据更新了，在 dom 中渲染后，自动执行该函数。什么时候用：created 生命周期中进行的 DOM 操作，要放在 nextTick 的回调函数中想在改变 DOM 元素的数据后，基于新的 dom 做点什么，对新 dom 一系列操作都需要放进 nextTick 回调函数中在使用某个第三方插件时，希望在 vue 生成的某些 dom 动态发生变化时重新应用该插件，比如 swipebox 插件实现原理：使用了宏任务和微任务。根据执行环境分别尝试采用 Promise、MutationObserver、setImmediate，如果以上都不行则采用 setTimeout 定义了一个异步方法，多次调用 nextTick 会将方法存入队列中，通过这个异步方法清空当前队列v-if 和 v-show 的区别v-if：动态向 DOM 树内添加或者删除 DOM 元素v-show：通过设置 DOM 元素的 display 样式属性控制显隐Vue 事件绑定原理原生事件绑定是通过 addEventListener 绑定给真实元素的，组件事件绑定是通过 Vue 自定义的 $on 实现的Vue 模版编译原理Vue 的编译过程就是将 template 转化为 render 函数的过程。会经历以下阶段：生成 AST 树：首先解析模版，生成 AST 语法树，使用大量的正则表达式对模板进行解析，遇到标签、文本的时候都会执行对应的钩子进行相关处理优化：Vue 的数据是响应式的，但模板中并不是所有的数据都是响应式的。有一些数据首次渲染后就不会再变化，对应的 DOM 也不会变化。优化过程就是深度遍历 AST 树，按照相关条件对树节点进行标记。这些被标记的节点(静态节点)我们就可以跳过对它们的比对codegen：将优化后的 AST 树转换为可执行的代码keep-alive可以实现组件缓存，当组件切换时不会对当前组件进行卸载常用的两个属性 include/exclude，允许组件有条件的进行缓存两个生命周期 activated/deactivated，用来得知当前组件是否处于活跃状态原理：Vue.js 内部将 DOM 节点抽象成了一个个的 VNode 节点，keep-alive 组件的缓存也是基于 VNode 节点的而不是直接存储 DOM 结构。它将满足条件的组件在一个对象中缓存起来，在需要重新渲染的时候再将 vnode 节点从 cache 对象中取出并渲染Vue 性能优化尽量减少 data 中的数据，data 中的数据会增加 getter 和 setter，会收集对应的 watcherv-if 和 v-for 不能连用：v-for 的优先级比 v-if 更高，这意味着 v-if 将分别重复运行于每个 v-for 循环中。如果要遍历的数组很大，而真正要展示的数据很少时，这将造成很大的性能浪费如果需要使用 v-for 给每项元素绑定事件时使用事件代理使用 keep-alive如果可以，使用 v-if 替代 v-showkey 保证唯一使用路由懒加载、异步组件第三方模块按需引入vue3 新特性基于 Proxy 的观察者机制：目前，Vue2 实现双向绑定是使用 Object.defineProperty 的 getter 和 setter。但是，Vue3 使用 ES2015 Proxy 作为其观察者机制。消除了以前存在的警告，使速度加倍，节省了一半的内存开销更好的支持 TS 和 JSXvuex核心组件state 全局唯一数据源getters 类似过滤器和计算属性，从 store 中的 state 中派生出一些状态mutations 更改 store 中的状态的唯一方法是提交 mutation，类似 redux 里的 reducer，同步任务actions 类似 redux 里的异步 reducer，可以执行异步任务modules 模块，使用单一状态树，应用的所有状态会集中到一个比较大的对象，变得复杂、臃肿。Vuex 允许我们将 store 分割成模块Vuex 中状态储存在哪里，怎么改变它？存储在 state 中，改变 Vuex 中的状态的唯一途径就是提交 (commit) mutationVuex 中状态是对象时，使用时要注意什么？因为对象是引用类型，复制后改变属性还是会影响原始数据，这样会改变 state 里面的状态，是不允许，所以先用深度克隆复制对象，再修改vue2 的缺陷数组的部分操作没有响应式：push(), pop(), shift(), unshift(), splice(), sort(), reverse()vue2 通过 Object.defineProperty 实现响应式，无法检测数组/对象属性的新增，不允许在已经创建的实例上动态添加新的响应式属性解决方案：Vue.set()Object.assign()$forcecUpdated()"},{"id":"4abb31899a22a33e22199a247688c032","isRootIndexFile":false,"isIndexFile":false,"filename":"vue 中的 diff 算法.md","basename":"vue 中的 diff 算法","path":"/home/runner/work/qxtang.github.io/qxtang.github.io/前端/框架/Vue","content":"vue 中的 diff 算法diff 的过程就是调用名为 patch 的函数，比较新旧节点，一边比较一边给真实的 DOM 打补丁diff 的比较方式比较新旧节点的时候，比较只会在同层级进行，不会跨层级比较diff 流程当数据发生改变时，set 方法会调用 Dep.notify 通知所有订阅者（Watcher），订阅者就会调用 patch 给真实的 DOM 打补丁，更新相应的视图patch 函数核心实现function patch(oldVnode, vnode) {  // 判断两节点是否值得比较  if (sameVnode(oldVnode, vnode)) {    patchVnode(oldVnode, vnode);  } else {    // 不值得比较则用 Vnode 替换 oldVnode    const oEl = oldVnode.el; // 当前 oldVnode 对应的真实元素节点    let parentEle = api.parentNode(oEl); // 父元素    createEle(vnode); // 根据 Vnode 生成新元素    if (parentEle !== null) {      api.insertBefore(parentEle, vnode.el, api.nextSibling(oEl)); // 将新元素添加进父元素      api.removeChild(parentEle, oldVnode.el); // 移除以前的旧元素节点      oldVnode = null;    }  }  return vnode;}// 判断两节点是否值得比较方法function sameVnode(a, b) {  return (    a.key === b.key &amp;&amp; // key 值    a.tag === b.tag &amp;&amp; // 标签名    a.isComment === b.isComment &amp;&amp; // 是否为注释节点    // 是否都定义了 data，data 包含一些具体信息，例如 onclick，style    isDef(a.data) === isDef(b.data) &amp;&amp;    sameInputType(a, b) // 当标签是 &lt;input&gt; 的时候，type 必须相同  );}/*- 值得比较，调用 patchVnode- 找到对应的真实 dom，称为 el- 判断 Vnode 和 oldVnode 是否指向同一个对象，如果是，那么直接 return- 如果他们都有文本节点并且不相等，那么将 el 的文本节点设置为 Vnode 的文本节点- 如果 oldVnode 有子节点而 Vnode 没有，则删除 el 的子节点- 如果 oldVnode 没有子节点而 Vnode 有，则将 Vnode 的子节点真实化之后添加到 el- 如果两者都有子节点，则执行 updateChildren 函数比较子节点，这一步很重要*/function patchVnode(oldVnode, vnode) {  const el = (vnode.el = oldVnode.el);  let i,    oldCh = oldVnode.children,    ch = vnode.children;  if (oldVnode === vnode) return;  if (oldVnode.text !== null &amp;&amp; vnode.text !== null &amp;&amp; oldVnode.text !== vnode.text) {    api.setTextContent(el, vnode.text);  } else {    updateEle(el, vnode, oldVnode);    if (oldCh &amp;&amp; ch &amp;&amp; oldCh !== ch) {      updateChildren(el, oldCh, ch);    } else if (ch) {      createEle(vnode); //create el&#x27;s children dom    } else if (oldCh) {      api.removeChildren(el);    }  }}/* - 将 Vnode 的子节点 Vch 和 oldVnode 的子节点 oldCh 提取出来- oldCh 和 vCh 各有两个头尾的变量 StartIdx 和 EndIdx，它们的 2 个变量相互比较，一共有 4 种比较方式。如果 4 种比较都没匹配，如果设置了 key，就会用 key 进行比较，在比较的过程中，变量会往中间靠，一旦 StartIdx &gt; EndIdx 表明 oldCh 和 vCh 至少有一个已经遍历完了，就会结束比较*/function updateChildren(parentElm, oldCh, newCh) {  let oldStartIdx = 0,    newStartIdx = 0;  let oldEndIdx = oldCh.length - 1;  let oldStartVnode = oldCh[0];  let oldEndVnode = oldCh[oldEndIdx];  let newEndIdx = newCh.length - 1;  let newStartVnode = newCh[0];  let newEndVnode = newCh[newEndIdx];  let oldKeyToIdx;  let idxInOld;  let elmToMove;  let before;  while (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) {    if (oldStartVnode == null) {      // 对于 vnode.key 的比较，会把 oldVnode = null      oldStartVnode = oldCh[++oldStartIdx];    } else if (oldEndVnode == null) {      oldEndVnode = oldCh[--oldEndIdx];    } else if (newStartVnode == null) {      newStartVnode = newCh[++newStartIdx];    } else if (newEndVnode == null) {      newEndVnode = newCh[--newEndIdx];    } else if (sameVnode(oldStartVnode, newStartVnode)) {      patchVnode(oldStartVnode, newStartVnode);      oldStartVnode = oldCh[++oldStartIdx];      newStartVnode = newCh[++newStartIdx];    } else if (sameVnode(oldEndVnode, newEndVnode)) {      patchVnode(oldEndVnode, newEndVnode);      oldEndVnode = oldCh[--oldEndIdx];      newEndVnode = newCh[--newEndIdx];    } else if (sameVnode(oldStartVnode, newEndVnode)) {      patchVnode(oldStartVnode, newEndVnode);      api.insertBefore(parentElm, oldStartVnode.el, api.nextSibling(oldEndVnode.el));      oldStartVnode = oldCh[++oldStartIdx];      newEndVnode = newCh[--newEndIdx];    } else if (sameVnode(oldEndVnode, newStartVnode)) {      patchVnode(oldEndVnode, newStartVnode);      api.insertBefore(parentElm, oldEndVnode.el, oldStartVnode.el);      oldEndVnode = oldCh[--oldEndIdx];      newStartVnode = newCh[++newStartIdx];    } else {      // 使用 key 时的比较      if (oldKeyToIdx === undefined) {        oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx); // 有 key 生成 index 表      }      idxInOld = oldKeyToIdx[newStartVnode.key];      if (!idxInOld) {        api.insertBefore(parentElm, createEle(newStartVnode).el, oldStartVnode.el);        newStartVnode = newCh[++newStartIdx];      } else {        elmToMove = oldCh[idxInOld];        if (elmToMove.sel !== newStartVnode.sel) {          api.insertBefore(parentElm, createEle(newStartVnode).el, oldStartVnode.el);        } else {          patchVnode(elmToMove, newStartVnode);          oldCh[idxInOld] = null;          api.insertBefore(parentElm, elmToMove.el, oldStartVnode.el);        }        newStartVnode = newCh[++newStartIdx];      }    }  }  if (oldStartIdx &gt; oldEndIdx) {    before = newCh[newEndIdx + 1] == null ? null : newCh[newEndIdx + 1].el;    addVnodes(parentElm, before, newCh, newStartIdx, newEndIdx);  } else if (newStartIdx &gt; newEndIdx) {    removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);  }}参考https://juejin.cn/post/6844903607913938951"},{"id":"7eb52050103fb5b795d44d524cea73f0","isRootIndexFile":false,"isIndexFile":false,"filename":"双向绑定原理.md","basename":"双向绑定原理","path":"/home/runner/work/qxtang.github.io/qxtang.github.io/前端/框架/Vue","content":"双向绑定原理数据劫持 + 发布-订阅模式，用 Object.defineProperty 监听对象各个属性的 setter，getter属性变动时发布消息给订阅者，订阅者收到属性的变化通知并执行相应的更新视图的函数Vue3.x 改用 Proxy 替代 Object.definePropertyProxy 可以直接监听对象和数组的变化，可以代理动态增加的属性，不需要深度遍历监听，并且作为新标准将受到浏览器厂商重点持续的性能优化Object.definePorperty 缺点：Object.definePorperty 递归遍历对象的所有属性，当层级较深时，会造成性能影响Object.definePorperty 只能作用在对象上，不能作用在数组上，通过数组下标添加元素，不能实时响应，vue2 通过重写数组方法原型的方式对数组数据进行监听，但是仍然无法监听数组索引的变化和长度的变更Object.definePorperty 只能监听定义时的属性，不能监听新增属性Proxy 只会代理对象的第一层，Vue3 怎样处理这个问题判断当前 Reflect.get 的返回值是否为 Object，如果是则再通过 reactive 方法做代理， 这样就实现了深度观测"},{"id":"8068010ae6cd28d82c2f8e7d5fb05994","isRootIndexFile":false,"isIndexFile":false,"filename":"渲染原理.md","basename":"渲染原理","path":"/home/runner/work/qxtang.github.io/qxtang.github.io/前端/框架/Vue","content":"渲染原理待完善"}]},{"id":"e91730aadcf9c6b7a887ab67ec20254a","isRootIndexFile":false,"isIndexFile":false,"filename":"HOC、Hooks、Mixin.md","basename":"HOC、Hooks、Mixin","path":"/home/runner/work/qxtang.github.io/qxtang.github.io/前端/框架","content":"HOC、Hooks、Mixin三种实现状态逻辑复用的技术Mixinmixin 缺点会相互依赖，相互耦合，不利于代码维护方法可能会相互冲突，难以追溯React 现在已经不再推荐使用 MixinHOC高阶组件就是一个函数，且该函数接受一个组件作为参数，并返回一个新的增强组件高阶组件自身不是 React API 的一部分，它是一种基于 React 的组合特性而形成的设计模式和编程技巧常见的有 react-redux 里的 connect 和 react-router 中的 withRouter作用：复用组件逻辑，操作状态和参数，渲染劫持HOC 缺点：嵌套地狱：可能出现多层包裹组件的情况，多层抽象同样增加了复杂度和理解成本命名冲突：如果高阶组件多次嵌套，没有使用命名空间的话会产生冲突，然后覆盖老属性HOC 场景和应用权限控制性能监控，包裹组件的生命周期，进行统一埋点日志打点双向绑定组合渲染、条件渲染可以借助 ES7 提供的 Decorators （装饰器）来让写法变得优雅，安装并配置 babel 插件：babel-plugin-transform-decorators-legacy使用注意：不要在 render 方法内创建高阶组件，会导致组件每次都会被卸载后重新挂载不要改变原始组件，高阶组件应该是没有副作用的纯函数，这样破坏了对高阶组件的约定，也改变了高阶组件的初衷，使用高阶组件是为了增强而非改变Hooks 缺点写法上有限制（不能出现在条件、循环中）破坏了 PureComponent、React.memo 浅比较的性能优化效果（为了取最新的 props 和 state，每次 render 都要重新创建事件处函数）在闭包场景可能会引用到旧的 state、props 值React.memo 并不能完全替代 shouldComponentUpdate（因为拿不到 state change，只针对 props change）useState 使用一个元组来返回 value 和 setter，需要输入两次相同的名称来定义一个 state，导致代码看起来很长且笨重参考https://juejin.cn/post/6844903815762673671"},{"id":"06525a63badbb76964788818cc2aa132","isRootIndexFile":false,"isIndexFile":false,"filename":"Redux.md","basename":"Redux","path":"/home/runner/work/qxtang.github.io/qxtang.github.io/前端/框架","content":"Redux一个数据管理中心，可以保证数据健壮性、可追溯和可预测性与 React 无关，独立运行于任何 JavaScript 环境整个应用只有唯一的状态树，所有状态维护在一个 Store 中规定只能通过一个纯函数（Reducer）来描述修改核心组件Store：整个程序的状态/对象树保存在 Store 中，一个工程只有一个 store。具有以下方法供使用：getState 获取 statedispatch 触发 action，更新 statesubscribe 订阅数据变更，注册监听器State：数据Action：用来描述发生了什么事情的对象。作为一个行为载体，用于映射相应的 Reducer，可以成为数据的载体，将数据从应用传递至 store 中，是 store 唯一的数据源Action CreatorReducer：确定状态将如何变化的地方。描述如何修改数据的纯函数，Action 属于行为名称，而 Reducer 便是修改行为的实质定义 ActionReact 中的 Action 必须具有 type 属性该属性指示正在执行的类型必须将它们定义为字符串常量，并且还可以向其添加更多的属性Reducer 的作用纯函数，规定应用程序的状态怎样因响应 action 而改变通过接受先前的状态和 action 来工作，返回一个新的状态它根据操作的类型确定需要执行哪种更新，然后返回新的值如果不需要完成任务，会返回原来的状态为什么 reducer 中不能做异步操作（为什么是纯函数）使用纯函数才能保证相同输入得到相同输出，保证状态的可预测，如果有副作用，那么返回的 state 就不确定redux 的设计思想就是不产生副作用，数据更改的状态可回溯，所以 redux 中处处都是纯函数React-ReduxProvider: 从最外部封装了整个应用，将 store 通过 context 传入组件中connect：一个高阶组件，负责连接 React 和 Redux，可以方便在 React 组件中使用 Redux异步 Action 方案使用 redux-thunk、redux-saga、dva 等工具redux-thunk 在一个 action 中返回一个函数执行异步操作，异步操作结束后，再去 dispatch 另一个 actionredux-saga：generator 风格dva：基于 redux-saga源码实现创建一个状态中心（state），通过纯函数来对状态中心的数据进行修改，然后将修改后的结果以发布订阅的方式通知到所有订阅者，从而达到一个共享状态的效果Redux 的核心是函数式编程，使用无副作用的同步函数 action 来触发 reducer 对数据进行修改Redux 的创建函数是 createStore，这个函数的作用是创建一个 store 对象，其中关键步骤是将 reducer 利用闭包存储在函数内导出了 subscribe 函数，subscribe 函数内部将订阅者添加到一个订阅者列表中，等待通知导出了 dispatch 函数，在 dispatch 内部执行了 reducer 函数，并将 action 作为参数传入到 reducer 中将 reducer 函数的返回结果（新的 state）存在 currentState 中，同时通知所有的订阅者 state 已经更新订阅者可以通过 getState 得到最新的 stateRedux 中间件的原理就是 Decorator 装饰器模式，将中间件经过一些装饰器（中间件）装饰以后，返回一个增强型的 dispatchconnect 实现获取 state: connect 通过 context 获取 Provider 中的 store，通过 store.getState 获取整个 store tree 上所有 state将 state 和 action 通过 props 的方式传入到原组件内部，wrapWithConnect 返回一个 ReactComponent 对象 Connect，Connect 重新 render 外部传入的原组件 WrappedComponent，并把 connect 中传入的 mapStateToProps, mapDispatchToProps 与组件上原有的 props 合并后，通过属性的方式传给 WrappedComponent监听 store tree 变化：connect 缓存了 store tree 中 state 的状态，通过当前 state 状态和变更前 state 状态进行比较，从而确定是否调用 this.setState 触发 Connect 及其子组件的重新渲染const connect = (mapStatetoProps, mapActionstoProps) =&gt; (WrapperComponent) =&gt; {  return class Connect extends Component {    static contextType = storeContext; // provide 定义的 context 对象    constructor(props) {      super();    }    componentWillMount() {      const store = this.context;      store.subscribe(this._updateProps);      this._updateProps(); // 初始化    }    _updateProps = () =&gt; {      const store = this.context;      // 传入state和props      const stateProps = mapStatetoProps ? mapStatetoProps(store.getState(), this.props) : {};      // 传入dispatch和props      const actionProps = mapActionstoProps ? mapActionstoProps(store.dispatch, this.props) : {};      //整合props，传给接收的组件      this.setState({        allProps: {          ...stateProps,          ...actionProps,          ...this.props,        },      });    };    render() {      return &lt;WrapperComponent {...this.state.allProps} /&gt;;    }  };};"},{"id":"c67c2ffa11cd0dab91827ba4c8ff4006","isRootIndexFile":false,"isIndexFile":true,"filename":"index.md","basename":"框架","path":"/home/runner/work/qxtang.github.io/qxtang.github.io/前端/框架","content":"框架React 与 Vue 异同React 是手动挡，Vue 是自动挡异：react 是函数式思想，all in js ，jsx 语法，js 操控 cssreact 是单向数据流react 每当应用的状态被改变时，全部子组件都会重新渲染。当然，这可以通过 shouldComponentUpdate 这个生命周期方法来进行控制，如果为 true 继续渲染、false 不渲染，但 Vue 将此视为默认的优化react 对 ts 更友好一些vue 是响应式思想，也就是基于数据可变的。把 html、js、css、组合到一起，也可以通过标签引擎组合到一个页面中vue 是双向绑定Vue 宣称可以更快地计算出 Virtual DOM 的差异，这是由于它在渲染过程中，会跟踪每一个组件的依赖关系，不需要重新渲染整个组件树同：使用 Virtual DOM，都有 jsx，性能好都是数据驱动视图什么是 mvvmModel-View-ViewModel 的缩写mvvm 是一种设计思想Model 层代表数据模型，也可以在 Model 中定义数据修改和操作的业务逻辑View 代表 UI 组件，它负责将数据模型转化成 UI 展现出来ViewModel 是一个同步 View 和 Model 的对象在 MVVM 架构下，View 和 Model 之间并没有直接的联系，而是通过 ViewModel 进行交互什么是受控组件受控：value 和 state 绑在一起的非受控：可通过浏览器 api 获取值单向数据流规定数据只能由外层组件向内层组件进行传递和更新组件的 props 是只读的让组件之间的关系变得简单、可预测、所有状态的改变可记录、可跟踪，源头易追溯否则容易导致数据紊乱、出现不可控操作如果数据在兄弟子组件之间共享，那么数据应该存储在父组件，并同时传递给需要数据的两个子组件什么是双向绑定数据与视图的响应式设计。具体表现为：View 的改变（填写表单）能实时让 Model 发生变化，而 Model 的变化也能实时更新 View什么是单向绑定所有数据只有一份，一旦数据变化，就去更新页面(只有 data--&gt;DOM，没有 DOM--&gt;data)用户在页面作出更新，需要用户手动收集(双向绑定是自动收集)，在合并到原有的数据中双向绑定、单向绑定的优缺点单向绑定：数据流也是单向的，对于复杂应用来说是实施统一状态管理（如 redux）的前提双向绑定：在一些需要实时反应用户输入的场合会非常方便（如多级联动菜单）。但常认为复杂应用中这种便利比不上引入状态管理带来的优势。因为不知道状态什么时候发生改变，是谁造成的改变，数据变更也不会通知"},{"id":"e7b856272f499e7d615800f583a18f05","isRootIndexFile":false,"isIndexFile":false,"filename":"spa 路由原理.md","basename":"spa 路由原理","path":"/home/runner/work/qxtang.github.io/qxtang.github.io/前端/框架","content":"spa 路由原理基本原理页面切换实质是切换 url，监听 url 变化，从而渲染不同的页面组件。hash 模式hash 包含在 URL 中，但不包括在请求中，用来指导浏览器动作，修改 hash 不会刷新页面hash 模式下，井号之前的内容才会被包含在请求中，因此对于后端来说，即使没有做到对路由的全覆盖，也不会返回 404 错误原理是监听 hashchange 事件执行对应回调history 模式历史记录、网页标题修改：HTML5 特性 pushState 和 replaceState监听 window 对象的 popState 事件执行对应回调更新页面，一个文档的 history 对象出现变化时（在浏览器某些行为下触发，比如点击后退、前进按钮或者调用 history.back()、history.forward()、history.go()方法），就会触发 popstate 事件history 模式下，前端的 URL 和实际向后端发起请求的 URL 一致。服务端如果缺少对该页面请求的处理，就会返回 404 错误需要服务器的支持：需要在服务端增加一个覆盖所有情况的候选资源：比如 URL 匹配不到任何资源时，则返回同一个 index.html 页面，这个页面就是前端应用的入口页面更推荐用 history 模式，history 模式更利于 seo 优化，url 也比较美观"},{"id":"89a269dba934197974e07de67fbdffe7","isRootIndexFile":false,"isIndexFile":false,"filename":"虚拟 Dom 与 diff.md","basename":"虚拟 Dom 与 diff","path":"/home/runner/work/qxtang.github.io/qxtang.github.io/前端/框架","content":"虚拟 Dom 与 diff虚拟 dom使用 javascript 对象表示 DOM 结构的树形数据结构这个树结构包含整个 DOM 结构的信息真实 DOM 的内存表示，一种编程概念为框架带来了跨平台的能力，抽象了原本的渲染过程，实现了跨平台的能力结合 diff 算法，可以减少 JavaScript 操作真实 DOM 的带来的性能消耗并不是所有情况使用虚拟 DOM 都提高性能，是针对在复杂的的项目使用。如果简单的操作，使用虚拟 DOM，要创建虚拟 DOM 对象等等一系列操作，还不如普通的 DOM 操作优点：跨平台直接操作/频繁操作 DOM 的性能差操作虚拟 DOM 不会立马进行重绘回流操作，一次性比较并修改真实 DOM 中需要改的部分，再操作 dom缺点：无法进行极致优化：在一些性能要求极高的应用中虚拟 DOM 无法进行针对性的极致优化，比如 VScode 采用直接手动操作 DOM 的方式进行极端的性能优化diff算法描述一种对比算法，对比出是哪个虚拟节点更改了，找出这个虚拟节点，并只更新这个虚拟节点所对应的真实节点，而不用更新其他数据没发生改变的节点，实现精准更新真实 DOM，进而提高效率在某一时间节点调用 React 的 render() 方法，会创建一棵由 React 元素组成的树。在下一次 state 或 props 更新时，相同的 render() 方法会返回一棵不同的树。React 需要基于这两棵树之间的差别来判断如何有效率的更新 UI 以保证当前 UI 与最新的树保持同步新旧虚拟 DOM 对比的时候，Diff 算法比较只会在同层级进行，不会跨层级比较。所以 Diff 算法是深度优先算法，时间复杂度 O(n)diff 过程把树形结构按照层级分解，只比较同级元素给列表结构的每个单元添加唯一的 key 属性，方便比较同一类型的元素：保留 DOM 节点，仅比对及更新有改变的属性元素类型不同：拆卸原有的树并且建立起新的树如果有子节点，对子节点进行递归key 的作用Keys 是一个辅助标识，用于追踪列表中被修改的元素在 diff 算法中，会借助元素的 key 值来判断该元素是不是新创建的，而减少不必要的重新渲染key 为什么不能用下标组件实例是基于它们的 key 来决定是否更新以及复用如果 key 是一个下标，那么修改顺序时会修改当前的 key导致非受控组件的 state（比如输入框）可能相互篡改，会出现无法预期的变动参考https://juejin.cn/post/6844903806132568072https://juejin.cn/post/6990582632270528525https://juejin.cn/post/6994959998283907102https://www.zhihu.com/question/31809713https://juejin.cn/post/6844903607913938951"}]},{"id":"e485e4b093f3e648bb7997c595f332e9","dirname":"浏览器","filename":"","basename":"","path":"/home/runner/work/qxtang.github.io/qxtang.github.io/前端","children":[{"id":"0891d33a8428aa46e0aaf378da73e0fd","isRootIndexFile":false,"isIndexFile":true,"filename":"index.md","basename":"浏览器","path":"/home/runner/work/qxtang.github.io/qxtang.github.io/前端/浏览器","content":"浏览器cookie主要作用：会话状态管理、个性化设置、浏览器行为跟踪一段一般不超过 4KB 的小型文本数据由名称（name）、值（value）和其它几个用于控制 Cookie 有效期、安全性、使用范围的可选属性组成标记为 Secure 的 Cookie 只应通过被 HTTPS 协议加密过的请求发送给服务端。字段Name：cookie 的名称Value：cookie 的值Domain：指定了 Cookie 可以送达的主机名。Path：指定了一个 URL 路径，这个路径必须出现在要请求的资源的路径中才可以发送 Cookie 首部Expires/Max-Age：用于设置 Cookie 的过期时间Size：cookie 的大小HTTPOnly：可以防止客户端脚本访问 Cookie，保证安全，例如 XSS 攻击Secure：指定是否使用 HTTPS 安全协议发送 CookieSameSite：防止 CSRF 攻击 和用户追踪（第三方恶意获取 cookie），可以设置三个值：Strict、Lax、Nonecookie 缺点大小只有 4kb、会增加请求大小个数限制、长度限制不安全，有可能被截获相比 localstorage， 需要自己封装 setter 和 gettercookie-sessionHTTP 是一个无状态的协议为了解决 HTTP 无状态导致的问题，出现了 cookie，这个状态是指后端服务的状态而非通讯协议的状态第一次请求服务端的时候，服务端响应头出现一个 set-cookie 字段，在客户端设置一个 cookie当再次请求服务端的时候，请求会附带这个 cookie 过去，cookie 中存有 sessionId 这样的信息来到服务端这边确认是否属于同一次会话当客户端请求创建一个 session 的时候，服务端会先检查这个客户端的请求里是否已包含了一个 session 标识如果已包含这个 sessionId，则说明以前已经为此客户端创建过 session，服务端就按照 sessionId 把这个 session 检索出来使用现在可使用 jwt 替代跨域请求如何携带 cookie服务端设置 Access-Control-Allow-Origin 响应头，为允许跨域的域服务端设置 Access-Control-Allow-Credentials 响应头 为 true请求时设置 withCredentials 为 truewithCredentials 是什么XMLHttpRequest 的一个请求配置指示了是否该使用类似 cookies,authorization headers(头部授权)或者 TLS 客户端证书这一类资格证书来创建一个跨站点访问控制Web Worker现代浏览器为 JavaScript 创造的 多线程环境。可以新建并将部分任务分配到 worker 线程并行运行，两个线程可 独立运行，互不干扰，可通过自带的 消息机制 相互通信。 基本用法：// 创建workerconst worker = new Worker(&#x27;work.js&#x27;);// 向 worker 线程推送消息worker.postMessage(&#x27;Hello World&#x27;);// 监听 worker 线程发送过来的消息worker.onmessage = function (event) {  console.log(&#x27;Received message &#x27; + event.data);};限制:同源限制无法使用 document / window / alert / confirm无法加载本地资源安全XSS、CSRF 攻击原理和防御XSS：利用客户端代码漏洞，比如评论框，注入恶意 js 到网页防御 xss：过滤 html 标签，转义页面上的输入内容和输出内容，过滤 on 开头属性，cookie 设置 httpOnlyCSRF：设法伪造带有正确 Cookie 的 HTTP 请求通常由于服务端没有对请求头做严格过滤引起的CSRF 防御不要使用 GET 请求来修改数据不要被第三方网站访问到用户的 cookieReferer 头检测，设置白名单接口不要被第三方网站请求、用 token 请求校验SameSite 属性是 cookie 的一个属性，用来防止 CSRF 攻击和用户追踪，用来限制第三方 CookieStrict完全禁止第三方 Cookie，可能造成不好的用户体验，比如，当前网页有一个 GitHub 链接，用户点击跳转就不会带有 GitHub 的 Cookie，跳转过去总是未登陆状态Lax（默认值）大多数情况也是不发送第三方 Cookie，但是导航到目标网址的 Get 请求除外None网站可以选择显式关闭 SameSite 属性，将其设为 None。不过，前提是必须同时设置 Secure 属性（Cookie 只能通过 HTTPS 协议发送），否则无效。白屏如何解决往 html 中填充内容，比如渲染根元素中间加上“加载中”几个字，让渲染结束前的这段时间有内容可以显示计算白屏时间使用 Performance API：&lt;!DOCTYPE html&gt;&lt;html&gt;  &lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot; /&gt;    &lt;title&gt;白屏&lt;/title&gt;    &lt;script type=&quot;text/javascript&quot;&gt;      // 不兼容performance.timing 的浏览器，如IE8      window.pageStartTime = Date.now();    &lt;/script&gt;    &lt;!-- 页面 CSS 资源 --&gt;    &lt;link rel=&quot;stylesheet&quot; href=&quot;common.css&quot; /&gt;    &lt;link rel=&quot;stylesheet&quot; href=&quot;page.css&quot; /&gt;    &lt;script type=&quot;text/javascript&quot;&gt;      // 白屏时间结束点      window.firstPaint = Date.now();    &lt;/script&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;!-- 页面内容 --&gt;  &lt;/body&gt;&lt;/html&gt;可使用 Performance API 时：白屏时间 = firstPaint - performance.timing.navigationStart;不可使用 Performance API 时：白屏时间 = firstPaint - pageStartTime;同源策略（跨域）不同协议、域名、端口，禁止请求，iframe、image、script、link 标签可以为什么会有同源策略如果没有同源策略，不同源的数据和资源（如 HTTP 头、Cookie、DOM、localStorage 等）就能相互随意访问，没有安全性。解决nginx，tomcat，apache 等任何有代理相关功能的服务器jsonpcorsjsonp使用 script 标签来帮助我们跨域服务端返回 函数名({json数据})，放在 script src 请求执行，前后端约定好函数名（或者由前端传给后端，即 callbackName）jquery 封装了 jsonp缺点：不好调试，在调用失败的时候不会返回任何状态码安全性，提供 jsonp 的服务可能存在页面注入漏洞cors服务器设置响应头：Access-Control-Allow-Origin:&lt;origin&gt;|*，origin 参数指定允许访问该资源的外域 URL默认 CORS 仅支持客户端向服务器发送如下的 9 个请求头：AcceptAccept-LanguageContent-LanguageDRPDownLinkSave-DataViewport-WidthWidthContent-Type(值仅限于 text/plain、multipart/form-data、application/x-www-form-urlencoded 三者之一)如果客户端向服务器发送了额外的请求头信息，则需要在服务器端，通过 Access-Control-Allow-Headers 对额外的请求头进行声明res.setHeader(&#x27;Access-Control-Allow-Headers&#x27;, &#x27;Content-Type,X-Custom-Header&#x27;);默认 CORS 仅支持客户端发起 GET、POST、HEAD 请求，如果客户端希望通过 PUT、DELETE 等方式请求，需要在服务器端，通过 Access-Control-Alow-Methods 来指明允许使用的 HTTP 方法// 只允许 POST、GET、DELETE、HEAD 请求方法res.setHeader(&#x27;Access-Control-Allow-Methods&#x27;, &#x27;POST,GET,DELETE,HEAD&#x27;);// 允许所有的 HTTP 请求方法res.setHeader(&#x27;Access-Control-Allow-Methods&#x27;, &#x27;*&#x27;);同时满足以下两大条件的请求，就属于简单请求，反之为非简单请求：请求方式：GET、POST、HEAD 三者之一HTTP 头部信息不超过以下几种字段：AcceptAccept-LanguageContent-LanguageLast-Event-IDContent-Type：只限于三个值 application/x-www-form-urlencoded、multipart/form-data、text/plain简单请求：请求头自动带上 Origin如果 Origin 指定的源不在允许范围之内，服务器会返回一个正常的 HTTP 回应，然后浏览器发现头信息中没有包含 Access-Control-Allow-Origin 字段，就表示出错否则会出现如下响应头Access-Control-Allow-Origin: http://api.bob.com ## 接受请求的域(*为所有)Access-Control-Allow-Credentials: true ## 是否可以发送cookieAccess-Control-Expose-Headers: FooBar ## 该字段可选，XHMHttpRequest 对象的方法只能够拿到六种字段: Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma，如果想拿到其他的需要使用该字段指定Content-Type: text/html; charset=utf-8如果请求时需要带上 cookie，请求头需要设置 withCredentials 为 true非简单请求：非简单请求的 CORS 会在正式通信之前进行一次预检请求浏览器先询问服务器，当前网页所在的域名是否可以请求您的服务器，以及可以使用哪些 HTTP 请求类型和头信息，只有得到正确的答复，才会进行正式的请求预检使用的请求方法是 OPTIONS，表示这个请求是用来询问的## 预检请求示例OPTIONS /cors HTTP/1.1Origin: localhost:2333Access-Control-Request-Method: PUT // 表示使用的什么HTTP请求方法Access-Control-Request-Headers: X-Custom-Header // 表示浏览器发送的自定义字段Host: localhost:2332Accept-Language: zh-CN,zh;q=0.9Connection: keep-aliveUser-Agent: Mozilla/5.0...服务器收到预检请求以后，检查了 Origin、Access-Control-Request-Method 和 Access-Control-Request-Headers 字段以后，确认允许跨域请求，就可以做出回应## 预检响应头示例HTTP/1.1 200 OKDate: Mon, 01 Dec 2008 01:15:39 GMTServer: Apache/2.0.61 (Unix)Access-Control-Allow-Origin: http://localhost:2332 // 表示 http://localhost:2332可以访问数据Access-Control-Allow-Methods: GET, POST, PUTAccess-Control-Allow-Headers: X-Custom-HeaderContent-Type: text/html; charset=utf-8Content-Encoding: gzipContent-Length: 0Keep-Alive: timeout=2, max=100Connection: Keep-AliveContent-Type: text/plain如未通过预检，会返回一个正常的 HTTP 响应，但是没有任何 CORS 的头相关信息，浏览器认定为失败当预检请求通过之后就发出正常的 HTTP 请求事件流描述接收事件的顺序，包括几个阶段：事件捕获阶段处于目标阶段事件冒泡阶段addEventListener 第三个参数：false（默认） - 事件在冒泡阶段执行true - 事件在捕获阶段执行事件流的应用：事件委托（事件代理）不直接在目标 dom 上设置监听函数，而是在其父元素上设置监听函数通过事件冒泡，父元素可以监听到子元素上事件的触发，通过判断事件发生元素 DOM 的类型，来做出不同的响应举例：ul 和 li 标签的事件监听，在添加事件时候，采用事件委托机制，不在 li 标签上直接添加，而是在 ul 父元素上添加比较合适动态元素的绑定，新添加的子元素也会有监听函数，也可以有事件触发机制target 和 currentTarget 区别event.target 返回触发事件的元素event.currentTarget 返回绑定事件的元素事件冒泡如果一个元素触发事件，那么其所有祖先元素都会依次执行触发该事件，这种机制称为冒泡（好比气泡从水底下一直向上冒泡，像 dom 树一样，一直到根元素。）事件捕获捕获与事件冒泡相反如何取消事件冒泡当我们只希望事件发生在它的目标而非它的父级元素上，封装 stopBubble 方法如下// 阻止事件冒泡的通用函数function stopBubble(e) {  // 如果传入了事件对象，那么就是非ie浏览器  if (e &amp;&amp; e.stopPropagation) {    // 因此它支持W3C的stopPropagation()方法    e.stopPropagation();  } else {    // 否则我们使用 ie 的方法来取消事件冒泡    window.event.cancelBubble = true;  }}a.onclick = function (e) {  stopBubble(e);};dom 元素的各种位置区别clientHeight：表示的是可视区域的高度，不包含 border 和滚动条offsetHeight：表示可视区域的高度，包含了 border 和滚动条scrollHeight：表示了所有区域的高度，包含了因为滚动被隐藏的部分。clientTop：表示边框 border 的厚度，在未指定的情况下一般为 0scrollTop：滚动后被隐藏的高度，获取对象相对于由 offsetParent 属性指定的父坐标(css 定位的元素或 body 元素)距离顶端的高度。localStorage、sessionStorage、cookie 区别关闭选项卡后，将删除存储在 sessionStorage 中的数据localStorage 永远存在，除非手动删除cookie 根据 expires 字段（过期时间）决定requestAnimationFrame使用一个回调函数作为参数。这个回调函数会在浏览器重绘之前调用浏览器用于定时循环操作的一个接口，类似于 setTimeout，主要用途是按帧对网页进行重绘设置这个 API 的目的是为了让各种网页动画效果（DOM 动画、Canvas 动画、SVG 动画、WebGL 动画）能够有一个统一的刷新机制，从而节省系统资源，提高系统性能，改善视觉效果代码中使用这个 API，就是告诉浏览器希望执行一个动画，让浏览器在下一个动画帧安排一次网页重绘优势在于可以充分利用显示器的刷新机制，比较节省系统资源显示器有固定的刷新频率（60Hz 或 75Hz），也就是说，每秒最多只能重绘 60 次或 75 次，requestAnimationFrame 的基本思想就是与这个刷新频率保持同步cancelAnimationFrame 用于取消重绘，它的参数是 requestAnimationFrame 返回的一个代表任务 ID 的整数值为了提高性能和电池寿命，因此在大多数浏览器里，当 requestAnimationFrame() 运行在后台标签页或者隐藏的 &lt;iframe&gt; 里时，requestAnimationFrame() 会被暂停调用以提升性能和电池寿命当浏览器渲染线程被过度占用时这个 API 调用间隔会非常不稳定，它并不是银弹使用：function test(timestamp) {  console.log(timestamp);  requestAnimationFrame(test);}requestAnimationFrame(test);"},{"id":"39b728ede14b93d31bd47ce1196d14ad","isRootIndexFile":false,"isIndexFile":false,"filename":"展示页面过程.md","basename":"展示页面过程","path":"/home/runner/work/qxtang.github.io/qxtang.github.io/前端/浏览器","content":"展示页面过程构造请求输入 URL 后解析出协议、主机、端口、路径等信息，构造一个 HTTP 请求查询缓存强缓存、协商缓存DNS 解析DNS 解析其实是一个递归的过程为了更快拿到 IP，DNS 普遍使用了缓存：浏览器缓存：浏览器按照一定的频率缓存 DNS 记录操作系统缓存：如果浏览器缓存中找不到 DNS 记录，就会去操作系统中找路由缓存：路由器也有 DNS 缓存查询 ISP 的 DNS 服务器根服务器：ISP 的 DNS 服务器找不到之后，向根服务器发出请求，进行递归查询CDN：DNS 服务器会返回一个跟用户最接近的点的 IP 地址给用户，CDN 节点的服务器负责响应用户的请求，提供所需的内容dns-prefetch：一种 DNS 预解析技术。当浏览网页时，浏览器会在加载网页时对网页中的域名进行解析缓存，这样在单击当前网页中的连接时就无需进行 DNS 的解析，减少用户等待时间，提高用户体验获取 ip 和端口获得请求 url 对应的 ip 地址，根据解析到的 IP 地址和端口号发起请求建立 TCP 连接tcp 协议通过三次握手与服务器建立连接服务器处理请求服务器响应（nginx、apache 等）处理请求并返回 HTTP 报文，浏览器收到开始渲染浏览器渲染流程详见渲染原理断开 TCP 连接：TCP 四次挥手参考https://juejin.cn/post/6844903779700047885https://juejin.cn/post/6844903815758479374"},{"id":"b1f9a5c2edf24f12e239400e147cadd7","isRootIndexFile":false,"isIndexFile":false,"filename":"浏览器架构.md","basename":"浏览器架构","path":"/home/runner/work/qxtang.github.io/qxtang.github.io/前端/浏览器","content":"浏览器架构以 chrome 为例主要组成⽤户界⾯：地址栏、前进/后退按钮、书签菜单等浏览器引擎：在⽤户界⾯和渲染引擎之间传送指令渲染引擎：负责显示请求的内容⽹络：⽤于⽹络调⽤JavaScript 解释器数据存储各个进程以及负责的工作chrome 采用多进程架构Browser（主进程）浏览器界面显示，用户交互，前进、后退、收藏前进和后退按钮控制看不见的部分：网络请求、文件读写页面的创建、销毁Plugin（插件进程）控制网页使用的所有插件，例如 flash 插件每种类型的插件对应一个进程，仅当使用该插件时才创建GPU3D 绘制，负责独立于其它进程的 GPU 任务。它之所以被独立为一个进程是因为它要处理来自于不同 tab 的渲染请求并把它在同一个界面上画出来Renderer（渲染进程）（最重要）每个 Tab 页对应一个渲染进程，即浏览器内核这就是主要与前端开发打交道的进程，负责页面渲染，脚本执行，事件处理等负责 tab 内和网页展示相关的所有工作。Chrome 会尽可能为每一个 tab 甚至是页面里面的每一个 iframe 都分配一个单独的渲染进程渲染进程渲染进程包含几大类子线程：GUI 渲染线程负责渲染页面，布局和绘制页面需要重绘和回流时，该线程就会执行与 js 引擎线程互斥，防止渲染结果不可预期JS 引擎线程负责处理解析和执行 javascript 脚本程序只有一个 JS 引擎线程（单线程）与 GUI 渲染线程互斥，防止渲染结果不可预期事件触发线程用来控制事件循环当事件满足触发条件时，将事件放入到 JS 引擎所在的执行队列中定时器线程setInterval 与 setTimeout 所在的线程定时任务并不是由 JS 引擎计时的，是由定时触发线程来计时的计时完毕后，通知事件触发线程异步网络请求线程浏览器有一个单独的线程用于处理 AJAX 请求当请求完成时，若有回调函数，通知事件触发线程其中 GUI 线程和 JS 引擎线程是互斥的，由于 JavaScript 是可操纵 DOM 的，如果在修改这些元素属性同时渲染界面（即 JavaScript 线程和 UI 线程同时运行），那么渲染线程前后获得的元素数据就可能不一致一个 tab 一个渲染进程的优缺点优点：提供安全性和沙盒性，当其中一个 tab 的崩溃时，你可以随时关闭这个 tab 并且其他 tab 不受到影响缺点：内存消耗大网站隔离功能会为网站内不同站点的 iframe 分配一个独立的渲染进程由来：如果一个 tab 只有一个进程的话不同站点的 iframe 都会跑在这个进程里面，这也意味着它们会共享内存，这就有可能会破坏同源策略常见浏览器内核IE：Trident 内核，也是俗称的 IE 内核Chrome：以前是 Webkit 内核，现在是 Blink 内核Firefox：Gecko 内核苹果 Safari：Webkit 内核参考https://juejin.cn/post/6844904046411644941https://zhuanlan.zhihu.com/p/149063367"},{"id":"3afb6ad15b155cb037676083d9603300","isRootIndexFile":false,"isIndexFile":false,"filename":"浏览器缓存.md","basename":"浏览器缓存","path":"/home/runner/work/qxtang.github.io/qxtang.github.io/前端/浏览器","content":"浏览器缓存Web 缓存种类： 数据库缓存，CDN 缓存，服务器缓存（例如 redis），浏览器缓存浏览器实现了 http 缓存浏览器缓存类型：强缓存，协商缓存只有 get 请求会缓存，post 请求不会缓存位置Memory Cache内存中缓存主要包含的是当前页面中已经抓取到的资源，已经下载的样式、脚本、图片读取高效、持续性很短随着进程的释放而释放，杀进程或者关闭 Tab 页面会被释放对于大文件来说，大概率是不存储在 Memory Cache 的，反之优先Disk Cache磁盘缓存浏览器获取当前系统内存使用率，过高的话，优先存储进 Disk Cache所有类型资源都可以放速度较慢不会被释放容量大Service WorkerService Worker 运行在 JavaScript 主线程之外，虽然由于脱离了浏览器窗体无法直接访问 DOM，但是它可以完成离线缓存、消息推送、网络代理等功能缓存过程每一次请求时，浏览器保存请求结果和缓存标识再次请求：存在缓存结果和缓存标识：检查是否命中强缓存，命中则直接使用上次保存的请求结果，返回 200，不向服务器发起请求；否则，使用协商缓存不存在该缓存结果和缓存标识：直接向服务器发起请求首次请求总体流程强缓存向浏览器缓存查找该请求结果，并根据该结果的缓存规则来决定是否使用该缓存结果的过程当符合命中强缓存的条件，不向服务器发送请求，直接从缓存中读取资源，返回 200 状态码控制强缓存的 header（按优先级小到大排序）：expires &lt; pragma &lt; cache-controlcache-control 优先级最高，当不支持 http1.1 的环境才会使用 expires 或者 pragmaexpires资源到期时间、格式为格林尼治时间戳如果未超过过期时间，直接使用该缓存缺点：要求客户端和服务端时钟严格同步，本地时间可以自己修改pragmaHTTP 1.0用于禁用网页缓存取值为 no-cache，和 cache-control 的 no-cache 效果一样cache-controlHTTP 1.1 新增取值public：资源客户端和服务器都可以缓存privite：资源只有客户端可以缓存no-cache：客户端缓存资源，但是是否缓存需要经过协商缓存来验证no-store：不使用缓存max-age：缓存保质期协商缓存强缓存失效后，浏览器携带缓存标识向服务器发送请求，由服务器根据缓存标识来决定是否使用缓存的过程会向服务器发送请求协商缓存过程：服务器发现资源无需更新，返回 304浏览器从本地缓存中获取资源，继续使用如果服务器发现该资源更新了，返回该资源，状态码 200浏览器更新该资源和缓存标识到本地缓存相关 header：Last-Modified / If-Modified-Since存在的问题：时间单位只精确到秒，如果文件 1 秒内改变多次，无法确保缓存精度；有可能文件内容没变，但是修改时间因为某些原因变了，人为修改之类的Last-Modified（响应头）：资源在服务器最后被修改的时间If-Modified-Since（请求头）携带上次请求返回的 Last-Modified告诉服务器该资源上次请求时的最后被修改时间服务器做对比后决定协商缓存是否生效，返回 304 或 200Etag / If-None-Match优先级高于 Last-Modified，解决 Last-Modified 的问题，但性能比 Last-Modified 差，Etag 需要计算Etag（响应头）：当前资源文件唯一标识，由服务器生成，由文件内容决定If-None-Match（请求头）携带上次请求该资源时返回的 Etag，告诉服务器服务器做对比，一致则代表生效，返回 304 或 200实际应用需要实时更新频繁变动的资源，设置 cache-control 为 no-cache不常变化的资源，例如 jquery，设置 cache-control 为 max-age=一个很长的时间单页应用部署时，入口 html 文件使用协商缓存（确保 html 入口是最新的，能够及时更新）按下 F5 或 ctrl+F5 时发生了什么ctrl+f5：跳过强缓存和协商缓存，直接从服务器加载资源f5：跳过强缓存，会检查协商缓存浏览器地址栏中输入 URL 回车：走正常流程参考https://www.jianshu.com/p/54cc04190252"},{"id":"02b91b90ead1d3896d0a8c1febfa517a","isRootIndexFile":false,"isIndexFile":false,"filename":"渲染原理.md","basename":"渲染原理","path":"/home/runner/work/qxtang.github.io/qxtang.github.io/前端/浏览器","content":"渲染原理合成渲染树创建 dom 树字节 → 字符 → 令牌 → 节点 → 对象模型(DOM)创建 dom 树过程转换（字节 → 字符）：浏览器从磁盘或网络读取 HTML 原始字节，根据文件的指定编码（例如 UTF-8）将它们转换成字符令牌化（字符 → 令牌）：浏览器将字符串转换成 W3C HTML5 标准规定的各种令牌，例如，&lt;html&gt;、&lt;body&gt;，以及其他尖括号内的字符串。每个令牌都具有特殊含义和一组规则词法分析（令牌 → 节点）：分词器将字节流转换为一个一个的 Token，Token 分为 Tag Token 和文本 Token，令牌转换成定义其属性和规则的“对象”。DOM 构建（节点 → DOM）：将 Token 解析为 DOM 节点，并将 DOM 节点添加到 DOM 树中HTML 解析器维护了一个 Token 栈结构，用来计算节点间父子关系，在上阶段生成的 Token 会被顺序压到这个栈中：HTML 解析器开始工作时，会默认创建了一个根为 document 的空 DOM 结构，同时会将一个 StartTag document 的 Token 压入栈底如果压入到栈中的是 StartTagToken，HTML 解析器会为该 Token 创建一个 DOM 节点，然后将这个 Dom 节点加入到 DOM 树中，它的父节点就是栈中相邻的那个元素生成的 DOM 节点如果分词器解析出来的是文本 Token，那么会生成一个文本节点，然后把这个文本 Dom 节点加入到 DOM 树中（文本 Token 不需入栈），它的父节点就是当前栈顶 Token 所对应的 DOM 节点如果分词器解析出来的是 EndTag 标签，HTML 解析器会查看 Token 栈顶的元素是否是 StartTag div，如果是，就将 StartTag div 从栈中弹出，边上该 div 元素解析完成最后按照上面的规则，分词器一路解析下来，就形成了一个简单的 DOM 树由于 HTML 标记定义不同标记之间的关系（一些标记包含在其他标记内），创建的对象链接在一个树数据结构内，此结构也会捕获原始标记中定义的父项-子项关系：HTML 对象是 body 对象的父项，body 是 paragraph 对象的父项，依此类推。创建 cssom 树将 css 解析成 cssom 树格式化样式表：字节流转为 document.styleSheets标准化样式表：比如 em → px, red → rgba(255,0,0,0), bold → 700计算每个 dom 节点样式计算规则：继承和层叠继承：每个子节点默认继承父节点样式，如果父节点找不到，采用浏览器默认样式（也叫 UserAgent 样式）层叠：样式层叠，是 CSS 一个基本特征，定义如何合并来自多个源的属性值的算法。具体层叠规则属于深入 CSS 语言的范畴计算完样式后，所有样式值会挂载到 window.getComputedStyle() 当中，可以通过这个方法获取计算后的样式解析 js操作 dom 树和 cssom 树将 dom 树和 cssom 树构造成渲染树只包含可见元素构造渲染树过程：从 dom 树的根节点开始遍历每个可见的节点对每个可见节点，找到 css 树中的对应的规则，并应用根据每个可见的节点及其对应的样式，组合生成渲染树渲染树的节点称为渲染对象，包含有颜色和大小等属性的矩形渲染对象和 dom 对象相对应，但这种对应关系不是一对一的，不可见的 dom 元素不会被插入渲染树js 为什么会阻塞后续资源下载：因为 js 有可能会修改 dom，在 js 执行完成前，后续资源的下载可能是没有必要的，所以代码中 script 标签最好放在 html 文档末尾当文档加载过程中遇到 js 文件，html 文档会挂起渲染的线程，等待文档中 js 文件加载完毕，等待解析执行完毕，才恢复 html 文档的渲染线程非外部引入 javascript，css，对渲染的影响：css 会阻塞 dom 渲染：render tree 生成依赖 dom 树和 cssom 树，故会阻塞 render tree 的生成css 不会阻塞 dom 解析：dom 树和 cssom 树的解析互不影响js 会阻塞 dom 解析：dom 树构建时当遇到 javascript 脚本，就要暂停 dom 解析，先去执行 javascript，因为 javascript 可能会操作当前已经生成的 dom，加上 defer 或者 async 属性，脚本下载的过程就不会阻塞 dom 解析css 会阻塞 js 执行：js 中可能会获取 dom 元素的 css 样式属性，为了获取到最新的正确的样式，需要等所有的 css 加载完成，否则获取的样式可能是错误的或者不是最新的，要等到 js 前面的 css 加载完成，js 才能执行，所以一般 cdn 引入第三方库的 js 一般放在 css 之前body 内部的外链 css 较为特殊，会形成样式闪烁现象，慎用外部引入 javascript，css，对渲染的影响：webkit 渲染引擎有一个优化，当渲染进程接收 html 文件字节流时，会先开启一个预解析线程如果遇到 javascript 文件或者 css 文件，预解析线程会提前下载这些数据为什么：js 最好放底部：js 会阻塞 dom 解析css 最好放头部：避免屏闪，css 会阻塞 dom 渲染头部同时有 js 与 css，最好将 js 放在 css 上面：如果 js 中获取元素的样式，浏览器是需要计算的，就是依赖于 css。浏览器无法感知 js 内容是什么，为避免样式获取，因而只好等前面所有 css 下载完后，再执行 js布局计算分层生成图层树（Layer Tree）拥有层叠上下文属性的元素会被提升为单独一层需要裁剪（clip）的地方也会创建图层图层绘制创建新图层的时机：显式合成：拥有层叠上下文的元素HTML 根元素本身具有层叠上下文元素设置 position 不为 static 并且设置了 z-index 属性元素的 opacity 值不是 1元素的 transform 值不是 none元素的 filter 值不是 none元素的 isolation 值是 isolatewill-change 指定的属性值为上面任意一个需要剪裁（clip）的元素元素有了层叠上下文的属性或者需要被剪裁，满足其中任意一点，就会被提升成为单独一层隐式合成：z-index 比较低的节点会提升为一个单独的图层，那么层叠等级比它高的节点都会成为一个独立的图层会增大内存的压力，有时候会让页面崩溃，这就是层爆炸绘制图层把一个复杂的图层拆分为很小的绘制指令，然后再按照这些指令的顺序组成一个绘制数组，绘制数组元素包含坐标、样式等属性分块绘制图层的操作在渲染进程中有专门的线程：合成线程渲染进程的主线程会给合成线程发送消息，把绘制数组提交给合成线程合成线程会将图层划分为图块，通常是 256 × 256 或者 512 × 512 这个规格此处 Chrome 底层优化首屏加载速度的一个手段：因为非视口内图块数据要进入 GPU 内存，考虑到浏览器内存上传到 GPU 内存的操作消耗，即使是绘制一部分图块，也可能会耗费大量时间在首次合成图块时只采用一个低分辨率的图片当正常图块内容绘制完毕后，将当前低分辨率图块内容替换光栅化合成线程按照视口附近的图块来优先生成位图栅格化：指将图块转换为位图，生成位图的操作是由栅格化来执行的图块是栅格化执行的最小单位渲染进程中专门维护了一个栅格化线程池，专门负责把图块转换为位图数据合成线程会选择视口附近的图块，把它交给栅格化线程池生成位图生成位图的过程会使用 GPU 进行加速，生成的位图发送给合成线程，使用 GPU 生成位图的过程叫快速栅格化，或者 GPU 栅格化，保存在 GPU 内存合成和显示合成线程生成一个绘制命令，发送给浏览器进程浏览器进程根据这个命令，把页面内容绘制到内存（生成了页面），把这部分内存发送给显卡显卡工作基本原理：假设屏幕刷新频率 60Hz，即一秒更新 60 张图片，一张图片停留时间约为 16.7ms每次更新的图片都来自显卡的前缓冲区显卡接收到浏览器进程传来的页面后，会合成相应的图像，并将图像保存到后缓冲区显卡系统自动将前缓冲区和后缓冲区对换位置，如此循环更新比如某个动画大量占用内存时，浏览器生成图像变慢，图像传送给显卡不及时，而显示器还是以不变的频率刷新，因此会出卡顿掉帧现象回流-重绘-合成回流：dom 几何尺寸变化的时候触发，会将布局计算样式等流程全部走一遍，比较消耗资源根据得到的渲染树，计算所有节点在屏幕中的位置，得到节点的几何信息，进行布局回流必定触发重绘，重绘不一定触发回流触发回流的操作：页面初次渲染浏览器窗口大小改变元素尺寸、位置、内容发生改变元素字体大小变化添加或者删除可见的 dom 元素激活 CSS 伪类（例如：:hover）查询某些属性或调用某些方法重绘：元素样式改变不影响位置时触发，省去布局的流程，跳过了布局树和建图层树根据渲染树以及回流得到的几何信息，得到节点的绝对像素，遍历渲染树并调用硬件的 API 绘制所有节点合成：更改了一个既不要布局也不要绘制的属性渲染引擎跳过布局和绘制，直接执行合成操作提升合成层的最好方式是使用 CSS 的 will-change 属性例子：比如使用 CSS 的 transform 来实现动画效果，避免了回流跟重绘，直接在非主线程中执行合成动画操作。效率更高，是在非主线程上合成的，没有占用主线程资源，也避开了布局和绘制两个阶段，相对于重绘和重排，合成能大大提升绘制效率。合成的优势：交由 GPU 合成，比 CPU 处理要快需要 repaint 时，只需要 repaint 本身，不会影响到其他的层对于 transform 和 opacity 效果，不会触发 layout 和 paint减少回流和重绘：CSS：使用 cssText 设置样式、或修改 class 来设置样式将动画效果应用到 position 属性为 absolute 或 fixed 的元素上避免使用 CSS 表达式（例如：calc()）CSS3 硬件加速（GPU 加速），可以让 transform、opacity、filters 这些动画不会引起回流重绘（如果为太多元素使用 css3 硬件加速，会导致内存占用较大，会有性能问题）JavaScript：避免频繁操作样式，最好一次性重写 style 属性，或者将样式列表定义为 class 并一次性更改 class 属性避免频繁操作 DOM，创建一个 documentFragment，在它上面应用所有 DOM 操作，最后再把它添加到文档中也可以先为元素设置 display: none，操作结束后再把它显示出来。因为在 display 属性为 none 的元素上进行的 DOM 操作不会引发回流和重绘避免频繁读取会引发回流/重绘的属性或方法（offsetTop、offsetLeft、offsetWidth、offsetHeight、getBoundingClientRect 等），如果确实需要多次使用，就用一个变量缓存起来对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流调用以下 api 会触发重绘回流：offsetTop、offsetLeft、offsetWidth、offsetHeightscrollTop、scrollLeft、scrollWidth、scrollHeightclientTop、clientLeft、clientWidth、clientHeightgetComputedStyle()getBoundingClientRecthttps://gist.github.com/paulirish/5d52fb081b3570c81e3aGPU 加速：利用 CSS3 的 transform、opacity、filter、will-change 这些属性可以实现合成的效果，也就是常说的 GPU 加速在合成的情况下，直接跳过布局和绘制流程，进入非主线程处理部分，直接交给合成线程处理充分发挥 GPU 优势，合成线程生成位图的过程中会调用线程池，并在其中使用 GPU 进行加速生成，而 GPU 是擅长处理位图数据的没有占用主线程的资源，即使主线程卡住了，效果依然流畅展示最佳实践使用 createDocumentFragment 进行批量的 DOM 操作对于 resize、scroll 等进行防抖/节流处理动画使用 transform 或者 opacity 实现将元素的 will-change 设置为 opacity、transform、top、left、bottom、right。渲染引擎会为其单独实现一个图层，当这些变换发生时，仅仅只是利用合成线程去处理这些变换，而不牵扯到主线程，提高渲染效率。对于不支持 will-change 属性的浏览器，使用一个 3D transform 属性来强制提升为合成 transform: translateZ(0);使用 requestAnimationFramewill-changehttps://developer.mozilla.org/zh-CN/docs/Web/CSS/will-change告知浏览器该元素会有哪些变化的方法，这样浏览器可以在元素属性真正发生变化之前提前做好对应的优化准备工作可以将一部分复杂的计算工作提前准备好，使页面的反应更为快速灵敏应该被视为最后的应对手段，用于解决现有的性能问题。不应该被用来预测性能问题"}]},{"id":"389b55b894875c4b629758e783cd8053","isRootIndexFile":false,"isIndexFile":false,"filename":"AST 抽象语法树.md","basename":"AST 抽象语法树","path":"/home/runner/work/qxtang.github.io/qxtang.github.io/前端","content":"AST 抽象语法树解析器 Parser把 js 源码转化为抽象语法树（AST）常用解析器https://github.com/babel/babel/tree/master/packages/babel-parserhttps://github.com/acornjs/acorn解析步骤两步：词法分析、语法分析词法分析把字符串形式的代码转换为 令牌（tokens）流，可以把令牌看作是一个扁平的语法片段数组例如：// 源n * n;// 词法分析结果[  { type: { ... }, value: &quot;n&quot;, start: 0, end: 1, loc: { ... } },  { type: { ... }, value: &quot;*&quot;, start: 2, end: 3, loc: { ... } },  { type: { ... }, value: &quot;n&quot;, start: 4, end: 5, loc: { ... } },]每一个 type 有一组属性来描述该令牌：const token = {  type: {    label: &#x27;name&#x27;,    keyword: undefined,    beforeExpr: false,    startsExpr: true,    rightAssociative: false,    isLoop: false,    isAssign: false,    prefix: false,    postfix: false,    binop: null,    updateContext: null,  },};语法分析根据词法分析的结果，也就是令牌 tokens，将其转换成 AST// 源function square(n) {  return n * n;}// ATSconst ast = {  type: &#x27;FunctionDeclaration&#x27;,  id: {    type: &#x27;Identifier&#x27;,    name: &#x27;square&#x27;,  },  params: [    {      type: &#x27;Identifier&#x27;,      name: &#x27;n&#x27;,    },  ],  body: {    type: &#x27;BlockStatement&#x27;,    body: [      {        type: &#x27;ReturnStatement&#x27;,        argument: {          type: &#x27;BinaryExpression&#x27;,          operator: &#x27;*&#x27;,          left: {            type: &#x27;Identifier&#x27;,            name: &#x27;n&#x27;,          },          right: {            type: &#x27;Identifier&#x27;,            name: &#x27;n&#x27;,          },        },      },    ],  },};应用IDE 使用，如代码风格检测(eslint 等)、代码的格式化，代码高亮，代码错误等等代码的混淆压缩转换代码工具，如 babelvue 模板编译过程prettierbabel-plugin-import将 antd 组件 import 语句转换成按需引入写法的 babel 插件参考https://segmentfault.com/a/1190000016231512https://juejin.cn/post/6844903725228621832"},{"id":"dfa88fedd022eb7068bcd634ae9c0b41","isRootIndexFile":false,"isIndexFile":false,"filename":"Babel.md","basename":"Babel","path":"/home/runner/work/qxtang.github.io/qxtang.github.io/前端","content":"Babel概念一个 JavaScript 翻译器将 ECMAScript 2015+ 语法编写的代码转换为向后兼容的 JavaScript 语法，以便能够运行在各种环境中通过 Polyfill 方式在目标环境中添加缺失的特性（通过引入第三方 polyfill 模块，例如 core-js）本质上是操作 AST 来完成代码的转译基本工作原理第 1 步 解析（Parse）通过解析器 babylon 将代码解析成抽象语法树，进行词法分析和语法分析，词法分析主要把字符流源代码（Char Stream）转换成令牌流（Token Stream），语法分析主要是将令牌流转换成抽象语法树第 2 步 转换（TransForm）通过 babel-traverse plugin 对抽象语法树进行深度优先遍历，遇到需要转换的，就直接在 AST 对象上对节点进行添加、更新及移除操作，比如遇到箭头函数，就转换成普通函数，最后得到新的 AST 树第 3 步 生成（Generate）通过 babel-generator 将 AST 树生成 es5 代码，同时也能创建 Source Map 映射配置方式主要分为 presets 和 plugins.babelrc._ 和 babel.config._ 区别.babelrc.* 仅适用于项目的某个部分babel.config.* 会影响整个项目中的代码，包含 node_modules 中的代码推荐使用 babel.config.*，Babel 自身使用的就是这种格式presets逆序处理，从后往前，这主要是为了确保向后兼容，由于大多数用户将 &quot;es2015&quot; 放在 &quot;stage-0&quot; 之前，可以是数组、对象、字符串{  &quot;presets&quot;: [&quot;presetA&quot;, [&quot;presetA&quot;], [&quot;presetA&quot;, {}]]}useBuiltIns：{  &quot;presets&quot;: [    [      &quot;@babel/preset-env&quot;,      {        &quot;useBuiltIns&quot;: &quot;usage&quot;,        &quot;debug&quot;: true,        &quot;corejs&quot;: 3 // 建议使用 3，core-js@2 分支中已经不会再添加新特性，新特性都会添加到 core-js@3      }    ]  ]}babel 在转译的时候，会将源代码分成 syntax（语法） 和 api 两部分来处理，语法处理通过配置 presetsbabel 使用 polyfill 来处理 api，@babel/preset-env 中有一个配置选项 useBuiltIns，用来告诉 babel 如何处理 api，由于这个选项默认值为 false，即不处理 api，所以代码转译后默认没有处理 api，可以通过手动引入 polyfill，但是 polyfill 没有动态引入会增加包的体积设置 useBuiltIns 的值为 &quot;entry&quot;，同时在源代码最上方手动引入 @babel/polyfill 这个库（该库一共分为两部分，第一部分是 core-js，第二部分是 regenerator-runtime。其中 core-js 为其他团队开源的另一个独立项目），此时 babel 根据项目 browserslist，引入浏览器不兼容的 polyfill。需要在入口文件手动添加 import '@babel/polyfill'，会自动根据 browserslist 替换成浏览器不兼容的所有 polyfill将 useBuiltIns 改为 &quot;usage&quot;，babel 就可以按需加载 polyfill，不需要手动引入 @babel/polyfill存在的问题：polyfill 会直接在全局对象上定义方法，比如 Array.include，众所周知前端开发不鼓励污染全局变量babel 会向翻译后的每一个文件原地定义许多帮助函数，用于转义语法，比如 __spreadArray、__generator,plugins本质是一个 js 程序, 指示 Babel 如何对代码进行转换排列顺序很重要plugins 在 presets 之前运行plugins 顺序从前往后排列，与 presets 相反核心与其周边babel 使用了微内核的架构风格，它的核心小，大部分功能通过插件扩展实现，@babel/core 就是这个内核，包含核心功能@babel/core加载和处理配置，读取 .babelrc 文件内容加载插件提供编译的 api：调用 Parser 进行语法解析，生成 AST调用 Traverser 遍历 AST，对 AST 进行转换生成代码，包括 SourceMap 转换和源代码生成@babel/cli命令行工具@babel/preset-env预设的语法转换插件的集合可以根据目标浏览器运行环境配置（browserslist、targets），将 es6+ 语法转 es5 语法，不需要一个个语法插件去安装（比如@babel/plugin-transform-arrow-functions）@babel/plugin-transform-runtime、@babel/runtime这个插件就是为了解决 useBuiltIns polyfill 污染全局的问题和每一个文件都有辅助函数问题将 babel 转译时添加到文件中的内联辅助函数统一隔离到 babel-runtime 提供的 helper 模块中编译时，直接从 helper 模块加载，不在每个文件中重复的定义辅助函数，从而减少包的尺寸其中 @babel/plugin-transform-runtime 的作用是转译代码，转译后的代码中可能会引入 @babel/runtime-corejs3 里面的模块前者运行在编译时，后者运行在运行时。类似 polyfill，后者需要被打包到最终产物里在浏览器中运行@babel/plugin-transform-runtime 通常仅在开发时使用，但是运行时最终代码需要依赖 @babel/runtime，所以 @babel/runtime 必须要作为生产依赖被安装typescript 的 importHelpers 配置和 tslib 也是类似的原理安装：$ yarn add @babel/plugin-transform-runtime -D$ yarn add @babel/runtime-corejs3修改配置如下：{  &quot;presets&quot;: [    [      &quot;@babel/preset-env&quot;      // 移除，否则和下面重复了      // {      //   &quot;useBuiltIns&quot;: &quot;usage&quot;,      //   &quot;debug&quot;: true      // }    ]  ],  &quot;plugins&quot;: [    [      &quot;@babel/plugin-transform-runtime&quot;,      {        &quot;corejs&quot;: 3 // 指定 runtime-corejs 的版本，目前有 2 3 两个版本      }    ]  ]}引入了这个插件后：api 从之前的直接修改原型改为了从一个统一的模块中引入，避免了对全局变量及其原型的污染helpers 从之前的原地定义改为了从一个统一的模块中引入，使得打包的结果中每个 helper 只会存在一个@babel/parser将源代码解析为 AST已经内置支持很多语法. 例如 JSX、Typescript、Flow、以及最新的 ECMAScript 规范@babel/traverse对 AST 进行遍历，对 AST 进行转换@babel/generator将 AST 转换为源代码，支持 SourceMapcore.js新 api 集合@babel/polyfill@babel/polyfill 融合了 core-js 和 regenerator-runtime，因此 babel-polyfill 本质就是 corejs引入 @bable/polyfill 就相当于在代码中引入下面两个库import &#x27;core-js/stable&#x27;;import &#x27;regenerator-runtime/runtime&#x27;;官方提示已经 deprecated，推荐使用 core-js@3 + @babel/preset-env 即可🚨 As of Babel 7.4.0, this package has been deprecated in favor of directly including core-js/stable (to polyfill ECMAScript features) and regenerator-runtime/runtime (needed to use transpiled generator functions)regenerator-runtime生成器函数、async、await 函数经 babel 编译后，regenerator-runtime 模块用于提供功能实现，运行时依赖，需要打包进产物"},{"id":"c33bc774af71130869c75080ef35f8cd","isRootIndexFile":false,"isIndexFile":true,"filename":"index.md","basename":"前端","path":"/home/runner/work/qxtang.github.io/qxtang.github.io/前端","content":"前端帧动画概念：每隔一个短暂时间进行图像替代，使其连续播放而成动画可以自由控制播放、暂停和停止可以控制播放次数，播放速度可以添加交互，在播放完成后添加事件浏览器兼容性好https://juejin.cn/post/6844903790370357262CSS3 阶梯函数：https://codesandbox.io/s/jie-ti-han-shu-shi-xian-zheng-dong-hua-shi-li-8r65b1通过 JS 来控制 img 的 src 属性切换（不推荐）通过 JS 来控制 Canvas 图像绘制，用 drawImage 方法将图片绘制到 Canvas 上，不断擦除和重绘通过 JS 来控制 CSS 属性值变化Browserslist用特定的语句来查询浏览器列表# 查询 Chrome 最后的两个版本npx browserslist &quot;last 2 Chrome versions&quot;chrome 96chrome 95autoprefixer 和 babel 都会用到开发过程中为了减小垫片的体积，避免使用过多没必要的垫片当我们确认的浏览器版本号，那么它的垫片体积就可以确认例如：当我们确认的浏览器版本号，那么它的垫片体积就会确认caniuse-lite 与 caniuse-dbbrowserslist 是从 caniuse-lite 这个库中查询数据的，caniuse-lite 是 caniuse-db 的精简版本，对 caniuse-db 的数据按一定规则做了简化，减少了库的大小caniuse-db 则是 can i use 网站的数据源，提供了网站查询所需的所有数据，caniuse-db 发布时会同步发布 caniuse-litecaniuse-lite 这个库也由 browserslist 团队进行维护由于它们都不属于线上数据库，使用时会将数据克隆至本地，所以可能会存在本地数据不是最新的情况，browserslist 提供了更新 caniuse-lite 的命令，可定期运行以获取最新数据npx browserslist@latest --update-db原理browserslist 根据正则解析查询语句，对浏览器版本数据库 caniuse-lite 进行查询，返回所得的浏览器版本列表因为 browserslist 并不维护数据库，因此它会经常提醒你去更新 caniuse-lite 这个库虚拟列表不能分页的情况下渲染多条（上万级别）数据只对可见区域进行渲染，对非可见区域中的数据不渲染或部分渲染的技术，从而达到极高的渲染性能实现描述首屏加载时，只加载可视区域内需要的列表项滚动发生时，计算出可视区域内的列表项，并将非可视区域内存在的列表项销毁列表项包含文字或图片，图片加载完成是异步的，无法预判高度对组件属性 itemSize 进行扩展，支持传递类型为数字、数组、函数将列表项渲染到屏幕外，对其高度进行测量并缓存，然后再将其渲染至可视区域内以预估高度先行渲染，然后获取真实高度并缓存使用新 api：ResizeObserver 监听图片尺寸变化，但需要考虑浏览器兼容性IntersectionObserver函数式编程是什么函数式编程是一种编程范式，目标是使用函数来抽象作用在数据之上的控制流与操作，从而在系统中消除副作用并减少对状态的改变，旨在尽可能地提高代码的无状态性和不变性主要思想是把运算过程尽量写成一系列嵌套的函数调用，比如柯里化、react 的高阶函数函数式库：Ramda.js、lodash、RxJS命令模式中 run 函数的好处将函数本身参数化，非侵入式的修改函数，无需重写任何内部逻辑为什么纯函数易于维护：无状态的代码不会改变或破坏全局的状态易于测试：不依赖外部资源的算法灵活便于重用、保持业务逻辑代码的纯净任务分解，一定程度增加代码可读性函数式的控制流能够在不需要研究任何内部细节的条件下提供该程序意图的清晰结构，这样就能更深刻地了解代码，并获知数据在不同阶段是如何流入和流出的多包项目https://juejin.cn/post/6844903568751722509Blob表示二进制类型的大对象，不可变的类似文件对象的原始数据含有两个属性：size 和 type，size 属性表示数据大小（以字节为单位），type 是 MIME 类型的字符串File基于 Blob，继承了 Blob 的功能并将其扩展使其支持用户系统上的文件提供有关文件的信息，并允许网页中的 JavaScript 访问其内容，比如 input 上传文件返回的 FileList 中的元素后端一次给 10 万条数据，如何处理展示直接遍历渲染（耗时最高，不推荐）setTimeout 分页渲染：把 10w 按照每页数量 limit 分成总共 Math.ceil(total / limit)页，然后利用 setTimeout，每次渲染 1 页数据使用 requestAnimationFrame 代替上一条的 setTimeout文档碎片(createDocumentFragment) + requestAnimationFrame懒加载：在列表尾部放一个空节点 blank，等到 blank 出现在视图中（使用 getBoundingClientRect），就说明到底了，这时候再加载第二页，以此类推虚拟列表如何拿到动画帧数https://www.cnblogs.com/coco1s/p/8029582.htmlsourceMap将编译、打包、压缩后的代码映射回源代码的技术由于打包压缩后的代码并没有阅读性可言，一旦在开发中报错或者遇到问题，直接在混淆代码中 debug 问题会带来非常糟糕的体验sourceMap 可以帮助我们快速定位到源代码的位置，提高我们的开发效率需要浏览器支持在压缩代码的末端加上，即可让 sourceMap 生效//# sourceURL=/path/to/file.js.map有了这段注释后，浏览器就会通过 sourceURL 去获取这份映射文件单页应用（SPA）优缺点优点：内容的改变不需要重新加载整个页面，用户体验好相对对服务器压力小前后端职责分离，架构清晰，前端进行交互逻辑，后端负责数据处理缺点：首屏加载慢前进后退路由需要自己管理，不能使用浏览器的前进后退功能SEO（搜索优化）难度大"},{"id":"bc44b152a26aed4e957221c11c5fe52b","isRootIndexFile":false,"isIndexFile":false,"filename":"npm.md","basename":"npm","path":"/home/runner/work/qxtang.github.io/qxtang.github.io/前端","content":"NPMnpm 的使用通过环境变量读取 package.json 中的属性：process.env.npm_package_name获取当前正在运行的 npm script 脚本名称：process.env.npm_lifecycle_event可通过添加 pre- 和 post- 前缀声明钩子脚本使用 link 调试本地包npm run 新建的 Shell 环境，会将当前目录的 node_modules/.bin 加入 PATH 环境变量，执行结束后，再将 PATH 环境变量恢复，这意味着，当前目录的 node_modules/.bin 子目录里面的所有脚本，都可以直接用脚本名调用，而不必加上路径或者 npxscript 中可通过 $npm_config_tag 获取 shell 中的配置值；如果 env 环境变量中存在以 npm_config_* 为前缀的环境变量，则也会被识别为 npm 的配置属性；以及各个级别的 .npmrc 配置文件npm run serve --params  // 参数params将转化成process.env.npm_config_params = truenpm run serve --params=123 // 参数params将转化成process.env.npm_config_params = 123npm version patch升级小版本，还会默认执行 git add-&gt;git commit-&gt;git tag 操作，也可以通过配置禁止这一默认行为查看所有可用命令：npm runnpm cinpm ci 只根据 package-lock.json 来安装包，而 npm install 在安装的过程中会结合 package.json 和 package-lock.json 来计算依赖包版本的差异性问题。所以相比较 npm install，npm ci 既能提升包的安装速度，又能避免在生产化境中出现包版本不一致的问题如果项目中已经存在 node_modules，npm ci 将会先删除它，然后再安装如果检测到 package.json 和 package-lock.json 中的依赖项不匹配的话，npm ci 将退出并报错，而不是更新两个文件中的版本号要求项目中必须具有 package-lock.json 或 npm-shrinkwrap.json，否则执行 npm ci 将会报错npm ci 只能一次安装整个项目的依赖包，而不能为项目安装单个依赖包npx直接运行 node_modules/.bin 目录下的可执行文件npx 想要解决的主要问题，就是调用项目内部安装的模块，可以避免全局安装模块npx 的原理很简单，就是运行的时候，会到 node_modules/.bin 路径和环境变量 PATH 里面，检查命令是否存在。由于 npx 会检查环境变量 PATH，所以系统命令也可以调用npm 检查配置的优先级项目级的 .npmrc 文件 &gt; 用户级的 .npmrc 文件 &gt; 全局级的 .npmrc &gt; npm 内置的 .npmrc 文件package-lock.json、yarn.lock 的作用锁定安装时的包的版本号，并且需要上传到 git，以保证其他人在 npm install 时大家的依赖能保证一致package.json 文件只能锁定大版本，也就是版本号的第一位，并不能锁定后面的小版本，你每次 npm install 都是拉取的该大版本下的最新的版本，为了稳定性考虑我们几乎是不敢随意升级依赖包的，这将导致多出来很多工作量，测试/适配等，所以 package-lock.json 文件出来了，当你每次安装一个依赖的时候就锁定在你安装的这个版本。npm install 流程检查项目中是否有 package-lock.json 文件如果有， 检查 package-lock.json 和 package.json 声明的依赖是否一致：一致， 直接使用 package-lock.json 中的信息，从网络或者缓存中加载依赖不一致， 根据上述流程中的不同版本进行处理如果没有， 那么会根据 package.json 递归构建依赖树，然后就会根据构建好的依赖去下载完整的依赖资源，在下载的时候，会检查有没有相关的资源缓存:存在， 直接解压到 node_modules 文件中不存在， 从 npm 远端仓库下载包，校验包的完整性，同时添加到缓存中，解压到 node_modules 中最后， 生成 package-lock.json 文件在我们实际的项目开发中，使用 npm 作为团队的最佳实践: 同一个项目团队，应该保持 npm 版本的一致性。如果希望一个模块不管是否安装过，npm 都要强制重新安装，可以使用 -f 或–force 参数npm 的缺点包之间相互依赖，导致嵌套地狱，会形成一棵巨大的依赖树依赖层级过深，有问题不利于排查和调试安装结果占据大量空间资源，安装时间长yarn 解决的问题采用模块扁平化的安装模式: 将不同版本的依赖包，按照一定的策略，归结为单个版本；以避免创建多个版本造成工程的冗余（目前版本的 npm 也有相同的优化）网络性能更好: yarn 采用了请求排队的理念，类似于并发池连接，能够更好的利用网络资源；同时也引入了一种安装失败的重试机制采用缓存机制，实现了离线模式 （目前的 npm 也有类似的实现）依赖包版本号采用了 semver 规范作为依赖版本管理方案一般格式：主版本号.次版本号.修订号（x.y.z）package.json参考：https://docs.npmjs.com/cli/v8/configuring-npm/package-jsonbin：表示的是一个可执行文件到指定文件源的映射&quot;bin&quot;: {  &quot;someTool&quot;: &quot;./bin/someTool.js&quot;}file：需要上传 npm 的文件，一般设置只上传编译产物，加快下载包的速度main：指定加载的入口文件browser：定义 npm 包在 browser 环境下的入口文件。如果 npm 包只在 web 端使用，并且严禁在 server 端使用，使用 browser 来定义入口文件module：定义 npm 包的 ESM 规范的入口文件，browser 环境和 node 环境均可使用。如果 npm 包导出的是 ESM 规范的包，使用 module 来定义入口文件man：指定帮助文档typings：指定 TypeScript 的入口文件dependenciesdependencies最终上线或者发布 npm 包时所需要，例如 vue 框架、UI 组件库发布 npm 包的时候，包中的 dependencies 依赖项在安装该包的时候会被一起下载，devDependencies 依赖项则不会devDependencies开发和测试时需要，例如打包工具、css 预处理器、测试框架等peerDependencies如果你安装我，那么你最好也要按照我的要求安装 A、B 和 C可以用来防止多次引入相同的库optionalDependencies这种依赖中的依赖项即使安装失败了，也不影响整个安装的过程如果一个依赖同时出现在 dependencies 和 optionalDependencies 中，那么 optionalDependencies 会获得更高的优先级在实际项目中，如果某个包已经失效，我们通常会寻找它的替代者，或者换一个实现方案。不确定的依赖会增加代码判断和测试难度，所以这个依赖项还是尽量不要使用版本号第一部分为主版本号，变化了表示有了一个不兼容上个版本的大更改第二部分为次版本号，变化了表示增加了新功能，并且可以向后兼容第三部分为修订版本号，变化了表示有 bug 修复，并且可以向后兼容第四部分为日期版本号加希腊字母版本号，希腊字母版本号共有五种，分别为 base、alpha、beta、RC、release希腊版本号Base此版本表示该软件仅仅是一个假页面链接，通常包括所有的功能和页面布局，但是 页面中的功能都没有做完整的实现，只是做为整体网站的一个基础架构。Alpha软件的初级版本，表示该软件在此阶段以实现软件功能为主，通常只在软件开发者 内部交流，一般而言，该版本软件的 Bug 较多，需要继续修改，是测试版本。测试 人员提交 Bug 经开发人员修改确认之后，发布到测试网址让测试人员测试，此时可 将软件版本标注为 alpha 版。Beta该版本相对于 Alpha 版已经有了很大的进步，消除了严重错误，但还需要经过多次 测试来进一步消除，此版本主要的修改对象是软件的 UI。修改的的 Bug 经测试人 员测试确认后可发布到外网上，此时可将软件版本标注为 beta 版。RC该版本已经相当成熟，基本上不存在导致错误的 Bug，与即将发行的正式版本相差无几。Release该版本意味“最终版本”，在前面版本的一系列测试版之后，终归会有一个正式的版本，是最终交付用户使用的一个版本。该版本有时也称标准版。版本号的写法version 必须确切匹配这个 version&gt;version 必须大于这个 version&gt;=version 必须大于等于这个 version&lt;version 必须小于这个 version&lt;=version 必须小于等于这个 version~version 大约相当于 version^version 与 version 兼容1.2.x 可以是 1.2.0、1.2.1 等，但不能是 1.3.0http://... URL 作为依赖项* 匹配任何版本&quot;&quot;(空字符串) 匹配任何版本，和 * 一样version1 - version2 相当于 &gt;=version1 &lt;=version2range1 || range2 range1 或 range2 其中一个满足时采用该 versiongit... Git URL 作为依赖项user/repo GitHub URLstag 一个以 tag 发布的指定版本，参考 npm-tagpath/path/path 本地 Paths域级包管理以@开头的包名由于用@声明了该包，npm 会默认将此包认定为私有包，而在 npm 上托管私有包是需要收费的，所以为了避免发布私有包，可以在发布时添加--accss=public 参数告知 npm 这不是一个私有包域级包不一定就是私有包，但是私有包一定是一个域级包在安装域级包时需要按照域级包全名来安装：npm install @scopeName/package发布一个支持 tree shaking 机制的包tree shaking 是依赖 ES Module 的模块特性来工作的，那是因为 ES Module 模块的依赖关系是在编译时确定的（和运行时无关），并且之后不能再改变，所以基于此特性可以进行可靠的静态分析设置 module 字段：该字段指向一个既符合 ES Module 模块规范但是又使用 ES5 语法的源文件。这么做的目的是为了启动 tree shaking 的同时，又避免代码兼容性的问题{  &quot;main&quot;: &quot;./lib/index.js&quot;, // 指向 CommonJS 模块规范的代码入口文件  &quot;module&quot;: &quot;./lib/index.es.js&quot; // 指向 ES Module 模块规范的代码入口文件}如上配置要求你的包中要发布两种模块规范的版本。如果你的 npm 环境支持 module 字段，则会优先使用 ES Module 模块规范的入口文件，如果不支持则会使用 CommonJS 模块规范的入口文件。其实要想发布一个支持 tree shaking 机制的包，最主要是要构建出一个符合 module 字段要求的源文件，也就是一个既符合 ES Module 模块规范但是又采用 ES5 语法的源文件。rollup 可以直接构建出符合 ES Module 模块规范的文件，但是 webpack 不能。所以我们只需要使用 rollup 提供的构建能力，在配置文件中把 output 的格式设置为 es 即可为了更好地使用 ES Module 模块规范来开启 tree shaking 功能，优先选用 rollup 来开发 npm 包基于 ES6 模块规范是为了用户在使用我们的包时可以享受 Tree Shaking 带来的好处；使用 ES5 语法书写是为了用户在配置 babel 插件时可以放心的屏蔽 node_modules 目录参考https://www.ruanyifeng.com/blog/2016/10/npm_scripts.html"},{"id":"3ff5cf28589df4ccb00f03ce76edf16c","isRootIndexFile":false,"isIndexFile":false,"filename":"事件循环.md","basename":"事件循环","path":"/home/runner/work/qxtang.github.io/qxtang.github.io/前端","content":"事件循环是什么js 是设计成单线程的，为了更好的处理异步任务，所以设计了事件循环机制js 为什么是单线程与 js 的用途有关如果 js 被设计了多线程，如果有一个线程要修改一个 dom 元素，另一个线程要删除这个 dom 元素，渲染器就不知道以哪个线程为准，DOM 渲染的结果不可预期多线程具有复杂性，编码的复杂性会增高为了利用多核 CPU 的计算能力，HTML5 提出 Web Worker 标准，允许 JavaScript 脚本创建多个线程，但是子线程完全受主线程控制，且不得操作 DOM。所以，这个新标准并没有改变 JavaScript 单线程的本质同步任务和异步任务JavaScript 单线程任务分为同步任务和异步任务JavaScript 有一个主线程（js 引擎线程）和调用栈（执行栈），所有的任务都会被放到调用栈等待主线程执行，同步任务会在调用栈中按顺序依次执行，异步任务会在异步任务有了结果后，将注册的回调函数放入任务队列中，等待主线程空闲的时候（调用栈被清空），被读取到栈内等待主线程的执行在遇到异步任务时（setTimeout、DOM 事件、ajax 等），会转交给浏览器的其他工作线程（事件触发线程、定时器线程）执行，执行完之后将回调函数放入到任务队列事件触发线程管理一个任务队列，调用栈中的代码调用某些异步 API 时会在任务队列中添加事件，异步任务触发条件达成，将回调事件放到任务队列中当主线程的任务执行完了（执行栈空了），js 会去询问事件队列有没有回调函数需要执行（所以 setTimeout 0 会等到最后才执行）如此循环往复，形成事件循环机制事件循环不一定每轮都伴随着重渲染，但是如果有微任务，一定会伴随着微任务执行宏任务和微任务异步任务队列又分微任务队列和宏任务队列宏任务是由宿主发起的，而微任务由 JavaScript 自身发起宏任务（多为运行环境 api）：script 标签中的代码、UI 渲染、UI 交互、setTimeout/setInterval/setImmediate、DOM 事件、postMessage、ajax 请求、requestAnimationFrame宏任务代表一个个离散的、独立工作单元，运行完任务后，浏览器可以继续其他调度，如重新渲染页面的 UI 或执行垃圾回收微任务（多为语法）：Promise.then\\catch\\finally、MutationObserver、async/await、process.nextTick（NodeJS）微任务更新应用程序的状态，但必须在浏览器任务继续执行其他任务之前执行，浏览器任务包括重新渲染页面的 UI。微任务的案例包括 promise 回调函数、DOM 发生变化等。微任务需要尽可能快地、通过异步方式执行，同时不能产生全新的微任务。微任务使得我们能够在重新渲染 UI 之前执行指定的行为，避免不必要的 UI 重绘，UI 重绘会使应用程序的状态不连续两者区别：宏任务：DOM 渲染后触发微任务：DOM 渲染前触发当满足执行条件时，宏任务(macroTask) 和 微任务(microTask) 会各自被放入对应的队列：宏队列(Macrotask Queue) 和 微队列(Microtask Queue) 中等待执行事件循环流程先会执行主进程栈中的内容，栈中的内容执行后执行微任务，微任务清空后再执行宏任务，先取出一个宏任务，再去执行微任务，然后在取宏任务清微任务这样不停的循环while (true) {  queue = getNextQueue(); // 如果是多队列情况则取一个队列  task = queue.pop(); // 取第一个任务  execute(task); // 执行任务  // 如果有微任务那么执行所有的微任务  while (microTasks.hasTasks()) {    doMicroTask();  }  // 浏览器渲染阶段  if (isRepaintTime()) {    // 动画队列有任务 那么执行所有动画 task(requestAnimationFrame)    animationTasks = animationQueue.copyTasks();    for (task in animationTasks) {      doAnimationTask(task);    }    // 绘制    repaint();  }}当主线程结束，从宏任务队列中，按照入队顺序，找到第一个执行的宏任务，放入调用栈，开始执行执行完该宏任务下所有同步任务后，即调用栈清空后，该宏任务被推出宏任务队列，然后微任务队列开始按照入队顺序，依次执行其中的微任务，直至微任务队列清空当微任务队列清空后，一个事件循环结束接着从宏任务队列中，找到下一个执行的宏任务，开始第二个事件循环，直至宏任务队列清空为止当微任务队列处理完成并清空时，事件循环会检查是否需要更新 UI 渲染，如果是，则会重新渲染 UI 视图单次循环迭代中，最多处理一个宏任务（其余的在队列中等待），而队列中的所有微任务都会被处理为什么微任务执行更早微任务是语法规定的宏任务执行时间一般比较长宏任务是由浏览器规定的（web api）每一次宏任务开始之前一定是伴随着一次 event loop 结束的，而微任务是在一次 event loop 结束前执行的页面渲染每次当一次事件循环结束后，即一个宏任务执行完成后以及微任务队列被清空后，浏览器就会进行一次页面更新渲染。通常我们浏览器页面刷新频率是 60fps，也就是意味着 16.67ms 要刷新一次，因此我们也要尽量保证一次事件循环控制在 16.67ms 之内，这也是我们需要做代码性能优化的一个原因。requestAnimationFrame 在重新渲染屏幕之前执行，非常适合用来做动画resize 和 scroll 事件其实自带节流，它只在 Event Loop 的渲染阶段去派发事件到 EventTarget 上执行 setTimeout/setInterval 时发生了什么JS 引擎线程通知定时触发器线程，间隔一个时间后，会触发一个回调事件， 而定时触发器线程在接收到这个消息后，会在等待的时间后，将回调事件放入到由事件触发线程所管理的事件队列中执行 XHR/fetch 时发生了什么JS 引擎线程通知异步 http 请求线程，发送一个网络请求，并制定请求完成后的回调事件， 而异步 http 请求线程在接收到这个消息后，会在请求成功后，将回调事件放入到由事件触发线程所管理的事件队列中参考https://juejin.cn/post/6844904165462769678https://juejin.cn/post/6844903919789801486"},{"id":"41b3d5a5ac6bcb3574744656d48dd9fd","isRootIndexFile":false,"isIndexFile":false,"filename":"图标方案.md","basename":"图标方案","path":"/home/runner/work/qxtang.github.io/qxtang.github.io/前端","content":"图标方案https://juejin.cn/post/6844903517564436493"},{"id":"8ba6f50880e02e2228ef3d5d8946c449","isRootIndexFile":false,"isIndexFile":false,"filename":"微前端.md","basename":"微前端","path":"/home/runner/work/qxtang.github.io/qxtang.github.io/前端","content":"微前端微前端不一定是一种新技术，也不必太复杂。只要我们保证代码隔离和团队自治，无论我们采用何种技术栈，我们都可以达到相同的效果由来工程越来越大，打包越来越慢团队人员多，产品功能复杂，代码冲突频繁、影响面大在后端服务开发中，为了解决庞大的一整块后端服务带来的变更与扩展方面的限制，出现了微服务架构把应用程序设计成一系列松耦合的细粒度服务允许使用不同的编程语言来编写不同服务前端也出现这样的问题，即，一种由独立交付的多个应用组成整体的架构风格。将前端应用分解成一些更小更简单的能够独立开发、测试、部署的小块，而在用户看来仍然是内聚的单个产品比起一整块的前端代码库，微前端架构下的代码库倾向于更小/简单、更容易开发传统开发的缺点历史项目，祖传代码交付压力，当时求快就近就熟，当时求稳导致技术栈落后，甚至强行混用多种技术栈，耦合混乱，不敢动，牵一发动全身每个微前端都应具备有自己的持续交付流水线（包括构建、测试并部署到生产环境），且要能独立部署，不必过多考虑其它代码库的状态意义技术栈无关，主框架不限制接入应用的技术栈，微应用具备完全自主权独立开发、独立部署，微应用仓库独立，前后端可独立开发，部署完成后主框架自动完成同步更新增量升级，在面对各种复杂场景时，我们通常很难对一个已经存在的系统做全量的技术栈升级或重构，而微前端是一种非常好的实施渐进式重构的手段和策略独立运行时，每个微应用之间状态隔离，运行时状态不共享微前端架构旨在解决单体应用在一个相对长的时间跨度下，由于参与的人员、团队的增多、变迁，从一个普通应用演变成一个巨石应用后，随之而来的应用不可维护的问题。这类问题在企业级 Web 应用中尤其常见。技术方案package 集成将每个微前端发布为一个 npm 包，并让容器应用程序将所有微前端应用作为依赖项这意味着只要有一个包更新，即使是小版本，宿主也要重新构建一次。不建议使用这种方案iframe优点：隔离得很彻底缺点：速度慢，浏览器处理 iframe 要启动更多的进程；页面刷新难以保存状态，路由、历史记录等等使用 umd 包通过 script 标签引入放在 cdn 上的资源，可以始终保持最新，子应用更新不需要通知宿主具有完全的灵活性，宿主可以控制什么时候载入每个应用，以及渲染应用时额外传参数vite 库模式：https://cn.vitejs.dev/guide/build.html#library-mode微前端架构存在的一些普遍问题下载量独立构建的 JavaScript 文件可能导致重复的公共依赖，从而增加用户的下载量例如，如果每个微应用都包括自己的 React 副本，那么用户就得多次下载 React环境差异在本地开发时无法把所有微应用和对应的后端都启动起来，不得不在本地进行环境的简化。如果开发环境和生产环境不严谨一致，容易造成问题。如果开发者想要完全模拟生产环境，会比较耗时治理复杂性要管理更多的东西：更多的代码库、更多的工具、更多的构建管道、更多的服务器、更多的域名等"},{"id":"44b01ff35878b7a548bb3550acb75dd2","isRootIndexFile":false,"isIndexFile":false,"filename":"文件上传&下载.md","basename":"文件上传&下载","path":"/home/runner/work/qxtang.github.io/qxtang.github.io/前端","content":"文件上传&amp;下载下载流式文件axios 请求配置 responseType 设为 blob使用开源工具 FileSaver 进行保存判断文件类型使用开源工具：https://github.com/sindresorhus/file-typeinput 元素 accept 属性只根据文件后缀名进行拦截，用户手动修改可以绕过可以通过读取文件中的二进制数据来识别正确的文件类型：https://juejin.cn/post/6971935704938971173对于某一些类型的文件，起始几个字节内容都是固定的，根据这几个字节的内容可以判断文件类型，可通过 FileReader API 来读取实现大文件并发上传参考：https://mp.weixin.qq.com/s/-iSpCMaLruerHv7717P0Wg并发控制结合 Blob.slice获取待上传文件计算文件 md5 值发起 get 请求判断文件是否已存在不存在则执行上传，并发上传分块，并通知后端实现大文件并行下载参考：https://mp.weixin.qq.com/s?__biz=MzI2MjcxNTQ0Nw==&amp;mid=2247490849&amp;idx=1&amp;sn=9d062c04baeb629d9b69a9fb4e7c3599&amp;scene=21使用 http 范围请求的特性先发送一个 head 类型的请求，从响应头中读取 Content-Length，获取文件大小参考https://juejin.cn/post/6980142557066067982https://juejin.cn/post/6989413354628448264"},{"id":"e72218e1e3f0fdc8683b4540827fdad0","isRootIndexFile":false,"isIndexFile":false,"filename":"柯里化.md","basename":"柯里化","path":"/home/runner/work/qxtang.github.io/qxtang.github.io/前端","content":"柯里化把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术意义让人们将关注的重点聚焦到函数本身，而不因冗余的数据参数分散注意力，单一参数的纯函数是最简单的，目的单纯、职责单一、灵活且通用减少耦合增强其可维护性缺点过度使用会占用较大的堆栈空间经过柯里化之后，函数的通用性有所降低，但是适用性有所提高实现// 手写柯里化const add = function (a, b, c) {  return a + b + c;};function curry(fn) {  return function curryFun(...args) {    if (args.length &lt; fn.length) {      return function () {        return curryFun([...args, ...arguments]);      };    }    return fn(...args);  };}const curried = curry(add);const a = curried(1)(9)(3);const b = curried(2, 8)(6);console.log({ a, b });参考https://zh.javascript.info/currying-partials"},{"id":"02653b44d2914e17a51d045920b2eb60","isRootIndexFile":false,"isIndexFile":false,"filename":"设计稿多端适配方案.md","basename":"设计稿多端适配方案","path":"/home/runner/work/qxtang.github.io/qxtang.github.io/前端","content":"设计稿多端适配方案如何让不同尺寸的屏幕能以正常比例呈现设计稿？动态修改 font-size + rem 方案动态修改 html 标签 font-size，样式单位统一用 rem，数值为设计稿尺寸除以 basevar fn = function () {  var designWidth = 1920; // 设计稿尺寸  var base = 16; // 1rem 的占比，不要小于 12  var html = document.getElementsByTagName(&#x27;html&#x27;)[0];  var clientWidth = document.body.clientWidth || document.documentElement.clientWidth;  html.style.fontSize = (clientWidth / designWidth) * base + &#x27;px&#x27;;};document.addEventListener(&#x27;DOMContentLoaded&#x27;, function () {  fn();});window.onresize = function () {  fn();};弊端和根元素 font-size 值强耦合，系统字体放大或缩小时，会导致布局错乱html 文件头部需插入一段 js 代码相较之下，vw 单位兼容性比 rem 稍差，ios8、安卓 4.4 及以上才完全支持。这也是为什么之前 rem 布局一直更流行的原因。目前 ios8、安卓 4.4 以下的用户已经非常少了，caniuse 上面显示，在中国这部分用户只有 1.2%，比例已经非常低了设计稿 px 转 vw 方案（推荐）1vw 表示屏幕宽度的 1%把所有需要适配屏幕大小等比缩放的元素都使用 vw 做为单位。不需要缩放的元素使用 px 做单位举个例子。设计师交付的设计稿宽度是 750px，设计稿上一个标题的 fontSize 标注尺寸是 32px。(32/750)*100% = 4.27% ，换句话说这个标题的字号占屏幕宽度的占比是 4.27%，不管任何屏幕都是如此。4.27% 即 4.27vw。可以使用 post-css 专门的插件做转换，或使用预处理样式语言中的函数@baseScreenWidth: 320;.px2vw(@name, @px) {  @{name}: (@px / @baseScreenWidth) * 100vw;}@function px2vw($px) {  @return $px * 100vw / 750;}// 以iphone7尺寸@2x 750像素宽的视觉稿为例@function vw($px) {  @return ($px / 750) * 100vw;}// 假设一个div元素在视觉稿中，宽度为120px，字体大小为12pxdiv {  width: vw(120);  font-size: vw(12);}dpr 是什么设备像素比，通过 window.devicePixelRatio 获取是设备上物理像素和设备独立像素（dips）的比例，window.devicePixelRatio = 物理像素 / dips简单的讲其实就是 dpr 决定了 css 1px 等于多少屏幕物理像素物理像素显示器上最小的物理显示单元，在操作系统的调度下，每一个设备像素都有自己的颜色值和亮度值设备独立像素（dips）也叫密度无关像素，可以认为是计算机坐标系统中得一个点，这个点代表一个可以由程序使用的虚拟像素（比如: css 像素），然后由相关系统转换为物理像素viewport用于定义视口的各种行为：视口宽度、初始缩放、最小最大缩放比例、是否允许用户手动缩放"},{"id":"f4f2163e7aab97895f81615a4f461428","isRootIndexFile":false,"isIndexFile":false,"filename":"防抖&节流.md","basename":"防抖&节流","path":"/home/runner/work/qxtang.github.io/qxtang.github.io/前端","content":"防抖&amp;节流防抖：n 秒内只执行一次，如果 n 秒内再次触发，则重新计算时间（多用于输入框）节流：多次调用，n 秒内只会执行一次，稀释执行频率手写：const tools = {  debounce: (fn, wait = 500) =&gt; {    let timer = null;    return function () {      if (timer) {        clearTimeout(timer);      }      timer = setTimeout(() =&gt; {        fn.apply(this, arguments);      }, wait);    };  },  throttle: (fn, wait = 500) =&gt; {    let canrun = true;    return function () {      if (!canrun) {        return;      }      canrun = false;      setTimeout(() =&gt; {        fn.apply(this, arguments);        canrun = true;      }, wait);    };  },};"}]},{"id":"079c4846f4492de09e5c456d89c26df5","dirname":"工作沉淀","filename":"","basename":"","path":"/home/runner/work/qxtang.github.io/qxtang.github.io","children":[{"id":"e9a2550e8c53d313e8e31853512a444e","isRootIndexFile":false,"isIndexFile":false,"filename":"Nginx 笔记.md","basename":"Nginx 笔记","path":"/home/runner/work/qxtang.github.io/qxtang.github.io/工作沉淀","content":"Nginx 笔记工作中经常用的，简单记录一下。常用命令nginx 启动nginx -c filename 指定配置文件启动nginx -s stop 快速关闭，可能不保存相关信息，并迅速终止 web 服务nginx -s quit 平稳关闭 Nginx，保存相关信息，有安排的结束 web 服务nginx -s reload 重启nginx -t 测试配置文件nginx -t -c xxx.conf 测试指定配置文件实用配置修改用户# 往往在第一行user root;跨域# 这里约定代理请求url path是以/apis/开头location ^~/apis/ {    # 这里重写了请求，将正则匹配中的第一个()中$1的path，拼接到真正的请求后面，并用break停止后续匹配    rewrite ^/apis/(.*)$ /$1 break;    ...    proxy_pass https://www.tianqiapi.com/;}处理前端单页应用的 history 路由模式location / {    try_files $uri $uri/ /index.html;}适配 PC 和移动环境location / {    # 移动、pc设备适配    if ($http_user_agent ~* &#x27;(Android|webOS|iPhone|iPod|BlackBerry)&#x27;) {        set $mobile_request &#x27;1&#x27;;    }    if ($mobile_request = &#x27;1&#x27;) {        rewrite ^.+ http://mysite-base-H5.com;    }}端口转发http {    ...    upstream dmp8001 {        server 127.0.0.1:8001;    }    server {        listen       80;        server_name  abc.com;        location / {            ...            proxy_pass http://dmp8001;        }    }    ...}善用正则# 动态校验企业微信 h5 应用可信域名location ~ WW_verify_(.*).txt {    return 200 $1;}虚拟主机server {    listen 12332;    server_name 127.0.0.1;    location / {        root D:/Desktop/test;        index index.html index.htm;    }}防媒体文件盗链location ~* \\.(gif|jpg|png|jpeg|mp4)$ {    expires 30d;    valid_referers *.hugao8.com www.hugao8.com m.hugao8.com *.baidu.com *.google.com;    if ($invalid_referer) {        rewrite ^/ http://ww4.sinaimg.cn/bmiddle/051bbed1gw1egjc4xl7srj20cm08aaa6.jpg;        # return 404;    }}简单实现负载均衡轮询（默认），请求过来后，Nginx 随机分配流量到任一服务器upstream backend {    server 127.0.0.1:3000;    server 127.0.0.1:3001;}weight=number 设置服务器的权重，默认为 1，权重大的会被优先分配upstream backend {    server 127.0.0.1:3000 weight=2;    server 127.0.0.1:3001 weight=1;}backup 标记为备份服务器。当主服务器不可用时，将传递与备份服务器的连接upstream backend {    server 127.0.0.1:3000 backup;    server 127.0.0.1:3001;}代理这个集群server {    listen      9000;    server_name localhost;    location / {        proxy_set_header Host $http_host;        proxy_set_header X-Real-IP $remote_addr;        proxy_set_header X-Scheme $scheme;        proxy_pass backend;    }}关于 location 的匹配location 的几种匹配方式普通匹配：location = URI { configuration } #精确匹配location ^~ URI { configuration } #非正则匹配location [空格] URI { configuration } #前缀匹配正则匹配：location ~ URI { configuration } #区分大小写location ~* URI { configuration } #不区分大小写几种匹配方式的说明与优先级整体规则按照先普通匹配，然后再正则匹配，如果正则不匹配，则回退至上一个普通匹配。其中普通匹配没有顺序之分，哪个匹配最精确，就使用哪个 location，正则匹配按照规则的书写顺序进行。= 精确匹配，匹配后停止后续匹配，直接执行该匹配后的 configuration。[空格] 前缀匹配，匹配后，继续更长前缀匹配和正则匹配。^~ 不属于正则匹配，匹配该规则后，停止继续正则匹配。~ 区分大小写的正则匹配，按顺序匹配，一旦匹配即停止后续匹配。~* 不区分大小写的正则匹配，按顺序匹配，一旦匹配即停止后续匹配。示例location = / {    [ configuration A ]}location / {    [ configuration B ]}location /user/ {    [ configuration C ]}location ^~ /images/ {    [ configuration D ]}location ~* \\.(gif|jpg|jpeg)$ {    [ configuration E ]}请求/精准匹配 A，不再往下查找。请求/index.html匹配 B。首先查找匹配的前缀字符，找到最长匹配是配置 B，接着又按照顺序查找匹配的正则。结果没有找到，因此使用先前标记的最长匹配，即配置 B。请求/user/index.html匹配 C。首先找到最长匹配 C，由于后面没有匹配的正则，所以使用最长匹配 C。请求/user/1.jpg匹配 E。首先进行前缀字符的查找，找到最长匹配项 C，继续进行正则查找，找到匹配项 E。因此使用 E。请求/images/1.jpg匹配 D。首先进行前缀字符的查找，找到最长匹配 D。但是，特殊的是它使用了^~修饰符，不再进行接下来的正则的匹配查找，因此使用 D。这里，如果没有前面的修饰符，其实最终的匹配是 E。大家可以想一想为什么。请求/documents/about.html匹配 B。因为 B 表示任何以/开头的 URL 都匹配。在上面的配置中，只有 B 能满足，所以匹配 B。总结location 的配置有两种形式，普通和正则。查找匹配的时候，先查找普通，选择最长匹配项，再查找正则。正则的优先级高于普通。正则查找是按照在配置文件中的顺序进行的，因此正则顺序很重要，建议越精细的放的越靠前。使用=精准匹配可以加快查找的效率，如果经常被访问建议使用精确匹配=。"},{"id":"54b845f50c1324aaf0f2dd2ef2f8b63a","isRootIndexFile":false,"isIndexFile":false,"filename":"adb 通过 wifi 调试微信 h5.md","basename":"adb 通过 wifi 调试微信 h5","path":"/home/runner/work/qxtang.github.io/qxtang.github.io/工作沉淀","content":"adb 通过 wifi 调试微信 h5手机和 pc 连接在同一 wifi 环境下手机启用开发者选项和无线调试模式手机选择&quot;使用配对码配对设备&quot;，pc 执行 adb pair {配对ip}:{配对端口}，输入手机给的配对码pc 执行 adb connect {无线调试ip}:{无线调试端口}微信打开 http://debugxweb.qq.com/?inspector=true，是微信客户端的内置域名，开启微信的远程调试功能即可通过 chrome 的 Remote debugging 功能进行调试参考https://developer.android.com/studio/command-line/adb?hl=zh-cn#connect-to-a-device-over-wi-fi"},{"id":"9a1c4aed7641d47c0fe0fe7b0d1c54bb","isRootIndexFile":false,"isIndexFile":false,"filename":"web 应用登录方案.md","basename":"web 应用登录方案","path":"/home/runner/work/qxtang.github.io/qxtang.github.io/工作沉淀","content":"web 应用登录方案cookie + session仅 jwt后端直接签发 jwt，后端不存储缺点：一旦下发，后端无法拒绝携带该 jwt 的请求，无法踢除用户jwt + redis后端备份一份 token 存入 redis，请求进来时，使用前端传来的 jwt 从 redis 查询出对应 token，做对比若 redis 中的 token 过期或不存在则视为无权限长短 token首次登录设置两个 token，都保存进 redisaccess_token：标准 JWT 格式，即请求时的授权令牌，过期时间较短，一般 2 个小时，redis key：uuid-access，value：jwtrefresh_token：用于刷新 access_token，过期时间较长，一般 1 个月，redis key：uuid-refresh，value：jwt添加凭 refresh_token 刷新 access_token 的接口前端请求封装先发起请求，如果接口返回 access_token 过期，先刷新 access_token，再进行一次重试为了让活跃用户保持登录，其他方案频繁续签会有性能问题，该方案解决此问题实践中遇到的问题前端请求刷新 token 有延迟，如何防止多次请求同时发起多次刷新 token请求封装中设置刷新 token 防抖锁，如果一次刷新任务进行中，则其他刷新请求取消同时发起多个请求时，access_token 正好过期，同时多次提示无权限请求封装中，如果刷新 token 锁处于关闭状态，则把请求任务保存进一个数组，等待锁打开再执行密码保存哈希加盐哈希函数：单向不可逆加密算法直接哈希的缺陷有可能被查表法、逆向查表法、彩虹表等方式破解首先将一些比较常用的密码的哈希值算好，然后建立一张表，当然密码越多，这张表就越大。当你知道某个密码的哈希值时，你只需要在你建立好的表中查找该哈希值，如果找到了，你就知道对应的密码了加盐盐就是一个随机生成的字符串将盐与原始密码连接在一起（前或后都可以），然后将连接后的字符串加密盐和加密后的密码一起保存进数据库登录时将盐和密码都查出来，前端传来的密码同样算法加密后进行比对直接 md5 加密保存不可逆加密算法，输入任意长度的信息，经过处理，输出都是 128 位的信息值小于 8 位的密码用 md5 加密不安全"},{"id":"a7aff4b7b9eea3d879a7aad0c984a6fb","isRootIndexFile":false,"isIndexFile":false,"filename":"为什么前端团队要统一技术栈.md","basename":"为什么前端团队要统一技术栈","path":"/home/runner/work/qxtang.github.io/qxtang.github.io/工作沉淀","content":"为什么前端团队要统一技术栈公司前端团队建议应该尽可能统一技术栈、统一开发框架。不统一开发框架的弊端断崖效应：团队决策者通常会从自身利益考量，希望尽量减少对外部门的依赖，无论是技术选型，规范建立，组件选取，运行环境都能够自行掌控，项目技术栈由单个员工决定的话，单个员工对单个项目的影响变的非常巨大。一个产品经常会因为一两个核心员工的离职难以为继，最后不得不重新开发新的产品。当一位核心员工构建了一些基础的平台工具后，往往随着他的离开把之前的技术积累全部丢弃掉，而更严重的情况会导致整个项目的持续运行都成了问题，比如有的前端会自己偷偷开发一个 npm 包做为项目依赖。统一开发框架的优势避免重复性技术研究，节约人力成本，让项目组把精力更多的投入到业务中。标准化技术规范，提升产品项目质量。要千人一面，而不要千人千面。采用统一的开发框架（平台）后，在技术栈，技术组件，技术实现方案，甚至在代码规范上就能形成标准化的技术输出模式，标准化带来的最大效果不仅仅是开发效率的快速提升，还有产品质量的大幅提升，这是显而易见的。进行技术沉淀，提升公司整体技术能力，避免陷入一个人的能力决定一个项目。当存在公司级别的统一开发框架（平台），项目团队基于该平台进行自身项目的研发，不再需要关注于底层技术实现，只需要关注业务即可。当存在核心同事离职时，平台的研发同事可以对新进入项目的同事进行相关培训，不会导致青黄不接的事情发生。而且，专注于平台的同事为了更好的满足项目组的技术需求，对平台进行不断的改进，从而达到技术积累和沉淀的目标。参考https://juejin.cn/post/6844903925947039757"},{"id":"a4f7292ddc0b242295c286032c06ed31","isRootIndexFile":false,"isIndexFile":false,"filename":"前后端鉴权策略.md","basename":"前后端鉴权策略","path":"/home/runner/work/qxtang.github.io/qxtang.github.io/工作沉淀","content":"前后端鉴权策略待完善"},{"id":"15c0a89ff7639100c849b3d0090fd083","isRootIndexFile":false,"isIndexFile":false,"filename":"动态校验企微应用可信域名.md","basename":"动态校验企微应用可信域名","path":"/home/runner/work/qxtang.github.io/qxtang.github.io/工作沉淀","content":"动态校验企微应用可信域名在企业微信后台创建自己的自建应用时，如应用页面需使用微信 JS-SDK、跳转小程序等，需完成域名归属验证，需要下载校验文件到自己服务器的根目录下，并能够通过 [自己的域名]/[校验文件名] 访问，以完成校验，如果有很多不同的企业需要安装你的应用，那么每一次安装都需要上传一遍校验文件，很麻烦，一次偶然，我将下载下来的校验文件打开，发现文件名与文件内容是有匹配的：也就是说，当企微请求 [自己的域名]/WW_verify_[随机串].txt 时，我们的服务器能将 随机串 响应给企微就可以通过校验，使用 nginx 的正则表达式能力，就可以轻松实现，匹配请求路径中 WW_verify_ 与 .txt 之间的内容，直接返回，location ~ WW_verify_(.*).txt {  return 200 $1;}"},{"id":"b4baff14e4c3095efd4ef6a7d801ab1e","isRootIndexFile":false,"isIndexFile":false,"filename":"迭代流程规范.md","basename":"迭代流程规范","path":"/home/runner/work/qxtang.github.io/qxtang.github.io/工作沉淀","content":"迭代流程规范待完善业务流程阶段总览产品研发阶段做市场调研根据调研结果决定是否设计和开发新的产品（或进行产品改良）研发/发布日常运营/运维阶段产品发布上线后，通过各类运营手段和运维手段向客户提供符合需求的、高可用的产品与服务运营常见的活动有拉新、留存、促活等。运维常见的活动有容量规划与实施、服务集群维护、系统容错管理等售后服务阶段主要由客服人员或售后工程师主导，包括解答或解决用户在使用产品后产生的疑问和投诉等产品研发流程规范大体分为需求阶段、研发阶段、测试阶段、发布阶段关键角色项目经理日常的项目管理、流程规范制定等工作一般由项目经理来主导如果没有设置项目经理这样的角色，流程规范的制定由各协同方共同商议决定，其中产品研发流程的规范绝大多数都由测试部门主导制定，一般由测试部门编写初稿，与协同部门共同商议后确定产品经理责对需求进行分析、编写需求文档、组织需求文档的评审、协调项目资源、对交付结果进行验收等工作研发人员负责编写技术设计方案、编码（包括与协同方联调和自测），把交付物提交给测试人员进行测试测试完成后把交付物发布到线上（发布人员可能有测试人员/研发人员等）质量保障人员（Qualtiy Assurance，简称 QA，很多时候通俗表达为测试人员）负责确保该需求的交付物符合产品需求关键原则微服务架构下，一个业务所具有的微服务数量多，服务与服务之间存在着复杂的交互关系不同服务分布在不同的团队中维护，一个需求通常需要多个微服务团队参与开发，基于这样的背景，在制定流程规范时会有如下考虑：各职能角色必须有 Owner 角色一个小型需求的产品研发过程，需要产品经理、研发人员和测试人员等角色的协同。一个大型需求，往往是由几个小型需求组成，同一个职能角色之间会有多个人员进行协同，因此，为了有利于协同，降低协同风险，应在每一个角色中设置 Owner 角色。基于此，Owner 角色在一定程度上需要有一些项目管理的意识、知识和技能。重评审和讨论，群策群力产品研发过程是一个脑力密集型的工作，复杂度高，大量的实践统计表明，在大规模软件开发中超过 50% 的错误来自需求分析和技术设计阶段。为了最大程度地降低风险，在其流程中需要加大评审和讨论环节的投入，通过多方审查的机制来保证过程质量、提高研发效率，所以，需求阶段和研发阶段的早期流程应有好的规范。前紧后松，提前应对风险高速迭代的研发过程，需要在研发过程的早期，前置发现更多的问题，使后面过程更顺畅，尽量达到“前紧后松”的效果，以降低研发过程的复杂度和风险。关键节点严格把控产品研发的子阶段之间体现了承上启下的作用，主导方会发生变化，所以对这些节点要严格把控，避免将风险和问题遗漏到以后解决。规范制定&amp;落地规范的制定没有特定的频率限制，通常情况下，在刚开始进行产品研发时会制定一个粗颗粒度的规范。在之后的项目过程中，出现了现有规范不能解决的问题，则会先商讨出来解决方案，再逐步把相应的流程规范明确下来。一个规范制定出来后，首先优先在测试部门内部进行评审，然后再与协同方达成共识，最后按照一定的节奏开始推广执行。在将规范进行落地后，应不断跟进执行情况，针对执行不到位的地方进行分析和改进，形成 PDCA 循环PDCA 循环（戴明环）全面质量管理的思想基础和方法依据含义：将质量管理分为四个阶段：Plan(计划)、Do(执行)、Check(检查)、Action(处理)在质量管理活动中，要求把各项工作按照作出计划、计划实施、检查实施效果，然后将成功的纳入标准，不成功的留待下一循环去解决。这一工作方法是质量管理的基本方法，也是企业管理各项工作的一般规律规范呈现泳道图产品研发阶段需求阶段：产品需求评审需求文档通常的表现形式是产品需求文档（PRD）或市场需求文档（MRD），它们也是技术设计文档和测试设计文档的重要输入确保对于需求的说明没有二义性应满足如下质量要求：完备性：需求是否包含了所有正常场景，对异常场景的考虑是否足够，UI 设计图和提示信息等是否完整、友好易理解：需求的表述是否具有二义性，是否使用了结构化的描述，流程类需求是否具有清晰的流程图可行性：需求中的功能是否具有可操作性，能否通过现有的技术实现一致性：需求是否与现有功能存在冲突，存在冲突时是否有兼容逻辑可测试性：需求中的功能要求是否有对错的评判，需求中的非功能要求是否具备验证的标准和方法测试人员尤其要重视需求的可测性。早期提出可测试性方面的问题和风险，否则，到了后续的环节才发现需求不可测，这可能会导致需求变更或技术实现方案的变更，对质量和效率的影响就太大了测试人员如何参与需求评审：强化需求评审或技术设计评审环节，投入较多的精力，前置思考好一个需求中的重点、难点、风险点，提前应对研发阶段：技术设计评审主要评审是否满足业务需求的功能和非功能质量属性，以及发布方案是否完备评审要点：正确性：技术设计是否可以满足业务需求中的全部功能要求，对异常情况的考虑是否充分可测性：技术设计是否可测，预期结果是否稳定非功能性：是否考虑了安全性、性能、稳定性、扩展性、可靠性等非功能质量属性兼容性：对不同形态和版本的终端是否兼容，对上下游的服务和数据是否兼容发布方案：部署逻辑设计是否合理是否需要对数据结构、缓存、各类配置等进行操作功能是否具备可回滚的能力灰度计划是否合理对服务的关键业务指标和技术指标是否做了监控和告警配置应急预案有哪些，如何应对预计的发布时间是如何安排的，需要哪些人员协同，等等测试阶段：测试设计&amp;评审测试阶段主要分两部分，测试设计阶段和测试执行阶段，测试设计阶段主要是进行测试方案和用例的设计，测试执行阶段主要是在提测后，对测试方案或用例进行执行的过程测试用例评审：测试用例的质量关系到测试执行的质量和测试工作本身的质量提高测试用例质量，可以通过两种方式，一是尽量将测试用例模板进行标准化；二是对用例进行评审。测试用例评审时间过早和过晚都不好，一般应在提测前 2 天左右的时间完成为宜评审要点：测试范围：测试用例是否覆盖了业务和技术的需求，对于已有功能是否进行了必要的回归异常情况：用例是否考虑了非常规操作或其他异常情况易读性：测试用例是否包含前置条件、操作步骤和期望结果等必要信息非功能性设计：针对非功能性的需求和技术设计，测试用例是否设计充分测试执行阶段和发布阶段涉及缺陷管理、测试总结与分析、测试报告编写等工作"}]},{"id":"5438208f2f467210ad3b895125ef281b","dirname":"微信","filename":"","basename":"","path":"/home/runner/work/qxtang.github.io/qxtang.github.io","children":[{"id":"5f55e555510d01a84852a1b5c63710cc","isRootIndexFile":false,"isIndexFile":true,"filename":"index.md","basename":"微信","path":"/home/runner/work/qxtang.github.io/qxtang.github.io/微信","content":"微信微信小程序分包机制某些情况下，需要将小程序划分成不同的子包，在构建时打包成不同的分包，用户在使用时按需进行加载通过在 app.json subpackages 字段声明项目分包结构在构建小程序分包项目时，构建会输出一个或多个分包。每个使用分包小程序必定含有一个主包。所谓的主包，即放置默认启动页面/TabBar 页面，以及一些所有分包都需用到公共资源/JS 脚本；而分包则是根据开发者的配置进行划分在小程序启动时，默认会下载主包并启动主包内页面，当用户进入分包内某个页面时，客户端会把对应分包下载下来，下载完成后再进行展示。目前小程序分包大小有以下限制：整个小程序所有分包大小不超过 20M单个分包/主包大小不能超过 2M对小程序进行分包，可以优化小程序首次启动的下载时间，以及在多团队共同开发时可以更好的解耦协作什么是 wxs小程序的一套脚本语言公众号用户授权流程1.用户同意授权，获取 code在后台配置合法域名，页面需运行在合法域名下引导关注者打开微信授权页面页面链接会通过 url 传递一些参数 appid、redirect_uri、response_type 等跳回应用2.通过 code 换取网页授权 access_token把 code 传给后端后端调微信接口消费 code，获得网页授权 access_token（可选择缓存） 和 openid请求微信用户信息接口，响应给前端接入 js-sdk 流程在后台配置合法域名，页面需运行在合法域名下前端引入微信 jssdk 资源请求后端获取 jssdk 签名参数接口后端请求微信接口获取 access_token，再用 access_token 获取 jsapi_ticket组装 noncestr、jsapi_ticket、timestamp、url，进行 sha1 签名得到 signature把计算结果响应给前端前端调用 wx.config 注入权限，jsApiList 配置需要调用的 jsapi通过 ready 接口处理成功验证、通过 error 接口处理失败验证小程序登录流程首次登录：前端调用 wx.login() 获取临时登录凭证 code，过期时间 5 分钟使用 code 请求后端登录接口，通过 code 换取用户登录信息，包括用户的 openid 及本次登录的 token 等前端保存 token 在缓存再次登录：获取缓存中的 token如果缓存中存在 token，调用 wx.checkSession() 判断微信登录态是否过期，调用后端相关接口检查 token 是否过期如有其中之一过期，则重新走登录流程性能优化使用分包避免在代码包中包含或在 wxss 中使用 base64 内联过多、过大的图片等资源文件。这类文件应尽可能部署到 CDN，并使用 url 引入启动过程中减少同步 api 的调用，会阻塞当前 js 线程避免启动过程进行复杂运算"},{"id":"6e923e3e6948d0f634098959a5f953da","isRootIndexFile":false,"isIndexFile":false,"filename":"真机调试微信 h5 页面.md","basename":"真机调试微信 h5 页面","path":"/home/runner/work/qxtang.github.io/qxtang.github.io/微信","content":"真机调试微信 h5 页面真机上通过 https 和可信域名访问本地开发服务，进行本地调试条件手机和 pc 处在同一局域网环境pc 安装 Fiddler假设可信域名为 wx-dev.com假设 pc 局域网 ip 为 192.168.1.106本地 hosts 文件添加映射编辑 hosts 文件，将域名映射到 pc 局域网 ip## 微信开发192.168.1.106 wx-dev.com设置 Fiddlertools -&gt; optionshttps 设置Connections 设置修改 webpack 配置开启 httpshttps://webpack.js.org/configuration/dev-server/#devserverhttps本地服务端口号改成 443此时可在 pc 浏览器通过 https://wx-dev.com 访问本地服务修改手机代理进入手机 wlan 设置，选择连接的 wifi，代理选择手动主机名填 pc 局域网 ip，端口填 Fiddler 代理设置中的端口号手机安装 Fiddler 证书手机浏览器访问 http://[pc局域网ip]:[Fiddler 代理端口号]，这里是 http://192.168.1.106:8002点击下载 Fiddler 证书，进入手机 wlan 设置安装证书此时手机浏览器可通过 https://wx-dev.com 访问 pc 上的本地服务。结束"}]},{"id":"cfc6762313c8fadde407c043154409f7","dirname":"最佳实践","filename":"","basename":"","path":"/home/runner/work/qxtang.github.io/qxtang.github.io","children":[{"id":"5d9cd149bffeb85ff35aed2ff52e3c4c","isRootIndexFile":false,"isIndexFile":false,"filename":"CSS最佳实践.md","basename":"CSS最佳实践","path":"/home/runner/work/qxtang.github.io/qxtang.github.io/最佳实践","content":"CSS 最佳实践待完善善用继承关键字 inherit使用 all:unset 或 all:revert 将样式进行批量重置"},{"id":"90c722fcc7f93ea31011ef4abc7f384d","isRootIndexFile":false,"isIndexFile":false,"filename":"Javascript.md","basename":"Javascript","path":"/home/runner/work/qxtang.github.io/qxtang.github.io/最佳实践","content":"Javascript先声明后调用优先 const常量大写少写魔法值，常量需要命名不污染全局不要忽略抛异常、不要忘了在 Promise\\async await 抛异常缓存耗时的计算，比如 dom 查找、设备信息查询等尽可能使用原生方法，因为原生方法是用低级语言写的（C/C++），并且被编译成机器码，效率更高，比如 Array 的 filter少用 for-in，慢，for-in 要搜索原型属性基于函数的迭代 forEach 比一般的循环要慢，如果对运行速度要求很严格，不要使用使用枚举或策略模式减少 elseif，使用 Map、Object 优化 switch-case?? 空值合并操作符、?. 链合并运算符少写 console（或提交代码时删除 console），项目跑起来一堆的日志让队友很头疼多元判断时，可将条件拼接成字符串存到 Object 里/** * 按钮点击事件 * @param {number} status 活动状态：1未开始 2进行中 3结束 * @param {string} identity 身份标识：guest游客 admin管理员 */const onButtonClick = (status, identity) =&gt; {  if (identity == &#x27;guest&#x27;) {    if (status == 1) {      //do sth    } else if (status == 2) {      //do sth    } else if (status == 3) {      //do sth    } else {      //do sth    }  } else if (identity == &#x27;admin&#x27;) {    if (status == 1) {      //do sth    } else if (status == 2) {      //do sth    } else if (status == 3) {      //do sth    } else {      //do sth    }  }};// 可优化为const actions = new Map([  [&#x27;guest_1&#x27;, () =&gt; {} /*do sth*/],  [&#x27;guest_2&#x27;, () =&gt; {} /*do sth*/],  [&#x27;guest_3&#x27;, () =&gt; {} /*do sth*/],  [&#x27;admin_1&#x27;, () =&gt; {} /*do sth*/],  [&#x27;admin_2&#x27;, () =&gt; {} /*do sth*/],  [&#x27;admin_3&#x27;, () =&gt; {} /*do sth*/],  [&#x27;default&#x27;, () =&gt; {} /*do sth*/],]);/** * 按钮点击事件 * @param {string} identity 身份标识：guest游客 admin管理员 * @param {number} status 活动状态：1未开始 2进行中 3 结束 */const onButtonClick = (identity, status) =&gt; {  let action = actions.get(`${identity}_${status}`) || actions.get(&#x27;default&#x27;);  action.call(this);};可适当使用对象区分作用域使用 Array.includes 来优化多个条件的判断使用 Array.every 和 Array.some 来处理全部/部分满足条件减少嵌套，提前使用 return用有意义且常用的单词命名变量// 错误：const yyyymmdstr = moment().format(&#x27;YYYY/MM/DD&#x27;);// 正确:const currentDate = moment().format(&#x27;YYYY/MM/DD&#x27;);保持统一命名可能同一个项目对于获取用户信息，会有三个不一样的命名，应该保持统一。// 错误：getUserInfo();getClientData();getCustomerRecord();// 正确：getUser();避免无意义前缀如果创建了一个对象 car，就没有必要把它的颜色命名为 carColor。// 错误：const car = {  carMake: &#x27;Honda&#x27;,  carModel: &#x27;Accord&#x27;,  carColor: &#x27;Blue&#x27;,};function paintCar(car) {  car.carColor = &#x27;Red&#x27;;}// 正确：const car = {  make: &#x27;Honda&#x27;,  model: &#x27;Accord&#x27;,  color: &#x27;Blue&#x27;,};function paintCar(car) {  car.color = &#x27;Red&#x27;;}使用函数参数默认值// 错误：function doSomeThing(name) {  const username = name || &#x27;tony&#x27;;  // ...}// 正确：function doSomeThing(name = &#x27;tony&#x27;) {  // ...}参数越少越好如果参数超过两个，使用解构语法，不用考虑参数顺序。// 错误：function createMenu(title, body, buttonText, cancellable) {  // ...}// 正确：function createMenu({ title, body, buttonText, cancellable }) {  // ...}createMenu({  title: &#x27;Foo&#x27;,  body: &#x27;Bar&#x27;,  buttonText: &#x27;Baz&#x27;,  cancellable: true,});抽象重复代码很多时候虽然是同一个功能，但由于一两个不同点，让你不得不写两个几乎相同的函数，要想优化重复代码需要有较强的抽象能力。不传 flag 参数不要通过 flag 的 true 或 false，来判断执行逻辑。删除弃用代码可以在代码库历史版本中找到它。使用 class链式调用这种模式让的代码简洁优雅，在类的方法最后返回 this 就可以了。class Car {  constructor(make, model, color) {    this.make = make;    this.model = model;    this.color = color;  }  setMake(make) {    this.make = make;    return this;  }  setModel(model) {    this.model = model;    return this;  }  setColor(color) {    this.color = color;    return this;  }  save() {    console.log(this.make, this.model, this.color);    return this;  }}const car = new Car(&#x27;Ford&#x27;, &#x27;F-150&#x27;, &#x27;red&#x27;).setColor(&#x27;pink&#x27;).save();单一功能原则如果一个类干的事情太多太杂，会导致后期很难维护。我们应该厘清职责，各司其职减少相互之间依赖。封闭开放原则“当需要改变一个程序的功能或者给这个程序增加新功能的时候，可以使用增加代码的方式，但是不允许改动程序的源代码”比如我想修改一个公共组件的样式来适配自己的页面，但又需要保证其他使用这个组件的页面不受影响，可以通过增加一个主题参数，根据该参数加载一份新的样式文件"},{"id":"38f7be06c8c5c4d4d37ea6cadecfc7fe","isRootIndexFile":false,"isIndexFile":false,"filename":"React.md","basename":"React","path":"/home/runner/work/qxtang.github.io/qxtang.github.io/最佳实践","content":"React使用 hooks使用 styled-components https://medium.com/building-crowdriff/styled-components-to-use-or-not-to-use-a6bb4a7ffc21考虑使用 unstated-next 代替 redux组件属性超过 3 个则换行没有子元素的组件写成自闭合多用函数组件，更小的打包体积，更高的执行效率多用 PureComponent，PureComponent 会先对 state 和 props 进行浅比较，不同的时候才会 render遵循单一职责原则，使用 HOC / 装饰器 / Render Props 增加职责react 组件文件用 jsx，用大驼峰命名 jsx 文件表达式中的 jsx 使用圆括号包裹每个文件只写一个组件，但是多个无状态组件可以放在单个文件中，文件名要与默认导出的类名一致组合优于继承性能原因尽量不写内联函数，比如点击事件React 应用中的权限管理：https://isamatov.com/react-permissions-and-roles/多使用解构，例如声明函数组件的 props 和 默认值export default ({ name = &#x27;小明&#x27;, sex = &#x27;男&#x27; }) =&gt; (  &lt;&gt;    我叫 {name}，性别 {sex}  &lt;/&gt;);组件属性命名保持统一，使兼容性良好，避免无意义前缀// 错误&lt;MyInput inputValue onInputChange wrapStyle wrapClassName /&gt;// 正确&lt;MyInput value onChange style className /&gt;避免在 render 里面动态创建对象 / 方法，否则会导致子组件每次都 render// 错误：render() {  const obj = {num: 1}  return (    &lt;Child obj={obj} onClick={()=&gt;{...}} /&gt;  );}避免在 JSX 中写复杂的三元表达式，应通过封装函数或组件实现// 错误：render() {  const a = 8;  return (    &lt;div&gt;      {        a &gt; 0 ? a &lt; 9 ? ... : ... : ...      }    &lt;/div&gt;  );}// 正确：f() {  // ...}render() {  const a = 8;  return (    &lt;div&gt;      {        this.f()      }    &lt;/div&gt;  );}使用运算符&amp;&amp;简化三元运算在 JavaScript 中，true &amp;&amp; expression 总是会返回 expression, 而 false &amp;&amp; expression 总是会返回 false，因此，如果条件是 true，&amp;&amp; 右侧的元素就会被渲染，如果是 false，React 会忽略并跳过它。例如：{  loading ? &lt;Loading /&gt; : null;}可简化为{  loading &amp;&amp; &lt;Loading /&gt;;}尽量避免使用展开运算符来展开 props变得难以理解和维护，容易出 bug遇到事件处理，可以使用一个返回新函数的方法例如：import React from &#x27;react&#x27;;export default function SampleComponent({ onValueChange }) {  const handleChange = (key) =&gt; {    return (e) =&gt; onValueChange(key, e.target.value);  };  return (    &lt;form&gt;      &lt;input onChange={handleChange(&#x27;name&#x27;)} /&gt;      &lt;input onChange={handleChange(&#x27;email&#x27;)} /&gt;      &lt;input onChange={handleChange(&#x27;phone&#x27;)} /&gt;    &lt;/form&gt;  );}使用 Hook components比如要封装一个弹窗组件：// 组件import React, { useCallback, useState } from &#x27;react&#x27;;import ConfirmationDialog from &#x27;components/global/ConfirmationDialog&#x27;;export default function useConfirmationDialog({ headerText, bodyText, confirmationButtonText, onConfirmClick }) {  const [isOpen, setIsOpen] = useState(false);  const onOpen = () =&gt; {    setIsOpen(true);  };  const Dialog = useCallback(    () =&gt; (      &lt;ConfirmationDialog        headerText={headerText}        bodyText={bodyText}        isOpen={isOpen}        onConfirmClick={onConfirmClick}        onCancelClick={() =&gt; setIsOpen(false)}        confirmationButtonText={confirmationButtonText}      /&gt;    ),    [isOpen]  );  return {    Dialog,    onOpen,  };}// 使用import React from &#x27;react&#x27;;import { useConfirmationDialog } from &#x27;./useConfirmationDialog&#x27;;function Client() {  const { Dialog, onOpen } = useConfirmationDialog({    headerText: &#x27;Delete this record?&#x27;,    bodyText: &#x27;Are you sure you want delete this record? This cannot be undone.&#x27;,    confirmationButtonText: &#x27;Delete&#x27;,    onConfirmClick: handleDeleteConfirm,  });  function handleDeleteConfirm() {}  const handleDeleteClick = () =&gt; {    onOpen();  };  return (    &lt;div&gt;      &lt;Dialog /&gt;      &lt;button onClick={handleDeleteClick} /&gt;    &lt;/div&gt;  );}export default Client;这种模式可以少写很多与组件相关的 state，比如弹窗的 visible、title 之类的将业务逻辑封装进 hooks，业务逻辑与 UI 分离（关注点分离）// 例如：import React from &#x27;react&#x27;;import ItemDisplay from &#x27;./ItemDisplay&#x27;;export default function SampleComponent() {  const { data, handleDelete, handleEdit, handleAdd } = useCustomHook();  return (    &lt;div&gt;      &lt;div&gt;        {data.map((item) =&gt; (          &lt;ItemDisplay item={item} /&gt;        ))}      &lt;/div&gt;      &lt;div&gt;        &lt;button onClick={handleDelete} /&gt;        &lt;button onClick={handleAdd} /&gt;        &lt;button onClick={handleEdit} /&gt;      &lt;/div&gt;    &lt;/div&gt;  );}不要把所有状态存放在 redux，redux 只用于存放用户登录信息、主题等信息不要任何变量都使用状态，可以使用 useRef 或成员属性（类组件）来储存与更新渲染无关的变量，可以通过已保存的状态来推断出的状态可使用 useMemo 来计算，而不要创建新状态尽量不要在组件中声明新的组件// 错误，不建议function A() {  const B = () =&gt; {    return &lt;p&gt;hello&lt;/p&gt;;  };  return (    &lt;div&gt;      &lt;B /&gt;    &lt;/div&gt;  );}原因：高耦合影响性能，A 每一次渲染都会重新声明一遍 B避免为了优化少量性能过度设计代码，牺牲代码的可维护性、易读性，浪费时间"},{"id":"d02c013ecd23b0f2469dc30db74d4108","isRootIndexFile":false,"isIndexFile":false,"filename":"git 实践.md","basename":"git 实践","path":"/home/runner/work/qxtang.github.io/qxtang.github.io/最佳实践","content":"git 实践git rebase可以直接理解为改变基底。feature 分支是基于 master 分支的 B 拉出来的分支，feature 的基底是 B。而 master 在 B 之后有新的提交，就相当于此时要用 master 上新的提交来作为 feature 分支的新基底。实际操作为把 B 之后 feature 的提交存下来，然后删掉原来这些提交，再找到 master 的最新提交位置，把存下来的提交再接上去（新节点新 commit id）如此 feature 分支的基底就相当于变成了 M 而不是原来的 B 了。注意，如果 master 上在 B 以后没有新提交，那么就还是用原来的 B 作为基，rebase 操作相当于无效，此时和 git merge 就基本没区别了，差异只在于 git merge 会多一条记录 Merge 操作的提交记录大部分公司其实会禁用 rebase，不管是拉代码还是 push 代码统一都使用 merge，虽然会多出无意义的一条提交记录“Merge … to …”，但至少能清楚地知道主线上谁合了的代码以及他们合代码的时间先后顺序GitFlow简单记录工作中使用 gitflow 模型管理代码版本、保证代码安全的方法。参考：A successful Git branching modelGit 工作流程Git 分支管理策略git flow 的使用GitFlow 原理浅析gitflow 现在被认为过于复杂，可能不适用于现代软件开发：如何看待 Git flow 发明人称其不适用于持续交付？Issues with git-flow在阿里，我们如何管理代码分支？分支类型master只有一条主分支只读，只能从分支 release 或 hotfix 合并进来所有发生在 master 分支的修改应该打 tag 做记录，方便追溯develop只有一条主开发分支，基于 master 分支克隆包含所有要发布到下一个 release 的代码只读，只能从 feature 或 release 合并进来feature 功能分支完成开发后，合并到 develop，合并到 develop 前，提交合并申请，与 develop 分支进行比较做代码审查，审查通过则允许合并从 develop 拉取 release 分支，提测release 或 hotfix 分支上线完毕，合并回 develop。feature功能开发分支，基于 develop 分支克隆，主要用于新需求新功能的开发有多条，按功能划分，如：/feature/20200712-新增用户、/feature/20200801-登陆注册可以几个人一起开发一条 feature，也可以一人负责一条 feature功能开发完毕后，提测前，合并到 develop 分支feature 类型的分支可同时存在多个，用于团队中多个功能同时开发，属于临时分支，功能完成后可选择删除release版本分支，用于测试与上线，基于 feature 分支合并到 develop 之后，从 develop 分支克隆有多条，按版本划分，如：/release/20200712-第一版v0.1、/release/20200713-第二版v0.2release 类型的分支主要用于测试和修改 bug，完成上线后合并回 develop 与 master 分支hotfix补丁分支，基于 master 分支克隆，主要用于对线上的版本进行 BUG 修复有多条，按版本划分，如：/hotfix/20200712-修复xss漏洞、/hotfix/20200713-修复新增用户失败bug修复完毕后合并回 develop 与 master 分支主要工作流程示例初始化项目，创建 master 分支，然后从 master 拉取 develop 分支根据需求划分功能，从 develop 拉取 feature 分支进行编码开发，如/feature/20200712-新增用户、/feature/20200801-登陆注册feature 分支完成后，合并到 develop 前，提交合并申请，与 develop 比较，进行代码审查，合并完成可以选择删除当前 feature需要发布时，从 develop 拉取 release 分支进行测试，例如/release/20200712-第一版，测试过程中在该条 release 分支上修改 BUG，测试通过后将该条 release 分支发布回归：任一 release 分支通过测试上线后，合并该 release 分支到 develop 与 master，master 分支打 tag，当前 release 不可修改，线上有问题须从 master 拉取 hotfix 分支进行修改通知所有进行中的 feature、release 把 master 合进来一次上线之后若发现 bug，从 master 拉取 hotfix 进行 bug 修改，如/hotfix/20200713-修复新增用户失败bughotfix 通过测试上线后，合并 hotfix 分支到 develop 与 master，master 分支打 tag版本回退：如果需进行版本回退，则选择上一版本号的 release 分支进行发布分支命名使用 YYYYMMDD-功能名称 格式，gui 工具或命令行打印时自动排序，找分支找比较方便参考https://ourai.ws/posts/working-with-git-in-team/https://www.cnblogs.com/irving/p/5146738.htmlhttps://mp.weixin.qq.com/s/0N3isbSZL4fM5HjZo1aafAhttps://ihower.tw/blog/archives/3843"},{"id":"6b4ced9d2ef205d68999ba7579eb19ac","isRootIndexFile":false,"isIndexFile":true,"filename":"index.md","basename":"最佳实践","path":"/home/runner/work/qxtang.github.io/qxtang.github.io/最佳实践","content":"最佳实践参考https://guide.aotu.io/docs/https://isamatov.com/simple-tips-for-writing-clean-react-components/https://react-typescript-cheatsheet.netlify.app/https://juejin.im/post/5e021eb96fb9a01628014095https://juejin.cn/post/7086735198942920712"},{"id":"a8b2265cbd54ac650bb8381258e83bd7","isRootIndexFile":false,"isIndexFile":false,"filename":"前端组件设计原则.md","basename":"前端组件设计原则","path":"/home/runner/work/qxtang.github.io/qxtang.github.io/最佳实践","content":"前端组件设计原则细粒度的考量：单一职责原则组件要建立在可复用的基础上，对于不可复用的单一职责组件仅作为独立组件的内部组件即可通用性考量暴露拓展能力给调用方（插槽、render props）css 解决方案使用 css-in-js、styled-components测试方案使用 Jest 测试框架"},{"id":"3e08f87fd663eba276f17e91f87d0536","isRootIndexFile":false,"isIndexFile":false,"filename":"调试排错技巧.md","basename":"调试排错技巧","path":"/home/runner/work/qxtang.github.io/qxtang.github.io/最佳实践","content":"调试排错技巧浏览器使用 debugger 关键字source 面板打断点chrome 移动页面调试工具：chrome://inspect/#devices使用 Chrome DevTools 的请求重放功能，重新发起请求webstorm 的 debug JavaScript in chrome 功能dom 断点：https://stackoverflow.com/questions/28963272/how-can-i-inspect-html-element-that-disappears-from-dom-on-lost-focusDevTools 调试节点失焦、获焦：element 面板 -&gt; 选中节点右键菜单 -&gt; Break onreactredux devtoolsreact developer tools参考https://umaar.com/dev-tips/https://isamatov.com/react-chrome-dev-tools-tips/https://developer.chrome.com/docs/devtools/"},{"id":"e7542d604b34ce539d8b7baa7df7746b","isRootIndexFile":false,"isIndexFile":false,"filename":"通用工程实践.md","basename":"通用工程实践","path":"/home/runner/work/qxtang.github.io/qxtang.github.io/最佳实践","content":"其他工程实践滥用事件总线的危害事件名称难以追溯，增加了代码复杂度、可维护性降低调试难度大业务代码分层习惯├─assets 静态资源├─service 业务逻辑封装├─components 组件  ├─business 业务组件  ├─common 通用组件├─constants 常量├─store 全局状态├─pages 页面├─types 通用类型├─utils 工具使前端能够脱离后端进行独立测试集成 mockjs 等工具，使前端能够脱离后端独立的进行测试，模拟后端各种请求报错以及所有其他情况npm 脚本命名同一系列行为的脚本，命令行参数、环境变量有差异，用冒号区分，比如&quot;scripts&quot;: {  &quot;build:test&quot;: &quot;tsc &amp;&amp; vite build --mode test&quot;,  &quot;build:prod&quot;: &quot;tsc &amp;&amp; vite build --mode production&quot;,}前置操作的处理如登录、获取用户信息、权限检查等任务，放在根组件（App.tsx、App.vue）中执行，执行结束再渲染路由组件，保证业务接口能正确获取参数小程序：小程序入口组件不会渲染任何内容，例如 Taro 框架，根组件必须同步返回 props.children，所以对前置操作的处理，可以将首页设置为一个 loading 页，在 loading 页中显示加载中且进行前置操作后，再跳转到业务页面（为 loading 页设置如 redirectUrl 参数设置跳转页面）。不建议在本地构建部署代码应使用 devops 系统前端项目的一般部署流程获取代码：从代码仓库获取项目代码，并切换到待部署的分支或版本安装依赖：安装项目构建所需要的依赖包源码构建：使用构建工具对项目源代码进行构建，生成产物代码产物打包：将部署所需的代码（通常指的是构建后的产物代码，如果是部署 Node 服务则还需要其他目录与文件）打成压缩包推送代码：将待部署的文件或压缩包推送至目标服务器的特定目录下，如果是推送压缩包的情况，还需执行解压重启服务：在部署 Node 服务的情况下，在代码推送后需要进行服务重启本地部署的优势快速：不需要获取代码、安装依赖这几个步骤构建失败能更方便查找问题本地部署的劣势溯源难环境一致性：不同开发人员的本地依赖包版本可能存在差异，导致打包结果并不严格一致；本地环境和部署代码的目标服务器环境之间也可能存在差异；导致项目代码的稳定性无法得到保障例如对于一个 Node 项目而言，在一个 NodeJS 低版本环境下构建的产物，在 Node 高版本环境下就有可能启动异常其他第三方库按需加载移除生产环境的控制台打印动态 polyfill通过判断环境变量的方式，区分执行环境差异代码，借助 DefinePlugin 将环境变量静态嵌入客户端代码尽量不要污染全局 window 对象通过封装解决浏览器差异兼容性问题为项目配置代码引用路径别名 alias项目不要添加任何与开发环境强耦合的设置（比如某个地方必须借助 vscode 的某个插件才能运行）禁止安装私人依赖包使用 Webpack Bundle Analyzer 分析包大小组成函数遵循单一职责原则只导入类型，使用 import typeimport type { DependencyList, useEffect, useLayoutEffect } from &#x27;react&#x27;;想要在 chrome 移动设备模拟器上添加某个自定义设备型号，需要知道该设备的分辨率console.log(document.body.clientWidth, document.body.clientHeight);开发环境 node 和 npm 版本需要一致，因为不同版本 node、npm 行为不一样小程序环境判断https://developers.weixin.qq.com/community/develop/doc/000e466b2c84d057b178e339d5b000https://developers.weixin.qq.com/community/develop/article/doc/000e6606ab4ac0edb4791eb4951013"}]},{"id":"e3e8f8ee86c2edd5565cdc07690caf3c","dirname":"网络","filename":"","basename":"","path":"/home/runner/work/qxtang.github.io/qxtang.github.io","children":[{"id":"4dd00a18c865ea7bc8d38a93b4960217","isRootIndexFile":false,"isIndexFile":false,"filename":"HTTP.md","basename":"HTTP","path":"/home/runner/work/qxtang.github.io/qxtang.github.io/网络","content":"HTTP超文本传输协议，是一个客户端和服务器端请求和应答的标准无状态、明文传输处于 TCP/IP 分层模型中的应用层浏览器实现了 http 缓存默认端口 80无状态性每次请求都建立新的连接，数据请求完毕立即断开，短连接（http1.1 开始已经支持长连接）协议对于发送过的请求或响应都不做持久化处理，为了更快地处理大量事务，确保协议的可伸缩性，特意设计得简单一些，保存状态需要引入 cookie 和 session，需要客户端实现 cookie 功能（浏览器），服务器实现 sessionHTTP 报文格式http 报文分为三部分：起始行、头部、主体其中起始行和头部字段并成为 请求头 或者 响应头，统称为 Headerheader 和 body 之间必须要有一个空行（CRLF）起始行描述请求或响应的基本信息，形如 GET /index.html HTTP/1.1头部：使用 key-value 形式更详细地说明报文多个键值对之间使用 空行（CRLF） 作为分隔符存放如 cookie、content-type 等主体：存放数据，明文传输请求类型OPTIONS：返回服务器针对特定资源所支持的 HTTP 请求方法HEAD：向服务器请求与 GET 请求相一致的响应，响应体不返回。可以在不必传输整个响应内容的情况下，就可以获取包含在响应头中的信息GET：向特定的资源发出请求POST：向指定资源提交数据进行处理请求PUT：向指定资源位置上传其最新内容DELETE：请求服务器删除指定资源TRACE：回显服务器收到的请求，主要用于测试或诊断状态码1xx 信息，服务器收到请求，需要请求者继续执行操作2xx 成功，操作被成功接收并处理3xx 重定向，需要进一步的操作以完成请求4xx 客户端错误，请求包含语法错误或无法完成请求5xx 服务器错误，服务器在处理请求的过程中发生了错误100 表示目前为止一切正常, 客户端应该继续请求, 如果已完成请求则忽略200 表明请求已经成功 默认情况下状态码为 200 的响应可以被缓存201 表示请求已经被成功处理，并且创建了新的资源。新的资源在应答返回之前已经被创建。202 表示服务器端已经收到请求消息，但是尚未进行处理。但是对于请求的处理确实无保证的，即稍后无法通过 HTTP 协议给客户端发送一个异步请求来告知其请求的处理结果。204 表示目前请求成功，但客户端不需要更新其现有页面。301 永久重定向。说明请求的资源已经被移动到了由 Location 头部指定的 url 上，是固定的不会再改变。搜索引擎会根据该响应修正。302 临时重定向。重定向状态码表明请求的资源被暂时的移动到了由 Location 头部指定的 URL 上。浏览器会重定向到这个 URL，但是搜索引擎不会对该资源的链接进行更新304 Not Modified 说明无需再次传输请求的内容，也就是说可以使用缓存的内容。这通常是在 GET 请求, 或在请求中附带了头部信息：If-None-Match 或 If-Modified-Since307 临时重定向。类似 302，区别在于能够确保请求方法和消息主体不会发生改变。308 永久重定向。类似 301，区别在于能够确保请求方法和消息主体不会发生改变。400 表示由于语法无效，服务器无法理解该请求。客户端不应该在未经修改的情况下重复此请求。401 说明由于缺乏目标资源要求的身份验证凭证，发送的请求未得到满足。403 指的是服务器端有能力处理该请求，但是拒绝授权访问。进入该状态后，不能再继续进行验证。该访问是永久禁止的，并且与应用逻辑密切相关（例如不正确的密码）404 说明服务器端无法找到所请求的资源。405 Method Not Allowed 表明服务器禁止了使用当前 HTTP 方法的请求。需要注意的是，GET 与 HEAD 两个方法不得被禁止，当然也不得返回状态码 405。500 表示所请求的服务器遇到意外的情况并阻止其执行请求，比如服务端代码语法错误502 表示作为网关或代理角色的服务器，从上游服务器（如 tomcat、php-fpm）中接收到的响应是无效的。504 表示网关或者代理的服务器无法在规定的时间内获得想要的响应。比如 代码执行时间超时，或死循环了。301 和 302 区别302 重定向只是暂时的重定向，例如未登陆的用户访问用户中心重定向到登录页面。因为服务器返回 302，所以，搜索搜索引擎认为新的网址是暂时的，搜索引擎会抓取新的内容而保留旧的地址。301 重定向是永久的重定向，搜索引擎在抓取新的内容的同时也将旧的网址替换为了重定向之后的网址常见请求头Accept 可接受的响应内容类型CookieContent-Type 请求体的 MIME 类型OriginReferer 来源User-AgentCache-Control 强缓存相关Expires 强缓存相关Last-Modified 协商缓存相关Etag 协商缓存相关Access-Control-Allow-Origin 指定允许跨域的域名http 1.1 新特性默认支持并使用长连接，默认设置 Connection：keep-alive，TCP 连接在发送后将仍然保持打开状态，客户端可以继续通过相同的连接发送请求，节省了为每个请求建立新连接所需的时间，还节约了网络带宽断点续传：在请求头引入了 range 头域，它允许只请求资源的某个部分，即返回码是 206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。身份认证状态管理新增了 host 字段，用来指定服务器的域名新的缓存头部标识：Cache-Control、Expires、Last-Modified、Etaghttp 1.0 缺点文本协议传输，不够安全无法复用链接，完成即断开，重新慢启动和 TCP 3 次握手线头阻塞，导致请求之间互相影响header 内容繁多，有时有可能会超过响应内容，并且每次有许多字段都是重复传输基于以上缺点，也出现了许多优化手段：雪碧图、合并脚本和样式表、资源内联、域名分片等优化工作，但是如果 http 协议足够好的话，本可以避免这些额外的操作http 2.0 帧（frame）和流（stream）帧代表着最小的数据单位，每个帧会标识出该帧属于哪个流，流是多个帧组成的数据流2.0 新特性二进制协议在 HTTP/1.1 版中，报文的头信息必须是文本（ASCII 编码），数据体可以是文本，也可以是二进制。http2 则是彻底二进制，统称为&quot;帧&quot;帧的概念是它实现多路复用的基础多路复用在 HTTP/1 中，每次请求都会建立一次 HTTP 连接，3 次握手和 4 次挥手，这个过程在一次请求过程中占用了较多时间，即使开启了 Keep-Alive，解决了多次连接的问题，但是依然有两个效率上的问题，一是串行的文件传输，二是连接数过多导致的性能问题仍然复用 TCP 连接，但是在一个连接里，客户端和服务器都可以同时发送多个请求或响应通信双方都可以给对方发送二进制帧，这种二进制帧的双向传输的序列，也叫做流(Stream)。HTTP/2 用流来在一个 TCP 连接上来进行多个数据帧的通信，这就是多路复用的概念多路复用，就是在一个 TCP 连接中可以存在多条流。换句话说，也就是可以发送多个请求，对端可以通过帧中的标识知道属于哪个请求。通过这个技术，可以避免 HTTP 旧版本中的队头阻塞问题，极大的提高传输性能。头部压缩由于 HTTP 1.1 协议不带状态，每次请求都必须附上所有信息请求的很多字段都是重复的，浪费带宽，影响速度http2 做了优化：头信息使用 gzip 或 compress 压缩后再发送头信息使用 gzip 或 compress 压缩后再发送数据流因为 HTTP/2 的数据包是不按顺序发送的，同一个连接里面连续的数据包，可能属于不同的请求因此，必须要对数据包做标记，指出它属于哪个请求HTTP/2 将每个请求或响应的所有数据包，称为一个数据流。每个数据流都有一个唯一编号数据包发送时，都标记数据流 ID，用来区分它属于哪个数据流服务器推送在 HTTP2 当中，服务器已经不再是完全被动地接收请求，响应请求，它也能新建 stream 来给客户端发送消息，当 TCP 连接建立之后，比如浏览器请求一个 HTML 文件，服务器就可以在返回 HTML 的基础上，将 HTML 中引用到的其他资源文件一起返回给客户端，减少客户端的等待HTTP2 下服务器主动推送的是静态资源，和 WebSocket 等是不同的队头阻塞现象由 HTTP 基本的“请求 - 应答”模型所导致因为 HTTP 规定报文必须是“一发一收”，这就形成了一个先进先出的“串行”队列队列里的请求没有优先级，只有入队的先后顺序，排在最前面的请求被最优先处理如果队首的请求因为处理的太慢耽误了时间，那么队列里后面的所有请求也不得不跟着一起等待，结果就是其他的请求承担了不应有的时间成本解决：域名分片，多开几个域名，而这些域名都指向同一个服务器定长与不定长包体响应头设置 Content-Length 指明包体的长度响应头设置 Transfer-Encoding: chunked 表示分块传输数据，Content-Length 字段会被忽略，基于长连接持续推送动态内容范围请求用于处理大文件的传输，允许客户端仅请求一个资源的一部分可以一次性请求多个部分，服务器会以 multipart 文件的形式将其返回客户端设置请求头：range，格式为Range: &lt;unit&gt;=&lt;range-start&gt;-Range: &lt;unit&gt;=&lt;range-start&gt;-&lt;range-end&gt;Range: &lt;unit&gt;=&lt;range-start&gt;-&lt;range-end&gt;, &lt;range-start&gt;-&lt;range-end&gt;Range: &lt;unit&gt;=&lt;range-start&gt;-&lt;range-end&gt;, &lt;range-start&gt;-&lt;range-end&gt;, &lt;range-start&gt;-&lt;range-end&gt;unit：范围请求所采用的单位，通常是字节（bytes）&lt;range-start&gt;：整数，表示在特定单位下，范围的起始值&lt;range-end&gt;：整数，表示在特定单位下，范围的结束值。可选，如果不存在，表示此范围一直延伸到文档结束0-499 表示从开始到第 499 个字节500- 表示从第 500 字节到文件终点-100 表示文件的最后 100 个字节服务器收到请求之后，首先验证范围是否合法，如果越界了那么返回 416 错误码，否则读取相应片段，返回 206 状态码服务器设置响应头：accept-ranges如果服务器返回的是范围响应，需要使用 206 Partial Content 状态码所请求的范围不合法，服务器会返回 416 Range Not Satisfiable 状态码，表示客户端错误如何处理表单数据的提交体现在两种不同的 Content-Type 取值:application/x-www-form-urlencoded其中的数据会被编码成以&amp;分隔的键值对字符以 URL 编码方式编码multipart/form-data每一个表单元素都是独立的资源表述对于图片等文件的上传，基本采用 multipart/form-datapost 和 get 区别GET 和 POST 方法没有实质区别，只是报文格式不同。约定上，get 一般使用 url 传参，post 一般使用 body 传参，实际上 post 也可以 url 传参。GET 请求会被浏览器主动缓存下来，GET 没有副作用，点击浏览器后退和刷新按钮时，POST 的数据会被重新提交，GET 可以收藏为书签，GET 参数可被浏览器历史保存。GET 的参数长度受到浏览器限制，http 协议上并没有限制。POST 无限制。数据类型 GET 只允许传 ASCII 字符，POST 没有限制，允许传二进制数据。POST 并不比 GET 安全，只有 https 才是安全的。get 请求传参长度的误区：误区：我们经常说 get 请求参数的大小存在限制，而 post 请求的参数大小是无限制的。 实际上 HTTP 协议从未规定 GET/POST 的请求长度限制是多少。对 get 请求参数的限制是来源与浏览器或 web 服务器，浏览器或 web 服务器限制了 url 的长度。为了明确这个概念，我们必须再次强调下面几点:HTTP 协议 未规定 GET 和 POST 的长度限制GET 的最大长度显示是因为 浏览器和 web 服务器限制了 URI 的长度不同的浏览器和 WEB 服务器，限制的最大长度不一样从 TCP 的角度，GET 请求会把请求报文一次性发出去，而 POST 会分为两个 TCP 数据包，首先发 header 部分，如果服务器响应 100(continue)， 然后发 body 部分。(火狐浏览器除外，它的 POST 请求只发一个 TCP 包)https://segmentfault.com/a/1190000018129846https://juejin.im/post/59fc04ecf265da4317697f26http1.x 如何实现长连接(Keep-Alive)http1.1 默认开启长连接，不需要设置标头http1.1 规定了默认保持长连接，数据传输完成了保持 TCP 连接不断开，等待在同域名下继续用这个通道传输数据。如果需要关闭，需要客户端发送 Connection：close 首部字段https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Connection_management_in_HTTP_1.x长连接优点较少的 CPU 和内存的使⽤（由于同时打开的连接的减少了）降低拥塞控制（TCP 连接减少了）减少了后续请求的延迟（⽆需再进⾏握⼿）长连接缺点减少了后续请求的延迟（⽆需再进⾏握⼿）http1.x 的长连接和 socket 的长连接区别HTTP1.1 通过使用 Connection:keep-alive 进行长连接，HTTP 1.1 默认进行持久连接。在一次 TCP 连接中可以完成多个 HTTP 请求，但是对每个请求仍然要单独发 headerKeep-Alive 不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如 Apache）中设定这个时间这种长连接是一种“伪链接”websocket 的长连接，是一个真的全双工。长连接第一次 tcp 链路建立之后，后续数据可以双方都进行发送，不需要发送请求头keep-alive 双方并没有建立正真的连接会话，服务端可以在任何一次请求完成后关闭。WebSocket 它本身就规定了是正真的、双工的长连接，两边都必须要维持住连接的状态。http1.x 和 http2 区别HTTP2 使用的是二进制传送，HTTP1.X 是文本（字符串）传送HTTP2 支持多路复用因为有流 ID，所以通过同一个 http 请求实现多个 http 请求传输变成了可能，可以通过流 ID 来标示究竟是哪个流从而定位到是哪个 http 请求HTTP2 头部压缩HTTP2 通过 gzip 和 compress 压缩头部然后再发送，同时客户端和服务器端同时维护一张头信息表，所有字段都记录在这张表中，这样后面每次传输只需要传输表里面的索引 Id 就行，通过索引 ID 查询表头的值HTTP2 支持服务器推送，HTTP2 支持在未经客户端许可的情况下，主动向客户端推送内容"},{"id":"c5ca62af56e287aef9b6b981b4847660","isRootIndexFile":false,"isIndexFile":false,"filename":"HTTPS.md","basename":"HTTPS","path":"/home/runner/work/qxtang.github.io/qxtang.github.io/网络","content":"HTTPSHTTP + SSL(TLS) = HTTPS是以安全为目的设计，http 明文传输不安全网景公司（Netscape）设置了 SSL 协议来对 http 协议传输的数据包进行加密处理TLS(Transport Layer Security) 是 SSL(Secure Socket Layer) 的后续版本需要 CA 证书，有成本默认端口号 443HTTPS 加解密流程对称加密常见的有 AES 算法加密与解密用的是同样的一个密钥效率高密钥越大，加密越强，但加密与解密的过程越慢通常使用相对较小的密钥，一般小于 256 bit缺点：不安全，在发送密钥的过程中，密钥有很大的风险会被黑客们拦截存储成本：每一个客户要生成一个不同的 key解决：通常的做法是将对称加密的密钥进行非对称加密，然后传送给需要它的人非对称加密常用的非对称加密算法是 RSA 算法使用了一对密钥，公钥 和 私钥，公钥进行加密，私钥用于解密私钥只能由一方安全保管，不能外泄，公钥可以发给任何请求它的人发送前，发送方先索要接受方公钥，发送方得到公钥后用其加密发送内容，接收方使用私钥解密内容不需要将私钥通过网络发送出去，因此安全性大大提高缺点：RSA 的运算速度非常慢（而对称加密的 AES 的加密速度比较快），效率低，性能问题对称与非对称结合（混合加密）在通信刚开始的时候使用非对称加密进行一系列认证，后续通信使用对称加密：接收方生成：非对称公钥和私钥发送方向接收方索要非对称公钥发送方生成：一个临时的对称加密密钥，往往是生成一个随机数发送方将对称密钥使用非对称公钥进行加密，然后发送接收方使用非对称私钥进行解密得到对称密钥然后双方可以使用对称加密来进行沟通中间人攻击（伪造非对称公钥）针对混合加密第一步，中间人可以伪造非对称公钥黑客事先设好自己的非对称公钥和私钥当黑客截获了发送方向接收方索取非对称公钥的消息，就把自己的非对称公钥发给发送方，同时也把截到的发送方的消息，继续发给接收方接收方收到索取公钥的请求，将公钥发送回并附带了一条信息，黑客截获了这个公钥之后，只将信息和黑客的公钥发给发送方，接收方的公钥黑客自己保留之后发送方就用了黑客的非对称公钥去加密自己的消息发给接收方，被黑客截获，黑客再用自己的非对称私钥去解密甚至可以随意篡改消息内容，用之前保留的接收方的公钥去加密消息，再发给接收方中间人攻击解决第三方公证机构（CA）介入接收方使用自己的公钥去 CA 开证明，CA 将接收方公钥、必要信息等包装成一个证书，能够证明接收方身份收到这个证书的发送方，就能确认这是接收方的公钥防止证书在传输过程中被黑客篡改服务器在发送浏览器的公钥中加入 CA 证书，浏览器可以验证 CA 证书的有效性接收方先把自己的公钥和必要信息用一个 hash 算法生成一个 数字摘要hash 算法特性：只要信息内容有一点的更改，重新使用该算法生成的 数字摘要 内容将会产生巨变CA 有自己的私钥和公钥CA 使用自己的私钥对该 数字摘要 进行加密，生成 数字签名把接收方的必要信息和 数字签名 合并，得到 数字证书发送方向接收方索要公钥时，接收方就把证书发给发送方发送方收到证书后，先用从证书内拿到的 hash算法 对接收方的原始信息生成新的 数字摘要再用 CA 的公钥对 数字签名 进行解密，也生成一个 数字摘要，如果接收方的信息被篡改了，hash 生成的摘要将会与 CA 公钥解密得到的摘要有巨大的不同由此可判定传过来的公钥等其他信息是否被中途篡改过如何验证证书的合法性首先浏览器读取证书中的证书所有者、有效期等信息进行校验，校验证书的网站域名是否与证书颁发的域名一致，校验证书是否在有效期内；浏览器开始查找操作系统中已内置的受新人的证书发布机构 CA，与服务器发来的证书中的颁发者 CA 比对，用于校验证书是否为合法机构颁发；如果找不到，浏览器就会报错，说明浏览器发来的证书是不可信任的；如果找到，那么浏览器就会从操作系统中取出颁发者 CA 的公钥（多数浏览器开发商发布版本时，会实现在内部植入常用认证机关的公开密钥），然后对服务器发来的证书里面的签名进行解密；浏览器使用相同的 hash 算法计算出服务器发来的证书的 hash 值，将这个计算的 hash 值与证书中签名做对比；对比结果一致，则证明服务器发来的证书合法，没有被冒充；SSL/TLS处于会话层TLS(Transport Layer Security) 是 SSL(Secure Socket Layer) 的后续版本，用于在互联网两台计算机之间用于身份验证和加密的一种协议通常情况下，HTTP 会先直接和 TCP 进行通信， 使用 SSL 后，则会先和 SSL 进行通信，然后再由 SSL 和 TCP 进行通信，HTTPS 就是身披了一层 SSL 的 HTTPSSL 是一个独立的协议，不只有 HTTP 可以使用，其他应用层协议也可以使用，比如 SMTP(电子邮件协议)、Telnet(远程登录协议) 等都可以使用TLS 的结构密钥交换算法 - 签名算法 - 对称加密算法 - 摘要算法 组成的一个密码串ECDHE-ECDSA-AES256-GCM-SHA384# 使用 ECDHE 进行密钥交换，使用 ECDSA 进行签名和认证，然后使用 AES 作为对称加密算法，密钥的长度是 256 位，使用 GCM 作为分组模式，最后使用 SHA384 作为摘要算法"},{"id":"edbcde9ad73872dc20f5bf13881f12c4","isRootIndexFile":false,"isIndexFile":true,"filename":"index.md","basename":"网络","path":"/home/runner/work/qxtang.github.io/qxtang.github.io/网络","content":"网络网络体系结构分层TCP/IP 通信传输流利用 TCP/IP 协议族进行网络通信时，会通过分层顺序与对方进行通信。发送端从应用层往下走，接收端则从链路层往上走发送端在层与层间传输数据时，没经过一层都会被加上首部信息，接收端每经过一层都会删除一条首部TCP/IP利用 IP 进行通信时所必须用到的协议群的统称，协议的集合具体来说，IP 或 ICMP、TCP 或 UDP、TELNET 或 FTP、以及 HTTP 等都属于 TCP/IP 协议族端口号用来识别同一台计算机中进行通信的不同应用程序。因此，它也被称为程序地址UDP处于 TCP/IP 分层模型中的传输层不提供复杂的控制机制，利用 IP 提供面向无连接的通信服务将应用程序发来的数据在收到的那一刻，立即按照原样发送到网络上的一种机制。即使是出现网络拥堵的情况，UDP 也无法进行流量控制等避免网络拥塞行为传输途中出现丢包，UDP 也不负责重发甚至当包的到达顺序出现乱序时也没有纠正的功能应用：1.包总量较少的通信（DNS、SNMP 等）；2.视频、音频等多媒体通信（即时通信）；3.限定于 LAN 等特定网络中的应用通信；4.广播通信（广播、多播）TCP处于 TCP/IP 分层模型中的传输层充分地实现了数据传输时各种控制功能，可以进行丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制作为一种面向有连接的协议，只有在确认通信对端存在时才会发送数据，从而可以控制通信流量的浪费在 IP 这种无连接的网络上也能够实现高可靠性的通信（ 主要通过检验和、序列号、确认应答、重发控制、连接管理以及窗口控制等机制实现）TCP 和 UDP 的区别tcp 是面向连接的，udp 是无连接的，即发送数据前不需要先建立链接tcp 提供可靠的服务，基于三次握手，UDP 是不可靠的tcp 只能是 1 对 1 的，UDP 支持 1 对 1,1 对多UDP 的头部开销比 TCP 的更小：tcp 的首部较大为 20 字节，而 UDP 只有 8 字节tcp 三次握手原因由 TCP 的自身特点可靠传输决定的，为了在数据通信开始之前先做好两端之间的准备工作客户端和服务端都需要知道各自是否可收发，因此需要三次握手，需要客户端和服务器端总共发送三个包以确认连接的建立第一次握手可以确认客服端的发送能力，第二次握手，确认了服务端的发送能力和接收能力，所以第三次握手才可以确认客户端的接收能力。不然容易出现丢包的现象三次握手过程客户端发送一个带 SYN=1，Seq=X 的数据包到服务器端口（第一次握手，由浏览器发起，告诉服务器我要发送请求了）服务器发回一个带 SYN=1，ACK=X+1，Seq=Y 的响应包以示传达确认信息（第二次握手，由服务器发起，告诉浏览器我准备接受了，你赶紧发送吧）客户端再回传一个带 ACK=Y+1，Seq=Z 的数据包，代表“握手结束”（第三次握手，由浏览器发送，告诉服务器，我马上就发了，准备接受吧）简版：1：客户端 –-&gt; 发送带有 SYN 标志的数据包–-&gt;服务端（我要发送请求了~）2：服务端 –-&gt; 发送带有 SYN/ACK 标志的数据包 -–&gt; 客户端（我准备接受了，你赶紧发送吧~）3：客户端 –-&gt; 发送带有带有 ACK 标志的数据包 -–&gt; 服务端（我马上就发了，准备接受吧~）tcp 四次挥手终止 TCP 连接，需要客户端和服务端总共发送 4 个包以确认连接的断开由于 TCP 连接是全双工的，因此，每个方向都必须要单独进行关闭四次挥手过程发起方向被动方发送报文，Fin、Ack、Seq，表示已经没有数据传输了。并进入 FIN_WAIT_1 状态。(第一次挥手：由浏览器发起的，发送给服务器，我请求报文发送完了，你准备关闭吧)被动方发送报文，Ack、Seq，表示同意关闭请求。此时主机发起方进入 FIN_WAIT_2 状态。(第二次挥手：由服务器发起的，告诉浏览器，我请求报文接受完了，我准备关闭了，你也准备吧)被动方向发起方发送报文段，Fin、Ack、Seq，请求关闭连接。并进入 LAST_ACK 状态。(第三次挥手：由服务器发起，告诉浏览器，我响应报文发送完了，你准备关闭吧)发起方向被动方发送报文段，Ack、Seq。然后进入等待 TIME_WAIT 状态。被动方收到发起方的报文段以后关闭连接。发起方等待一定时间未收到回复，则正常关闭。(第四次挥手：由浏览器发起，告诉服务器，我响应报文接受完了，我准备关闭了，你也准备吧)简版：1：客户端 --&gt; 发送一个 FIN，用来关闭客户端到服务器的数据传送（我请求报文发送完了，你准备关闭吧~）2：服务器 --&gt; 收到这个 FIN，发回一个 ACK，确认序号为收到的序号加 1。和 SYN 一样，一个 FIN 将占用一个序号（我请求报文接受完了，我准备关闭了，你也准备吧）3：服务器 --&gt; 关闭与客户端的连接，发送一个 FIN --&gt; 客户端（我响应报文发送完了，你准备关闭吧）4：客户端 --&gt; 发回 ACK 报文确认，并将确认序号设置为收到序号加 1（我响应报文接受完了，我准备关闭了，你也准备吧）DNS根据域名查出 IP 地址的服务WebSocketHTML5 提供的一种浏览器与服务器进行全双工通讯的网络技术，属于应用层协议基于 TCP 传输协议浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接， 并进行双向数据传输参考http://www.ruanyifeng.com/blog/2016/06/dns.htmlhttps://www.cnblogs.com/leezhxing/p/4524176.htmlhttps://juejin.cn/post/6844904100035821575https://juejin.cn/post/6844903510509633550"}]},{"id":"e3db49d633625ac1552e7dca23fb879e","isRootIndexFile":false,"isIndexFile":false,"filename":"AST抽象语法树.md","basename":"AST抽象语法树","path":"/home/runner/work/qxtang.github.io/qxtang.github.io","content":"AST 抽象语法树参考https://segmentfault.com/a/1190000016231512https://juejin.cn/post/6844903725228621832解析器 Parser把 js 源码转化为抽象语法树（AST）常用解析器https://github.com/babel/babel/tree/master/packages/babel-parserhttps://github.com/acornjs/acorn解析步骤两步：词法分析、语法分析词法分析把字符串形式的代码转换为 令牌（tokens）流，可以把令牌看作是一个扁平的语法片段数组例如：// 源n * n;// 词法分析结果[  { type: { ... }, value: &quot;n&quot;, start: 0, end: 1, loc: { ... } },  { type: { ... }, value: &quot;*&quot;, start: 2, end: 3, loc: { ... } },  { type: { ... }, value: &quot;n&quot;, start: 4, end: 5, loc: { ... } },]每一个 type 有一组属性来描述该令牌：const token = {  type: {    label: &#x27;name&#x27;,    keyword: undefined,    beforeExpr: false,    startsExpr: true,    rightAssociative: false,    isLoop: false,    isAssign: false,    prefix: false,    postfix: false,    binop: null,    updateContext: null,  },};语法分析根据词法分析的结果，也就是令牌 tokens，将其转换成 AST// 源function square(n) {  return n * n;}// ATSconst ast = {  type: &#x27;FunctionDeclaration&#x27;,  id: {    type: &#x27;Identifier&#x27;,    name: &#x27;square&#x27;,  },  params: [    {      type: &#x27;Identifier&#x27;,      name: &#x27;n&#x27;,    },  ],  body: {    type: &#x27;BlockStatement&#x27;,    body: [      {        type: &#x27;ReturnStatement&#x27;,        argument: {          type: &#x27;BinaryExpression&#x27;,          operator: &#x27;*&#x27;,          left: {            type: &#x27;Identifier&#x27;,            name: &#x27;n&#x27;,          },          right: {            type: &#x27;Identifier&#x27;,            name: &#x27;n&#x27;,          },        },      },    ],  },};应用IDE 使用，如代码风格检测(eslint 等)、代码的格式化，代码高亮，代码错误等等代码的混淆压缩转换代码工具，如 babelvue 模板编译过程prettierbabel-plugin-import将 antd 组件 import 语句转换成按需引入写法的 babel 插件"},{"id":"af171a65b1a63809e1e25aeda1e60fe1","isRootIndexFile":false,"isIndexFile":false,"filename":"CentOS.md","basename":"CentOS","path":"/home/runner/work/qxtang.github.io/qxtang.github.io","content":"CentOS转发虚拟机的服务给宿主（例如：xshell 通过 ssh 连接 VirtualBox 中的 centos）设置 -&gt; 网络 -&gt; 高级 -&gt; 端口转发主机 ip：127.0.0.1 或 不填主机端口：主机用于请求子系统 ip：可不填子系统端口：虚拟机中真实服务端口参考：https://blog.csdn.net/chengqiuming/article/details/83239413windows virtual box 无法创建、启动虚拟机解决方法run virtual box service as administrator (VBoxSVC.exe), if running kill it first.run virtual box main executable (VirtualBox.exe whatever is on your desktop) as adminstrator too首次安装sudo yum -y install lrzszsudo yum -y install curlsudo yum -y install wget安装最新版 git：sudo yum -y install https://packages.endpointdev.com/rhel/7/os/x86_64/endpoint-repo.x86_64.rpm &amp;&amp; sudo yum -y install git参考：https://computingforgeeks.com/install-git-2-on-centos-7/关防火墙：sudo systemctl stop firewalld.service &amp;&amp; sudo systemctl disable firewalld.service安装 nginxsudo yum -y install epel-release &amp;&amp; sudo yum update &amp;&amp; sudo yum -y install nginx参考：https://blog.csdn.net/zhou_438/article/details/89554438安装 Jenkins参考：https://blog.csdn.net/Mr_Bobcp/article/details/130464060yum install java-11-openjdk &amp;&amp; \\wget https://mirrors.aliyun.com/jenkins/redhat/jenkins-2.390-1.1.noarch.rpm &amp;&amp; \\rpm -ivh jenkins-2.390-1.1.noarch.rpm设置开机启动systemctl start jenkins参考：https://www.cnblogs.com/supiaopiao/p/12160541.html"},{"id":"1b720adc958d7aa65c28ee132123bd7d","isRootIndexFile":false,"isIndexFile":false,"filename":"Linux 命令.md","basename":"Linux 命令","path":"/home/runner/work/qxtang.github.io/qxtang.github.io","content":"Linux 命令查看pwdll、lscathead -2 file1 查看前几行lesstail -3 file1 查看一个文件的最后三行top 查看内存free -m 查看内存统计cd / &amp;&amp; du -sh * 查看任意目录下文件夹大小df -h 查看磁盘空间大小ip addr、ifconfiggrepgrep str /tmp/test 在文件 ‘/tmp/test’ 中查找 “str”grep ^str /tmp/test 在文件 ‘/tmp/test’ 中查找以 “str” 开始的行grep [0-9] /tmp/test 查找 ‘/tmp/test’ 文件中所有包含数字的行grep str -r /tmp/* 在目录 ‘/tmp’ 及其子目录中查找 “str”findfind / -name file1 从 ‘/’ 开始进入根文件系统查找文件和目录find /home/user1 -name *.bin 在目录 ‘/ home/user1’ 中查找以 ‘.bin’ 结尾的文件文件操作mkdirmvrmcptouch file1其他diff file1 file2 找出两个文件的不同sdiff file1 file2 以对比的方式显示两个文件的不同shutdown -h now 立即关机shutdown -r now 立即重启man 查看参考手册（例如 man ping）压缩tar -cvf archive.tar file1 把 file1 打包成 archive.tar（-c: 建立压缩档案；-v: 显示所有过程；-f: 使用档案名字，是必须的，是最后一个参数）tar -xvf archive.tar 释放一个包tar -xvf archive.tar -C /tmp 把压缩包释放到 /tmp 目录下vii 编辑模式:w :w! 保存:q :q! 退出:wq 保存并且退出x 删除当前光标所在处的字符dd 删除游标所在的那一整行ndd n 为数字。删除光标所在的向下 n 行，例如 20dd 则是删除 20 行yy 复制游标所在的那一行nyy n 为数字。复制光标所在的向下 n 行，例如 20yy 则是复制 20 行p, P p 为粘贴游标下一行，P 则为粘贴在游标上一行u 撤销ctrl + r 重做上一个动作防火墙systemctl stop firewalld.servicesystemctl disable firewalld.servicesystemctl restart iptables.servicesystemctl enable iptables.servicelrzszrz 上传rz -y 覆盖上传sz 下载"},{"id":"8e7beee6d2cd7d2325c189032a4f6012","isRootIndexFile":false,"isIndexFile":false,"filename":"WebAssembly.md","basename":"WebAssembly","path":"/home/runner/work/qxtang.github.io/qxtang.github.io","content":"WebAssembly定义可移植、体积小、加载快并且兼容 Web 的全新格式，十六进制的 Binary Code，是一种编译产出物与 JavaScript 是协作关系https://webassembly.org/由来为了更好的性能，javascript 执行过程：代码 -&gt; AST -&gt; 字节码 -&gt; 字节码进入翻译器，将字节码一行一行的翻译成机器码执行 WebAssembly 没有这些步骤使用场景对性能有很高要求的 App/Module/ 游戏在 Web 中使用 C/C++/Rust/Go 的库工具https://github.com/AssemblyScript/assemblyscripthttps://github.com/kripken/emscriptenhttps://github.com/WebAssembly/wabt"},{"id":"index","isRootIndexFile":true,"isIndexFile":true,"filename":"index.md","basename":"index","path":"/home/runner/work/qxtang.github.io/qxtang.github.io","content":"✒ 工作与日常学习笔记via：doc-builder"},{"id":"9ca2a634dde58497e71f5ebe2ec4a192","isRootIndexFile":false,"isIndexFile":false,"filename":"前端工具链.md","basename":"前端工具链","path":"/home/runner/work/qxtang.github.io/qxtang.github.io","content":"前端工具链NodeJsfs-extraorachalkchokidarcommandershelljsrouting-controllersnodemailernode-schedule基础设施verdaccio工程化eslintprettiereslint-config-prettiereslint-plugin-prettiernpm-run-allmockjsstorybooklernacross-envhuskycommitlintcommitizenconventional-changelog构建ViteWebpackBabel编程工具lodashbody-scroll-lockdayjsqshttps://github.com/sindresorhus/file-typeechartsswiperhtml2canvashttps://github.com/unshiftio/url-parsehttps://github.com/alibaba/x-renderbetter-scrollclipboard.jshammer.jspopmotionimmutable-jshttps://github.com/kenwheeler/slickhttps://github.com/SortableJS/Sortablehttps://github.com/DataV-Team/DataVhttps://github.com/alibaba/formilyasync-poolCSSpostcss-px-to-viewportUI 框架ant-designhttps://procomponents.ant.design/Reacthttps://create-react-app.dev/ahooksstyled-componentsclassnamesunstated-nextreduxredux-toolkitreact-dndhttps://github.com/framer/motionreact-motionReact Form https://github.com/TanStack/formhttps://github.com/TanStack/tablereact-i18nextformikVuevuexvue-router网络axiosreact-queryswr调试工具ts-nodespy-debuggervconsole小程序Taro"},{"id":"91cddc44e8c0f27fe5a0290f334ada7e","isRootIndexFile":false,"isIndexFile":false,"filename":"单元测试.md","basename":"单元测试","path":"/home/runner/work/qxtang.github.io/qxtang.github.io","content":"单元测试概念是指对软件中的最小可测试单元进行检查和验证当通过手动重新运行来测试代码时，很容易漏掉一些东西对于单元测试中单元的含义，一般来说，要根据实际情况去判定其具体含义，如 C 语言中单元指一个函数，Java 里单元指一个类，图形化的软件中可以指一个窗口或一个菜单等。总的来说，单元就是人为规定的最小的被测功能模块。单元测试是在软件开发过程中要进行的最低级别的测试活动，软件的独立单元将在与程序的其他部分相隔离的情况下进行测试自动化测试测试是独立于代码的以各种方式运行我们的函数，并将结果与预期结果进行比较行为驱动开发（BDD）规范先行，实现在后简单来说就是首先写一些暂时无法通过的测试，然后去实现它们包含了三部分内容：测试、文档和示例前端常用单元测试框架mocha、Jest 提供了单元测试所需的各种 API，你可以使用它们来对你的代码进行单元测试参考https://zh.javascript.info/testing-mocha"},{"id":"54c29119da89e3edf1afb1ec4f51fb6c","isRootIndexFile":false,"isIndexFile":false,"filename":"工作问题记录.md","basename":"工作问题记录","path":"/home/runner/work/qxtang.github.io/qxtang.github.io","content":"工作问题记录nginx 配置使用 location 前缀匹配，某些服务的前缀有相同部分，比如 /api-serve1、/api-serve2，流量转发到了后面的服务前缀匹配命中后，会继续更长前缀匹配和正则匹配。可换成使用 ~ 来匹配，这是区分大小写的正则匹配，按顺序匹配，一旦匹配即停止后续匹配。小程序适配 iphonex 机型底部安全区域padding-bottom: constant(safe-area-inset-bottom);css module 的局限性，无法准确预测类名// 例如这样的写法，使用了 css module 不会生效// 鼠标经过某个子节点同时想要修改父节点的样式.parent {  color: red;}.children {  &amp;:hover .parent {    color: yellow;  }}MySQL 数据库使用 utf8 编码格式 无法保存 emoji 表情改成 utf8mb4是 MySQL 的一个历史遗留问题，utf8mb4 才是真正的 UTF-8在 MySQL 中，“utf8”编码只支持每个字符最多三个字节，中文是占 3 个字节，其他数字、英文、符号占一个字节而真正的 UTF-8 是每个字符最多四个字节，emoji 符号占 4 个字节，一些较复杂的文字、繁体字也是 4 个字节MySQL 一直没有修复这个 bug，他们在 2010 年发布了一个叫作“utf8mb4”的字符集，绕过这个问题IOS 无法通过 volume 属性设置 video 音量，读取总是返回 1官方文档说必须通过用户操作https://developer.apple.com/library/archive/documentation/AudioVideo/Conceptual/Using_HTML5_Audio_Video/Device-SpecificConsiderations/Device-SpecificConsiderations.htmltypescript 工程，编译产物每一个文件都产生多余辅助函数https://www.typescriptlang.org/tsconfig#importHelpersrendering twice because of strict modehttps://stackoverflow.com/questions/61254372/my-react-component-is-rendering-twice-because-of-strict-modeuseEffect hook, dom ref is null in unmount callbackhttps://github.com/facebook/react/issues/20875https://reactjs.org/blog/2020/08/10/react-v17-rc.html#effect-cleanup-timingH5 页面在 iphone 手机底部出现留白meta viewport，加入 viewport-fit=cover&lt;meta  name=&quot;viewport&quot;  content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0, viewport-fit=cover&quot;/&gt;解决 Git 默认不区分文件名大小写的问题git config core.ignorecase falsehttps://www.jianshu.com/p/df0b0e8bcf9bError [ERR_MODULE_NOT_FOUND]: Cannot find module in JSimport 的时候加上 .js 拓展名https://bobbyhadz.com/blog/javascript-error-err-module-not-found-cannot-find-module元素高度适配不同宽高比的屏幕，比如经常碰到在 IPhoneSE 中元素位置不符合设计稿，适配前，元素 top 属性即使经过 postcss 插件 px2vw 动态计算，由于不同设备宽高比不一致，会出现明显位置不正确现象，IPhoneSE 之类机型最明显通过封装 adapterTop 函数，计算正确的 top，动态设置 top 属性。（1650 为设计稿高度）// js 函数export const adapterTop = (top: number) =&gt; {  const topVw = px2vw(top);  const offsetTopVw = (px2vw(1650) - (document.body.offsetHeight / document.body.offsetWidth) * 100) / 2;  return `${topVw - offsetTopVw}vw`;};// less 函数.adapter-top(@top: 0px) {  top: calc(@top - ((1650px - 100vh) / 2));}Canvas drawImage 在高清屏幕下变模糊function setupCanvas(canvas) {  // Get the device pixel ratio, falling back to 1.  var dpr = window.devicePixelRatio || 1;  // Get the size of the canvas in CSS pixels.  var rect = canvas.getBoundingClientRect();  // Give the canvas pixel dimensions of their CSS  // size * the device pixel ratio.  canvas.width = rect.width * dpr;  canvas.height = rect.height * dpr;  var ctx = canvas.getContext(&#x27;2d&#x27;);  // Scale all drawing operations by the dpr, so you  // don&#x27;t have to worry about the difference.  ctx.scale(dpr, dpr);  return ctx;}代码维护与多人协作问题使用 gitflow 分支模型对项目代码进行管理项目集成 eslint、prettier、commitlint 等工具禁止安装私人 npm 包merge request金管家游戏专区与游戏供应商对接问题根据业务需求，游戏专区的每一个游戏都需要添加：埋点上报、初始化 app js sdk、接入兔展配置中心、设置 app 右上角分享参数等繁琐功能将这些繁琐操作封装成 jssdk 供游戏供应商使用，供应商不需要关心底层细节某一时刻 token 失效，多个接口同时报错，弹出多个提示问题方案一：对提示组件使用单例模式进行封装，同一时刻只允许一个提示存在，每次调用提示组件时，销毁之前的调用，只执行最新的调用方案二：改进请求封装，设置一个变量用于保存当前 token 是否失效，如果已失效，则不再发起后面的请求线上问题定位追溯构建发布时，将构建信息（构建分支、构建人、构建时间等）通过 Webpack 的 DefinePlugin 定义进全局变量，把这些信息在控制台打印出来，方便追溯问题生产包设置点击右下角 10 下弹出 vconsole 控制台ios 使用渐变背景出现诡异线条https://stackoverflow.com/questions/30914299/weird-horizontal-line-with-gradient-in-retina-safari"},{"id":"a2374d9b519720a592f4d7bf8120f21a","isRootIndexFile":false,"isIndexFile":false,"filename":"设计模式.md","basename":"设计模式","path":"/home/runner/work/qxtang.github.io/qxtang.github.io","content":"设计模式参考：https://juejin.cn/post/7072175210874535967https://juejin.cn/post/6844904032826294286常用设计原则单一职责原则一个程序只做好一件事如果功能过于复杂就拆分开，每个部分保持独立比如 Promise，每个 then 只做一件事开放/封闭原则对扩展开放，对修改封闭增加需求时，扩展新代码，而非修改已有代码比如 Promise，如果新增需求，扩展 then比如为表单校验类增加拓展接口而不是修改内部代码// 优化前let checkType = function (str, type) {  switch (type) {    case &#x27;email&#x27;:      return /^[\\w-]+(\\.[\\w-]+)*@[\\w-]+(\\.[\\w-]+)+$/.test(str);    case &#x27;mobile&#x27;:      return /^1[3|4|5|7|8][0-9]{9}$/.test(str);    case &#x27;tel&#x27;:      return /^(0\\d{2,3}-\\d{7,8})(-\\d{1,4})?$/.test(str);    default:      return true;  }};// const result = checkType(&#x27;165226226326&#x27;,&#x27;mobile&#x27;)// 优化后let checkType = (function () {  let rules = {    email(str) {      return /^[\\w-]+(\\.[\\w-]+)*@[\\w-]+(\\.[\\w-]+)+$/.test(str);    },    mobile(str) {      return /^1[3|4|5|7|8][0-9]{9}$/.test(str);    },  };  //暴露接口  return {    //校验    check(str, type) {      return rules[type] ? rules[type](str) : false;    },    //添加规则    addRule(type, fn) {      rules[type] = fn;    },  };})();console.log(checkType.check(&#x27;188170239&#x27;, &#x27;mobile&#x27;));checkType.addRule(&#x27;money&#x27;, function (str) {  return /^[0-9]+(.[0-9]{2})?$/.test(str);});console.log(checkType.check(&#x27;18.36&#x27;, &#x27;money&#x27;));里氏替换原则子类能覆盖父类父类能出现的地方子类就能出现接口隔离原则保持接口的单一独立依赖倒转原则面向接口编程，依赖于抽象而不依赖于具体使用方只关注接口而不关注具体类的实现设计模式分类创建型单例模式原型模式工厂模式抽象工厂模式建造者模式组合型（结构型）适配器模式装饰器模式代理模式外观模式桥接模式组合模式享元模式行为型观察者模式迭代器模式策略模式模板方法模式职责链模式命令模式备忘录模式状态模式访问者模式中介者模式解释器模式单例模式场景：登录框、vuex 和 redux 中的 store一个类只有一个实例，并提供一个访问它的全局访问点划分命名空间，减少全局变量只会实例化一次。简化了代码的调试和维护，节约内存有可能导致模块间的强耦合，从而不利于单元测试示例class LoginForm {  constructor() {    this.state = &#x27;hide&#x27;;  }  show() {    if (this.state === &#x27;show&#x27;) {      return;    }    this.state = &#x27;show&#x27;;    console.log(&#x27;显示&#x27;);  }  hide() {    if (this.state === &#x27;hide&#x27;) {      return;    }    this.state = &#x27;hide&#x27;;    console.log(&#x27;隐藏&#x27;);  }}LoginForm.getInstance = (function () {  let instance;  return function () {    if (!instance) {      instance = new LoginForm();    }    return instance;  };})();let obj1 = LoginForm.getInstance();obj1.show();let obj2 = LoginForm.getInstance();obj2.hide();console.log(obj1 === obj2); // true工厂模式场景需要依赖具体环境创建不同实例，实例都有相同的行为扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以示例class Product {  constructor(name) {    this.name = name;  }  init() {    console.log(&#x27;init&#x27;);  }  fun() {    console.log(&#x27;fun&#x27;);  }}class Factory {  create(name) {    return new Product(name);  }}let factory = new Factory();let p = factory.create(&#x27;p1&#x27;);p.init();p.fun();适配器模式将一个类的接口转化为另外一个接口，以满足需求，使类之间接口不兼容问题通过适配器得以解决可以让任何两个没有关联的类一起运行，提高了类的复用额外对象的创建，非直接调用，存在一定的开销场景：整合第三方 SDK、封装旧接口适配器与代理模式相似，适配器模式提供一个不同的接口，代理模式提供一模一样的接口示例class Plug {  getName() {    return &#x27;iphone充电头&#x27;;  }}class Target {  constructor() {    this.plug = new Plug();  }  getName() {    return this.plug.getName() + &#x27; 适配器Type-c充电头&#x27;;  }}let target = new Target();target.getName();// 自己封装的ajax， 使用方式如下ajax({ url: &#x27;/getData&#x27;, type: &#x27;Post&#x27;, dataType: &#x27;json&#x27;, data: { test: 111 } }).done(function () {});// 因为历史原因，代码中全都是：// $.ajax({....})// 做一层适配器var $ = {  ajax: function (options) {    return ajax(options);  },};装饰者模式在不改变原对象的基础上，动态的给对象添加额外职责，对其进行包装扩展，是实现继承的一种替代方案装饰类和被装饰类都只关心自身的核心业务，实现了解耦方便动态的扩展功能，且提供了比继承更多的灵活性缺点多层装饰比较复杂常常会引入许多小对象，看起来比较相似，实际功能大相径庭代理模式为一个对象提供一个代用品或占位符，以便控制对它的访问能将代理对象与被调用对象分离，降低耦合度，可以起到保护目标对象的作用代理对象可以扩展目标对象的功能，通过修改代理对象就可以了，符合开闭原则场景做授权控制HTML 元素事件代理ES6 的 proxy缺点处理请求速度可能有差别，非直接访问存在开销外观模式为子系统的一组接口提供一个一致的界面，定义了一个高层接口，这个接口使子系统更加容易使用减少系统相互依赖，提高灵活性、安全性缺点：不符合开闭原则，如果要改东西很麻烦，继承重写都不合适场景兼容浏览器事件绑定设计初期，应该要有意识地将不同的两个层分离，比如经典的三层结构，在数据访问层和业务逻辑层、业务逻辑层和表示层之间建立外观 Facade在开发阶段，子系统往往因为不断的重构演化而变得越来越复杂，增加外观 Facade 可以提供一个简单的接口，减少他们之间的依赖在维护一个遗留的大型系统时，可能这个系统已经很难维护了，这时候使用外观 Facade 也是非常合适的，为系系统开发一个外观 Facade 类，为设计粗糙和高度复杂的遗留代码提供比较清晰的接口，让新系统和 Facade 对象交互，Facade 与遗留代码交互所有的复杂工作观察者模式（发布订阅模式）定义了一种一对多的关系，让多个观察者对象同时监听某一个主题对象，这个主题对象的状态发生变化时就会通知所有的观察者对象，使它们能够自动更新自己，当一个对象的改变需要同时改变其它对象，并且它不知道具体有多少对象需要改变的时候，就应该考虑使用观察者模式缺点：过度使用会导致对象与对象之间的联系弱化，会导致难以跟踪维护和理解场景DOM 事件vue 事件总线状态模式允许一个对象在其内部状态改变的时候改变它的行为，对象看起来似乎修改了它的类迭代器模式提供一种方法顺序一个聚合对象中各个元素，而又不暴露该对象的内部表示访问一个聚合对象的内容而无需暴露它的内部表示为遍历不同的集合结构提供一个统一的接口，从而支持同样的算法在不同的集合结构上进行操作对于集合内部结果常常变化各异，不想暴露其内部结构的话，但又想让客户代码透明的访问其中的元素，可以使用迭代器模式场景Array.prototype.forEachES6 Iterator示例class Iterator {  constructor(conatiner) {    this.list = conatiner.list;    this.index = 0;  }  next() {    if (this.hasNext()) {      return this.list[this.index++];    }    return null;  }  hasNext() {    if (this.index &gt;= this.list.length) {      return false;    }    return true;  }}class Container {  constructor(list) {    this.list = list;  }  getIterator() {    return new Iterator(this);  }}let container = new Container([1, 2, 3, 4, 5]);let iterator = container.getIterator();while (iterator.hasNext()) {  console.log(iterator.next());}桥接模式将抽象部分与它的实现部分分离，使它们都可以独立地变化有助于独立地管理各组成部分， 把抽象化与实现化解耦大量的类将导致开发成本的增加，同时在性能方面可能也会有所减少示例class Color {  constructor(name) {    this.name = name;  }}class Shape {  constructor(name, color) {    this.name = name;    this.color = color;  }  draw() {    console.log(`${this.color.name} ${this.name}`);  }}let red = new Color(&#x27;red&#x27;);let yellow = new Color(&#x27;yellow&#x27;);let circle = new Shape(&#x27;circle&#x27;, red);circle.draw();let triangle = new Shape(&#x27;triangle&#x27;, yellow);triangle.draw();组合模式通过对象的多态表现，使得用户对单个对象和组合对象的使用具有一致性希望用户忽略组合对象和单个对象的不同，用户将统一地使用组合结构中的所有对象示例class TrainOrder {  create() {    console.log(&#x27;创建火车票订单&#x27;);  }}class HotelOrder {  create() {    console.log(&#x27;创建酒店订单&#x27;);  }}class TotalOrder {  constructor() {    this.orderList = [];  }  addOrder(order) {    this.orderList.push(order);    return this;  }  create() {    this.orderList.forEach((item) =&gt; {      item.create();    });    return this;  }}// 可以在购票网站买车票同时也订房间let train = new TrainOrder();let hotel = new HotelOrder();let total = new TotalOrder();total.addOrder(train).addOrder(hotel).create();原型模式用原型实例指向创建对象的种类，并且通过拷贝这些原型创建新的对象示例class Person {  constructor(name) {    this.name = name;  }  getName() {    return this.name;  }}class Student extends Person {  constructor(name) {    super(name);  }  sayHello() {    console.log(`Hello， My name is ${this.name}`);  }}let student = new Student(&#x27;xiaoming&#x27;);student.sayHello();策略模式组成：一组策略类，封装了具体的算法，并负责具体的计算过程；环境类，接受客户的请求，将请求委托给某一个策略定义一系列的算法，把它们一个个封装起来，并且使它们可以互相替换可以有效的避免多重条件选择语句提供了对开放-封闭原则的支持，将算法封装在独立的策略中，使得它们易于切换，理解，易于扩展场景一个系统需要动态地在几种算法中选择一种表单验证模板方法模式模板方法模式由抽象父类、具体的实现子类组成。在抽象父类中封装了子类的算法框架，实现一些公共方法和封装子类中所有方法的执行顺序子类通过继承这个抽象类，也继承了整个算法结构，并且可以选择重写父类的方法场景一次性实现一个算法的不变的部分，并将可变的行为留给子类来实现子类中公共的行为应被提取出来并集中到一个公共父类中的避免代码重复示例class Beverage {  constructor({ brewDrink, addCondiment }) {    this.brewDrink = brewDrink;    this.addCondiment = addCondiment;  }  /* 烧开水，共用方法 */  boilWater() {    console.log(&#x27;水已经煮沸=== 共用&#x27;);  }  /* 倒杯子里，共用方法 */  pourCup() {    console.log(&#x27;倒进杯子里===共用&#x27;);  }  /* 模板方法 */  init() {    this.boilWater();    this.brewDrink();    this.pourCup();    this.addCondiment();  }}/* 咖啡 */ const coffee = new Beverage({  /* 冲泡咖啡，覆盖抽象方法 */  brewDrink: function () {    console.log(&#x27;冲泡咖啡&#x27;);  },  /* 加调味品，覆盖抽象方法 */  addCondiment: function () {    console.log(&#x27;加点奶和糖&#x27;);  },});coffee.init();命令模式将一个请求封装成一个对象，从而让你使用不同的请求把客户端参数化，对请求排队或者记录请求日志，可以提供命令的撤销和恢复功能命令发出者和接受者解耦，使发出者不需要知道命令的具体执行过程即可执行示例// 接收者类class Receiver {  execute() {    console.log(&#x27;接收者执行请求&#x27;);  }}// 命令者class Command {  constructor(receiver) {    this.receiver = receiver;  }  execute() {    console.log(&#x27;命令&#x27;);    this.receiver.execute();  }}// 触发者class Invoker {  constructor(command) {    this.command = command;  }  invoke() {    console.log(&#x27;开始&#x27;);    this.command.execute();  }}// 仓库const warehouse = new Receiver();// 订单const order = new Command(warehouse);// 客户const client = new Invoker(order);client.invoke();中介者模式所有的相关对象都通过中介者对象来通信，而不是互相引用使网状的多对多关系变成了相对简单的一对多关系类似于观察者模式，但是单向的，由中介者统一管理例如表单的 onchange 事件，无论是输入框还是单选按钮，都统一与 onchange 通信，由 onchange 统一处理事件类型的差异，实现各个事件间的解耦"}]