[{"id":"079c4846f4492de09e5c456d89c26df5","dirname":"工作沉淀","filename":"","basename":"","path":"/home/runner/work/qxtang.github.io/qxtang.github.io","children":[{"id":"c259441ba1b59e345b9198134fbe688a","filename":"ADB 通过 Wi-Fi 调试手机.md","basename":"ADB 通过 Wi-Fi 调试手机","path":"/home/runner/work/qxtang.github.io/qxtang.github.io/工作沉淀","content":"ADB 通过 Wi-Fi 调试手机手机和电脑需连接在同一 WiFi 下手机启用开发者选项和无线调试模式允许无线调试后，选择使用配对码配对，adb pair ip:port，填写显示的配对码、IP 地址和端口号运行 adb connect ip:port"},{"id":"18ee921cd515e914d7e5a89fd6bba176","filename":"GitFlow 笔记.md","basename":"GitFlow 笔记","path":"/home/runner/work/qxtang.github.io/qxtang.github.io/工作沉淀","content":"GitFlow 笔记简单记录工作中使用 gitflow 模型管理代码版本、保证代码安全的方法。参考：A successful Git branching modelGit 工作流程Git 分支管理策略git flow 的使用GitFlow 原理浅析gitflow 现在被认为过于复杂，可能不适用于现代软件开发：如何看待 Git flow 发明人称其不适用于持续交付？Issues with git-flow在阿里，我们如何管理代码分支？分支类型master只有一条主分支只读，只能从分支 release 或 hotfix 合并进来所有发生在 master 分支的修改应该打 tag 做记录，方便追溯develop只有一条主开发分支，基于 master 分支克隆包含所有要发布到下一个 release 的代码只读，只能从 feature 或 release 合并进来feature 功能分支完成开发后，合并到 develop，合并到 develop 前，提交合并申请，与 develop 分支进行比较做代码审查，审查通过则允许合并从 develop 拉取 release 分支，提测release 或 hotfix 分支上线完毕，合并回 develop。feature功能开发分支，基于 develop 分支克隆，主要用于新需求新功能的开发有多条，按功能划分，如：/feature/20200712-新增用户、/feature/20200801-登陆注册可以几个人一起开发一条 feature，也可以一人负责一条 feature功能开发完毕后，提测前，合并到 develop 分支feature 类型的分支可同时存在多个，用于团队中多个功能同时开发，属于临时分支，功能完成后可选择删除release版本分支，用于测试与上线，基于 feature 分支合并到 develop 之后，从 develop 分支克隆有多条，按版本划分，如：/release/20200712-第一版v0.1、/release/20200713-第二版v0.2release 类型的分支主要用于测试和修改 bug，完成上线后合并回 develop 与 master 分支hotfix补丁分支，基于 master 分支克隆，主要用于对线上的版本进行 BUG 修复有多条，按版本划分，如：/hotfix/20200712-修复xss漏洞、/hotfix/20200713-修复新增用户失败bug修复完毕后合并回 develop 与 master 分支主要工作流程示例初始化项目，创建 master 分支，然后从 master 拉取 develop 分支根据需求划分功能，从 develop 拉取 feature 分支进行编码开发，如/feature/20200712-新增用户、/feature/20200801-登陆注册feature 分支完成后，合并到 develop 前，提交合并申请，与 develop 比较，进行代码审查，合并完成可以选择删除当前 feature需要发布时，从 develop 拉取 release 分支进行测试，例如/release/20200712-第一版，测试过程中在该条 release 分支上修改 BUG，测试通过后将该条 release 分支发布回归：任一 release 分支通过测试上线后，合并该 release 分支到 develop 与 master，master 分支打 tag，当前 release 不可修改，线上有问题须从 master 拉取 hotfix 分支进行修改通知所有进行中的 feature、release 把 master 合进来一次上线之后若发现 bug，从 master 拉取 hotfix 进行 bug 修改，如/hotfix/20200713-修复新增用户失败bughotfix 通过测试上线后，合并 hotfix 分支到 develop 与 master，master 分支打 tag版本回退：如果需进行版本回退，则选择上一版本号的 release 分支进行发布分支名称可以使用 YYYYMMDD-功能名称 这样的格式，因为这样的命名格式，git gui 工具或者命令行上显示的时候是会自动根据前面的时间来排序，找分支找起来比较方便"},{"id":"e9a2550e8c53d313e8e31853512a444e","filename":"Nginx 笔记.md","basename":"Nginx 笔记","path":"/home/runner/work/qxtang.github.io/qxtang.github.io/工作沉淀","content":"Nginx 笔记工作中经常用的，简单记录一下。实用跨域# 这里约定代理请求url path是以/apis/开头location ^~/apis/ {    # 这里重写了请求，将正则匹配中的第一个()中$1的path，拼接到真正的请求后面，并用break停止后续匹配    rewrite ^/apis/(.*)$ /$1 break;    ...    proxy_pass https://www.tianqiapi.com/;}处理前端单页应用的 history 路由模式location / {    try_files $uri $uri/ /index.html;}适配 PC 和移动环境location / {    # 移动、pc设备适配    if ($http_user_agent ~* &#x27;(Android|webOS|iPhone|iPod|BlackBerry)&#x27;) {        set $mobile_request &#x27;1&#x27;;    }    if ($mobile_request = &#x27;1&#x27;) {        rewrite ^.+ http://mysite-base-H5.com;    }}端口转发http {    ...    upstream dmp8001 {        server 127.0.0.1:8001;    }    server {        listen       80;        server_name  abc.com;        location / {            ...            proxy_pass http://dmp8001;        }    }    ...}善用正则# 动态校验企业微信 h5 应用可信域名location ~ WW_verify_(.*).txt {    return 200 $1;}虚拟主机server {    listen 12332;    server_name 127.0.0.1;    location / {        root D:/Desktop/test;        index index.html index.htm;    }}防媒体文件盗链location ~* \\.(gif|jpg|png|jpeg|mp4)$ {    expires 30d;    valid_referers *.hugao8.com www.hugao8.com m.hugao8.com *.baidu.com *.google.com;    if ($invalid_referer) {        rewrite ^/ http://ww4.sinaimg.cn/bmiddle/051bbed1gw1egjc4xl7srj20cm08aaa6.jpg;        # return 404;    }}简单实现负载均衡轮询（默认），请求过来后，Nginx 随机分配流量到任一服务器upstream backend {    server 127.0.0.1:3000;    server 127.0.0.1:3001;}weight=number 设置服务器的权重，默认为 1，权重大的会被优先分配upstream backend {    server 127.0.0.1:3000 weight=2;    server 127.0.0.1:3001 weight=1;}backup 标记为备份服务器。当主服务器不可用时，将传递与备份服务器的连接upstream backend {    server 127.0.0.1:3000 backup;    server 127.0.0.1:3001;}代理这个集群server {    listen      9000;    server_name localhost;    location / {        proxy_set_header Host $http_host;        proxy_set_header X-Real-IP $remote_addr;        proxy_set_header X-Scheme $scheme;        proxy_pass backend;    }}关于 location 的匹配location 的几种匹配方式普通匹配：location = URI { configuration } #精确匹配location ^~ URI { configuration } #非正则匹配location [空格] URI { configuration } #前缀匹配正则匹配：location ~ URI { configuration } #区分大小写location ~* URI { configuration } #不区分大小写几种匹配方式的说明与优先级整体规则按照先普通匹配，然后再正则匹配，如果正则不匹配，则回退至上一个普通匹配。其中普通匹配没有顺序之分，哪个匹配最精确，就使用哪个 location，正则匹配按照规则的书写顺序进行。= 精确匹配，匹配后停止后续匹配，直接执行该匹配后的 configuration。[空格] 前缀匹配，匹配后，继续更长前缀匹配和正则匹配。^~ 不属于正则匹配，匹配该规则后，停止继续正则匹配。~ 区分大小写的正则匹配，按顺序匹配，一旦匹配即停止后续匹配。~* 不区分大小写的正则匹配，按顺序匹配，一旦匹配即停止后续匹配。示例location = / {    [ configuration A ]}location / {    [ configuration B ]}location /user/ {    [ configuration C ]}location ^~ /images/ {    [ configuration D ]}location ~* \\.(gif|jpg|jpeg)$ {    [ configuration E ]}请求/精准匹配 A，不再往下查找。请求/index.html匹配 B。首先查找匹配的前缀字符，找到最长匹配是配置 B，接着又按照顺序查找匹配的正则。结果没有找到，因此使用先前标记的最长匹配，即配置 B。请求/user/index.html匹配 C。首先找到最长匹配 C，由于后面没有匹配的正则，所以使用最长匹配 C。请求/user/1.jpg匹配 E。首先进行前缀字符的查找，找到最长匹配项 C，继续进行正则查找，找到匹配项 E。因此使用 E。请求/images/1.jpg匹配 D。首先进行前缀字符的查找，找到最长匹配 D。但是，特殊的是它使用了^~修饰符，不再进行接下来的正则的匹配查找，因此使用 D。这里，如果没有前面的修饰符，其实最终的匹配是 E。大家可以想一想为什么。请求/documents/about.html匹配 B。因为 B 表示任何以/开头的 URL 都匹配。在上面的配置中，只有 B 能满足，所以匹配 B。总结location 的配置有两种形式，普通和正则。查找匹配的时候，先查找普通，选择最长匹配项，再查找正则。正则的优先级高于普通。正则查找是按照在配置文件中的顺序进行的，因此正则顺序很重要，建议越精细的放的越靠前。使用=精准匹配可以加快查找的效率，如果经常被访问建议使用精确匹配=。"},{"id":"b113ce2d11fb3ad7fc3a16d27da51e74","filename":"工作中遇到问题汇总.md","basename":"工作中遇到问题汇总","path":"/home/runner/work/qxtang.github.io/qxtang.github.io/工作沉淀","content":"工作中遇到问题汇总Q：某个站点的 nginx 配置使用 location 前缀匹配，某些服务的前缀有相同部分，比如 /api-serve1、/api-serve2，流量转发到了后面的服务A：前缀匹配命中后，会继续更长前缀匹配和正则匹配。可换成使用 ~ 来匹配，这是区分大小写的正则匹配，按顺序匹配，一旦匹配即停止后续匹配。Q：小程序适配 iphonex 机型底部安全区域A：padding-bottom: constant(safe-area-inset-bottom);Q：小程序: hideLoading 能把 toast 也隐藏掉A：https://developers.weixin.qq.com/community/develop/doc/00020212ec8200bc146731f2f51800https://developers.weixin.qq.com/community/develop/doc/000008d41284382afbf6bdf6051c00Q：css module 的局限性，无法准确预测类名// 例如这样的写法，使用了 css module 不会生效.parent {  color: red;}// 鼠标经过某个子节点想要修改父节点的样式.children {  &amp;:hover .parent {    color: yellow;  }}Q：MySQL 数据库使用 utf8 编码格式 无法保存 emoji 表情A：改成 utf8mb4是 MySQL 的一个历史遗留问题，utf8mb4 才是真正的 UTF-8在 MySQL 中，“utf8”编码只支持每个字符最多三个字节，中文是占 3 个字节，其他数字、英文、符号占一个字节而真正的 UTF-8 是每个字符最多四个字节，emoji 符号占 4 个字节，一些较复杂的文字、繁体字也是 4 个字节MySQL 一直没有修复这个 bug，他们在 2010 年发布了一个叫作“utf8mb4”的字符集，巧妙的绕过了这个问题Q：IOS 无法通过 volume 属性设置 video 音量A：https://developer.apple.com/library/archive/documentation/AudioVideo/Conceptual/Using_HTML5_Audio_Video/Device-SpecificConsiderations/Device-SpecificConsiderations.htmlQ：小程序环境判断https://developers.weixin.qq.com/community/develop/doc/000e466b2c84d057b178e339d5b000https://developers.weixin.qq.com/community/develop/article/doc/000e6606ab4ac0edb4791eb4951013Q：typescript 工程，编译产物每一个文件都产生多余辅助函数A：https://www.typescriptlang.org/tsconfig#importHelpersQ：rendering twice because of strict modeA：https://stackoverflow.com/questions/61254372/my-react-component-is-rendering-twice-because-of-strict-modeQ：useEffect hook, dom ref is null in unmount callbackA：https://github.com/facebook/react/issues/20875https://reactjs.org/blog/2020/08/10/react-v17-rc.html#effect-cleanup-timingQ：H5 页面在 iphone 手机底部出现留白A：meta viewport，加入 viewport-fit=cover&lt;meta  name=&quot;viewport&quot;  content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0, viewport-fit=cover&quot;/&gt;Q：解决 Git 默认不区分文件名大小写的问题A：https://www.jianshu.com/p/df0b0e8bcf9bgit config core.ignorecase false"}]},{"id":"07405a1e638d890ec4968814c210740b","dirname":"前端技术","filename":"","basename":"","path":"/home/runner/work/qxtang.github.io/qxtang.github.io","children":[{"id":"65251720ce93a86e0baf484ea8ff1fd2","filename":"AST抽象语法树.md","basename":"AST抽象语法树","path":"/home/runner/work/qxtang.github.io/qxtang.github.io/前端技术","content":"AST 抽象语法树参考https://segmentfault.com/a/1190000016231512https://juejin.cn/post/6844903725228621832解析器 Parser把 js 源码转化为抽象语法树（AST）常用解析器https://github.com/babel/babel/tree/master/packages/babel-parserhttps://github.com/acornjs/acorn解析步骤两步：词法分析、语法分析词法分析把字符串形式的代码转换为 令牌（tokens）流，可以把令牌看作是一个扁平的语法片段数组例如：// 源n * n;// 词法分析结果[  { type: { ... }, value: &quot;n&quot;, start: 0, end: 1, loc: { ... } },  { type: { ... }, value: &quot;*&quot;, start: 2, end: 3, loc: { ... } },  { type: { ... }, value: &quot;n&quot;, start: 4, end: 5, loc: { ... } },]每一个 type 有一组属性来描述该令牌：const token = {  type: {    label: &#x27;name&#x27;,    keyword: undefined,    beforeExpr: false,    startsExpr: true,    rightAssociative: false,    isLoop: false,    isAssign: false,    prefix: false,    postfix: false,    binop: null,    updateContext: null,  },};语法分析根据词法分析的结果，也就是令牌 tokens，将其转换成 AST// 源function square(n) {  return n * n;}// ATSconst ast = {  type: &#x27;FunctionDeclaration&#x27;,  id: {    type: &#x27;Identifier&#x27;,    name: &#x27;square&#x27;,  },  params: [    {      type: &#x27;Identifier&#x27;,      name: &#x27;n&#x27;,    },  ],  body: {    type: &#x27;BlockStatement&#x27;,    body: [      {        type: &#x27;ReturnStatement&#x27;,        argument: {          type: &#x27;BinaryExpression&#x27;,          operator: &#x27;*&#x27;,          left: {            type: &#x27;Identifier&#x27;,            name: &#x27;n&#x27;,          },          right: {            type: &#x27;Identifier&#x27;,            name: &#x27;n&#x27;,          },        },      },    ],  },};应用IDE 使用，如代码风格检测(eslint 等)、代码的格式化，代码高亮，代码错误等等代码的混淆压缩转换代码工具，如 babelvue 模板编译过程prettierbabel-plugin-import将 antd 组件 import 语句转换成按需引入写法的 babel 插件"},{"id":"4f33420293c9962d59b3bea05fc9da86","filename":"Babel.md","basename":"Babel","path":"/home/runner/work/qxtang.github.io/qxtang.github.io/前端技术","content":"Babel概念一个 JavaScript 翻译器将 ECMAScript 2015+ 语法编写的代码转换为向后兼容的 JavaScript 语法，以便能够运行在各种环境中通过 Polyfill 方式在目标环境中添加缺失的特性 （通过引入第三方 polyfill 模块，例如 core-js）基本工作原理第 1 步 解析（Parse）通过解析器 babylon 将代码解析成抽象语法树，包括词法分析和语法分析，词法分析主要把字符流源代码（Char Stream）转换成令牌流（ Token Stream），语法分析主要是将令牌流转换成抽象语法树第 2 步 转换（TransForm）通过 babel-traverse plugin 对抽象语法树进行深度优先遍历，遇到需要转换的，就直接在 AST 对象上对节点进行添加、更新及移除操作，比如遇到箭头函数，就转换成普通函数，最后得到新的 AST 树第 3 步 生成（Generate）通过 babel-generator 将 AST 树生成 es5 代码，同时也能创建 Source Map 映射配置主要分为 presets 和 plugins.babelrc._ 和 babel.config._ 区别.babelrc._ 仅适用于项目的某个部分babel.config._ 会影响整个项目中的代码，包含 node_modules 中的代码推荐使用 babel.config._，Babel 自身使用的就是这种格式presets逆序处理，从后往前，这主要是为了确保向后兼容，由于大多数用户将 &quot;es2015&quot; 放在 &quot;stage-0&quot; 之前，可以是数组、对象、字符串{  &quot;presets&quot;: [    &quot;presetA&quot;, // bare string    [&quot;presetA&quot;], // wrapped in array    [&quot;presetA&quot;, {}] // 2nd argument is an empty options object  ]}useBuiltIns{  &quot;presets&quot;: [    [      &quot;@babel/preset-env&quot;,      {        &quot;useBuiltIns&quot;: &quot;usage&quot;,        &quot;debug&quot;: true,        &quot;corejs&quot;: 3 // 建议使用 3，core-js@2 分支中已经不会再添加新特性，新特性都会添加到 core-js@3      }    ]  ]}babel 在转译的时候，会将源代码分成 syntax（语法） 和 api 两部分来处理，语法处理通过配置 presets，babel 使用 polyfill 来处理 api，@babel/preset-env 中有一个配置选项 useBuiltIns，用来告诉 babel 如何处理 api，由于这个选项默认值为 false，即不处理 api，所以代码转译后默认没有处理 api，可以通过手动引入 polyfill，但是 polyfill 没有动态引入会增加包的体积设置 useBuiltIns 的值为 &quot;entry&quot;，同时在源代码的最上方手动引入 @babel/polyfill 这个库（该库一共分为两部分，第一部分是 core-js，第二部分是 regenerator-runtime。其中 core-js 为其他团队开源的另一个独立项目），此时 babel 根据项目 browserslist，引入浏览器不兼容的 polyfill。需要在入口文件手动添加 import '@babel/polyfill'，会自动根据 browserslist 替换成浏览器不兼容的所有 polyfill将 useBuiltIns 改为 &quot;usage&quot;，babel 就可以按需加载 polyfill，并且不需要手动引入 @babel/polyfill存在的问题polyfill 会直接在全局对象上定义方法，比如 Array.include，众所周知前端开发不鼓励污染全局变量，babel 会向翻译后的每一个文件原地定义许多帮助函数，用于转义语法，比如 __spreadArray、__generator,plugins本质是一个 JS 程序, 指示 Babel 如何对代码进行转换排列顺序很重要plugins 在 presets 之前运行plugins 顺序从前往后排列，与 presets 相反核心与其周边@babel/corebabel 使用了微内核的架构风格，也就是说它们的核心非常小，大部分功能都是通过插件扩展实现的，@babel/core 就是这个内核，包含核心功能作用：加载和处理配置(config)加载插件调用 Parser 进行语法解析，生成 AST调用 Traverser 遍历 AST，并使用访问者模式应用'插件'对 AST 进行转换生成代码，包括 SourceMap 转换和源代码生成@babel/cli命令行工具@babel/plugin-transform-runtime、@babel/runtime这个插件就是为了解决 useBuiltIns polyfill 污染全局的问题和每一个文件都有辅助函数问题，将 babel 转译时添加到文件中的内联辅助函数统一隔离到 babel-runtime 提供的 helper 模块中编译时，直接从 helper 模块加载，不在每个文件中重复的定义辅助函数，从而减少包的尺寸其中 @babel/plugin-transform-runtime 的作用是转译代码，转译后的代码中可能会引入 @babel/runtime-corejs3 里面的模块。前者运行在编译时，后者运行在运行时。类似 polyfill，后者需要被打包到最终产物里在浏览器中运行@babel/plugin-transform-runtime 通常仅在开发时使用，但是运行时最终代码需要依赖 @babel/runtime，所以 @babel/runtime 必须要作为生产依赖被安装typescript 的 importHelpers 配置和 tslib 也是类似的原理安装：$ yarn add @babel/plugin-transform-runtime -D$ yarn add @babel/runtime-corejs3修改配置如下：{  &quot;presets&quot;: [    [      &quot;@babel/preset-env&quot;      // 移除，否则和下面重复了      // {      //   &quot;useBuiltIns&quot;: &quot;usage&quot;,      //   &quot;debug&quot;: true      // }    ]  ],  &quot;plugins&quot;: [    [      &quot;@babel/plugin-transform-runtime&quot;,      {        &quot;corejs&quot;: 3 // 指定 runtime-corejs 的版本，目前有 2 3 两个版本      }    ]  ]}引入了这个插件后：api 从之前的直接修改原型改为了从一个统一的模块中引入，避免了对全局变量及其原型的污染helpers 从之前的原地定义改为了从一个统一的模块中引入，使得打包的结果中每个 helper 只会存在一个@babel/parser将源代码解析为 AST已经内置支持很多语法. 例如 JSX、Typescript、Flow、以及最新的 ECMAScript 规范@babel/traverse实现了访问者模式，对 AST 进行遍历，转换插件会通过它获取感兴趣的 AST 节点，对节点继续操作@babel/generator将 AST 转换为源代码，支持 SourceMap@babel/preset-env语法转换插件的集合可以根据目标浏览器运行环境配置（browserslist、targets），将 ES2015+ 的语法转换为 es5 语法，不需要一个个语法插件去安装（比如@babel/plugin-transform-arrow-functions）core.js新 api 集合@babel/polyfill@babel/polyfill 融合了 core-js 和 regenerator-runtime，因此 babel-polyfill 本质就是 corejs引入 @bable/polyfill 就相当于在代码中引入下面两个库import &#x27;core-js/stable&#x27;;import &#x27;regenerator-runtime/runtime&#x27;;官方提示已经 deprecated，推荐使用 core-js@3 + @babel/preset-env 即可🚨 As of Babel 7.4.0, this package has been deprecated in favor of directly including core-js/stable (to polyfill ECMAScript features) and regenerator-runtime/runtime (needed to use transpiled generator functions)regenerator-runtime生成器函数、async、await 函数经 babel 编译后，regenerator-runtime 模块用于提供功能实现，运行时依赖，需要打包进产物"},{"id":"da1cb124c51c98d0dd90ce9db78aa2dc","filename":"React源码学习.md","basename":"React源码学习","path":"/home/runner/work/qxtang.github.io/qxtang.github.io/前端技术","content":"React 源码学习参考https://pomb.us/build-your-own-react/https://github.com/Hazlank/blog/issues/13"},{"id":"d3c9e089dd008e2d59c32305f690bbb7","filename":"微前端.md","basename":"微前端","path":"/home/runner/work/qxtang.github.io/qxtang.github.io/前端技术","content":"微前端微前端不一定是一种新技术，也不必太复杂。只要我们保证代码隔离和团队自治，无论我们采用何种技术栈，我们都可以达到相同的效果由来工程越来越大，打包越来越慢团队人员多，产品功能复杂，代码冲突频繁、影响面大在后端服务开发中，为了解决庞大的一整块后端服务带来的变更与扩展方面的限制，出现了微服务架构把应用程序设计成一系列松耦合的细粒度服务允许使用不同的编程语言来编写不同服务前端也出现这样的问题，即，一种由独立交付的多个应用组成整体的架构风格。将前端应用分解成一些更小更简单的能够独立开发、测试、部署的小块，而在用户看来仍然是内聚的单个产品比起一整块的前端代码库，微前端架构下的代码库倾向于更小/简单、更容易开发传统开发的缺点历史项目，祖传代码交付压力，当时求快就近就熟，当时求稳导致技术栈落后，甚至强行混用多种技术栈，耦合混乱，不敢动，牵一发动全身每个微前端都应具备有自己的持续交付流水线（包括构建、测试并部署到生产环境），且要能独立部署，不必过多考虑其它代码库的状态意义技术栈无关，主框架不限制接入应用的技术栈，微应用具备完全自主权独立开发、独立部署，微应用仓库独立，前后端可独立开发，部署完成后主框架自动完成同步更新增量升级，在面对各种复杂场景时，我们通常很难对一个已经存在的系统做全量的技术栈升级或重构，而微前端是一种非常好的实施渐进式重构的手段和策略独立运行时，每个微应用之间状态隔离，运行时状态不共享微前端架构旨在解决单体应用在一个相对长的时间跨度下，由于参与的人员、团队的增多、变迁，从一个普通应用演变成一个巨石应用后，随之而来的应用不可维护的问题。这类问题在企业级 Web 应用中尤其常见。技术方案package 集成将每个微前端发布为一个 npm 包，并让容器应用程序将所有微前端应用作为依赖项这意味着只要有一个包更新，即使是小版本，宿主也要重新构建一次。不建议使用这种方案iframe优点：隔离得很彻底缺点：速度慢，浏览器处理 iframe 要启动更多的进程；页面刷新难以保存状态，路由、历史记录等等使用 umd 包通过 script 标签引入放在 cdn 上的资源，可以始终保持最新，子应用更新不需要通知宿主具有完全的灵活性，宿主可以控制什么时候载入每个应用，以及渲染应用时额外传参数微前端架构存在的一些普遍问题下载量独立构建的 JavaScript 文件可能导致重复的公共依赖，从而增加用户的下载量例如，如果每个微应用都包括自己的 React 副本，那么用户就得多次下载 React环境差异在本地开发时无法把所有微应用和对应的后端都启动起来，不得不在本地进行环境的简化。如果开发环境和生产环境不严谨一致，容易造成问题。如果开发者想要完全模拟生产环境，会比较耗时治理复杂性要管理更多的东西：更多的代码库、更多的工具、更多的构建管道、更多的服务器、更多的域名等"},{"id":"2227cf216416fc887bc6ecb4f95596a7","filename":"性能优化.md","basename":"性能优化","path":"/home/runner/work/qxtang.github.io/qxtang.github.io/前端技术","content":"性能优化代码层面缓存 dom 查找结果用 innerHTML 代替 DOM 操作，减少 DOM 操作次数不频繁修改 DOM如果要修改 DOM 的多个样式可以用 cssText 一次性将要改的样式写入，或将样式写到 class 里，再修改 DOM 的 class 名称// badconst el = document.querySelector(&#x27;.myDiv&#x27;);el.style.borderLeft = &#x27;1px&#x27;;el.style.borderRight = &#x27;2px&#x27;;el.style.padding = &#x27;5px&#x27;;// goodconst el = document.querySelector(&#x27;.myDiv&#x27;);el.style.cssText += &#x27;border-left: 1px; border-right: 2px; padding: 5px;&#x27;;// cssText会覆盖已存在的样式，所以使用 +=列表绑定事件，使用事件委托如无必要，不要重写原生方法，因为原生方法底层是用 C/C++实现的，速度更快CSS 能做的事情，尽量不用 JS 来做避免 css 表达式比如 calcwebpack、babel 层面webpack 按需加载，React.lazy + import()，Webpack 4 之后，只需要用异步语句 require.ensure(&quot;./xx.js&quot;) 或 import(&quot;./xx.js&quot;) 方式引入模块，就可以实现模块的动态加载，这种能力本质也是基于 Chunk 实现的，遇到异步引入语句时会为该模块单独生成一个 chunkwebpack 配置 external，将通用库抽离，不打包进 bundle，比如 jquery、lodash，使用 CDN，并开启强缓存配置 babel 动态 polyfill，只针对不支持的浏览器引入 polyfill配置 file-loader，使小图使用 base64借助 webpack-bundle-analyzer 工具分析打包出的文件包含哪些，大小占比如何，模块包含关系webpack 的 tree-shaking 删除多余代码antd 按需加载，babel-plugin-importwebpack 拆包优化其他不常修改的资源（jquery），开启强缓存优化，配置响应头 Cache-Control 与 Expires减少 http 请求次数：雪碧图、小图片使用字体图标代替css 放顶部、js 放底部，非关键性的脚本（比如百度统计），script 标签加上 defer 或者 async单页应用首屏加载放个 loading，优化用户感知，利用一些过渡效果、骨架屏使用 link 标签的 rel 属性，设置 prefetch、preload（preload 将会把资源得下载顺序权重提高，使得关键数据提前下载好，优化页面打开速度）注意项目中是否使用了字体，字体加载也会让首屏加载变得很慢压缩 js、css 代码减少 cookie 的体积使用公共 CDN，好处：如果其他网站刚好也用过同一个资源，会得到缓存服务端开启 gzip（gzip 只对文本文件有效，比如 js、css，流文件无效，比如图片）路由懒加载图片懒加载将静态资源放在其他域名的原因（CDN）浏览器对于相同域名有并发请求数限制请求时不会发送 cookie，节省了流量cookie 会发送给二级域名，所以这些静态资源不放在二级域名，放在单独一级域名script 标签的 defer 和 async没有 defer 或 async 属性，浏览器会立即加载并执行相应的脚本async：立即下载，下载完立即执行，不确定顺序执行。对于完全独立的脚本来才去使用 async，比如谷歌统计百度统计。一定会在页面的 load 事件前执行，但不确定在 DOMContentLoaded 事件触发前后执行。defer：立即下载，将延迟到整个页面都解析完毕后再运行js 为什么放最下面？当文档加载过程中遇到 js 文件，html 文档会挂起渲染（加载解析渲染同步）的线程，不仅要等待文档中 js 文件加载完毕，还要等待解析执行完毕，才可以恢复 html 文档的渲染线程，因为 JS 有可能会修改 DOM，比如 document.write，这意味着，在 JS 执行完成前，后续所有资源的下载可能是没有必要的，这是 js 阻塞后续资源下载的原因。所以平时的代码中，js 是放在 html 文档末尾的css 为什么放最上面？CSS 不会阻塞 DOM 的解析，但会阻塞 DOM 渲染css 是由单独的下载线程异步下载的但会阻塞 render 树渲染（渲染时需等 css 加载完毕，因为 render 树需要 css 信息）gzip只对文本文件有效，比如 js、css，流文件无效，比如图片需要客户端和服务端的同时支持客户端支持：请求头中有个 Accept-Encoding 来标识对压缩的支持，content-encoding: gzip服务端支持：能够返回经过 gzip 压缩的文件重绘（repaint）与回流（reflow）重绘：当元素样式的改变不影响布局时，触发重绘，此时由于只需要 UI 层面的重新像素绘制，因此 损耗较少。回流、重排：当元素的尺寸、结构或触发某些属性时，触发回流。此时，浏览器需要重新经过计算，计算后还需要重新页面布局，因此是较耗性能的操作。触发回流的操作：页面初次渲染浏览器窗口大小改变元素尺寸、位置、内容发生改变元素字体大小变化添加或者删除可见的 dom 元素激活 CSS 伪类（例如：:hover）查询某些属性或调用某些方法回流必定触发重绘，重绘不一定触发回流。重绘的开销较小，回流的代价较高。如何避免触发回流和重绘CSS：避免使用 table 布局。尽可能在 DOM 树的最末端改变 class。避免设置多层内联样式。将动画效果应用到 position 属性为 absolute 或 fixed 的元素上避免使用 CSS 表达式（例如：calc()）CSS3 硬件加速（GPU 加速）JavaScript：避免频繁操作样式，最好一次性重写 style 属性，或者将样式列表定义为 class 并一次性更改 class 属性避免频繁操作 DOM，创建一个 documentFragment，在它上面应用所有 DOM 操作，最后再把它添加到文档中也可以先为元素设置 display: none，操作结束后再把它显示出来。因为在 display 属性为 none 的元素上进行的 DOM 操作不会引发回流和重绘避免频繁读取会引发回流/重绘的属性或方法（offsetTop、offsetLeft、offsetWidth、offsetHeight、getBoundingClientRect 等），如果确实需要多次使用，就用一个变量缓存起来对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流requestAnimationFrame使用一个回调函数作为参数。这个回调函数会在浏览器重绘之前调用浏览器用于定时循环操作的一个接口，类似于 setTimeout，主要用途是按帧对网页进行重绘设置这个 API 的目的是为了让各种网页动画效果（DOM 动画、Canvas 动画、SVG 动画、WebGL 动画）能够有一个统一的刷新机制，从而节省系统资源，提高系统性能，改善视觉效果代码中使用这个 API，就是告诉浏览器希望执行一个动画，让浏览器在下一个动画帧安排一次网页重绘优势在于可以充分利用显示器的刷新机制，比较节省系统资源显示器有固定的刷新频率（60Hz 或 75Hz），也就是说，每秒最多只能重绘 60 次或 75 次，requestAnimationFrame 的基本思想就是与这个刷新频率保持同步cancelAnimationFrame 用于取消重绘，它的参数是 requestAnimationFrame 返回的一个代表任务 ID 的整数值为了提高性能和电池寿命，因此在大多数浏览器里，当 requestAnimationFrame() 运行在后台标签页或者隐藏的 &lt;iframe&gt; 里时，requestAnimationFrame() 会被暂停调用以提升性能和电池寿命当浏览器渲染线程被过度占用时这个 API 调用间隔会非常不稳定，它并不是银弹使用：function test(timestamp) {  console.log(timestamp);  requestAnimationFrame(test);}requestAnimationFrame(test);如何判断一个页面卡顿的原因内存泄漏，由于疏忽或者程序的某些错误造成未能释放已经不再使用的内存的情况（比如不再使用的变量额外创建）Chrome devTools Performance 查看内存情况打开 Chrome 的无痕模式，这样做的目的是为了屏蔽掉 Chrome 插件对我们之后测试内存占用情况的影响"}]},{"id":"index","filename":"index.md","basename":"index","path":"/home/runner/work/qxtang.github.io/qxtang.github.io","content":"✒ 工作与日常学习笔记via：doc-builder"}]