[{"id":"cfc6762313c8fadde407c043154409f7","dirname":"最佳实践","filename":"","basename":"","path":"/home/runner/work/qxtang.github.io/qxtang.github.io","children":[{"id":"90c722fcc7f93ea31011ef4abc7f384d","isRootIndexFile":false,"isIndexFile":false,"filename":"Javascript.md","basename":"Javascript","path":"/home/runner/work/qxtang.github.io/qxtang.github.io/最佳实践","content":"Javascript先声明后调用优先 const常量大写少写魔法值，常量需要命名不污染全局不要忽略抛异常、不要忘了在 Promise\\async await 抛异常缓存耗时的计算，比如 dom 查找、设备信息查询等尽可能使用原生方法，因为原生方法是用低级语言写的（C/C++），并且被编译成机器码，效率更高，比如 Array 的 filter少用 for-in，慢，for-in 要搜索原型属性基于函数的迭代 forEach 比一般的循环要慢，如果对运行速度要求很严格，不要使用使用枚举或策略模式减少 elseif，使用 Map、Object 优化 switch-case?? 空值合并操作符、?. 链合并运算符少写 console（或提交代码时删除 console），项目跑起来一堆的日志让队友很头疼多元判断时，可将条件拼接成字符串存到 Object 里/** * 按钮点击事件 * @param {number} status 活动状态：1未开始 2进行中 3结束 * @param {string} identity 身份标识：guest游客 admin管理员 */const onButtonClick = (status, identity) =&gt; {  if (identity == &#x27;guest&#x27;) {    if (status == 1) {      //do sth    } else if (status == 2) {      //do sth    } else if (status == 3) {      //do sth    } else {      //do sth    }  } else if (identity == &#x27;admin&#x27;) {    if (status == 1) {      //do sth    } else if (status == 2) {      //do sth    } else if (status == 3) {      //do sth    } else {      //do sth    }  }};// 可优化为const actions = new Map([  [&#x27;guest_1&#x27;, () =&gt; {} /*do sth*/],  [&#x27;guest_2&#x27;, () =&gt; {} /*do sth*/],  [&#x27;guest_3&#x27;, () =&gt; {} /*do sth*/],  [&#x27;admin_1&#x27;, () =&gt; {} /*do sth*/],  [&#x27;admin_2&#x27;, () =&gt; {} /*do sth*/],  [&#x27;admin_3&#x27;, () =&gt; {} /*do sth*/],  [&#x27;default&#x27;, () =&gt; {} /*do sth*/],]);/** * 按钮点击事件 * @param {string} identity 身份标识：guest游客 admin管理员 * @param {number} status 活动状态：1未开始 2进行中 3 结束 */const onButtonClick = (identity, status) =&gt; {  let action = actions.get(`${identity}_${status}`) || actions.get(&#x27;default&#x27;);  action.call(this);};可适当使用对象区分作用域使用 Array.includes 来优化多个条件的判断使用 Array.every 和 Array.some 来处理全部/部分满足条件减少嵌套，提前使用 return用有意义且常用的单词命名变量// 错误：const yyyymmdstr = moment().format(&#x27;YYYY/MM/DD&#x27;);// 正确:const currentDate = moment().format(&#x27;YYYY/MM/DD&#x27;);保持统一命名可能同一个项目对于获取用户信息，会有三个不一样的命名，应该保持统一。// 错误：getUserInfo();getClientData();getCustomerRecord();// 正确：getUser();避免无意义前缀如果创建了一个对象 car，就没有必要把它的颜色命名为 carColor。// 错误：const car = {  carMake: &#x27;Honda&#x27;,  carModel: &#x27;Accord&#x27;,  carColor: &#x27;Blue&#x27;,};function paintCar(car) {  car.carColor = &#x27;Red&#x27;;}// 正确：const car = {  make: &#x27;Honda&#x27;,  model: &#x27;Accord&#x27;,  color: &#x27;Blue&#x27;,};function paintCar(car) {  car.color = &#x27;Red&#x27;;}使用函数参数默认值// 错误：function doSomeThing(name) {  const username = name || &#x27;tony&#x27;;  // ...}// 正确：function doSomeThing(name = &#x27;tony&#x27;) {  // ...}参数越少越好如果参数超过两个，使用解构语法，不用考虑参数顺序。// 错误：function createMenu(title, body, buttonText, cancellable) {  // ...}// 正确：function createMenu({ title, body, buttonText, cancellable }) {  // ...}createMenu({  title: &#x27;Foo&#x27;,  body: &#x27;Bar&#x27;,  buttonText: &#x27;Baz&#x27;,  cancellable: true,});抽象重复代码很多时候虽然是同一个功能，但由于一两个不同点，让你不得不写两个几乎相同的函数，要想优化重复代码需要有较强的抽象能力。不传 flag 参数不要通过 flag 的 true 或 false，来判断执行逻辑。删除弃用代码可以在代码库历史版本中找到它。使用 class链式调用这种模式让的代码简洁优雅，在类的方法最后返回 this 就可以了。class Car {  constructor(make, model, color) {    this.make = make;    this.model = model;    this.color = color;  }  setMake(make) {    this.make = make;    return this;  }  setModel(model) {    this.model = model;    return this;  }  setColor(color) {    this.color = color;    return this;  }  save() {    console.log(this.make, this.model, this.color);    return this;  }}const car = new Car(&#x27;Ford&#x27;, &#x27;F-150&#x27;, &#x27;red&#x27;).setColor(&#x27;pink&#x27;).save();单一功能原则如果一个类干的事情太多太杂，会导致后期很难维护。我们应该厘清职责，各司其职减少相互之间依赖。封闭开放原则“当需要改变一个程序的功能或者给这个程序增加新功能的时候，可以使用增加代码的方式，但是不允许改动程序的源代码”比如我想修改一个公共组件的样式来适配自己的页面，但又需要保证其他使用这个组件的页面不受影响，可以通过增加一个主题参数，根据该参数加载一份新的样式文件"},{"id":"38f7be06c8c5c4d4d37ea6cadecfc7fe","isRootIndexFile":false,"isIndexFile":false,"filename":"React.md","basename":"React","path":"/home/runner/work/qxtang.github.io/qxtang.github.io/最佳实践","content":"React使用 hooks使用 styled-components https://medium.com/building-crowdriff/styled-components-to-use-or-not-to-use-a6bb4a7ffc21考虑使用 unstated-next 代替 redux组件属性超过 3 个则换行没有子元素的组件写成自闭合多用函数组件，更小的打包体积，更高的执行效率多用 PureComponent，PureComponent 会先对 state 和 props 进行浅比较，不同的时候才会 render遵循单一职责原则，使用 HOC / 装饰器 / Render Props 增加职责react 组件文件用 jsx，用大驼峰命名 jsx 文件表达式中的 jsx 使用圆括号包裹每个文件只写一个组件，但是多个无状态组件可以放在单个文件中，文件名要与默认导出的类名一致组合优于继承性能原因尽量不写内联函数，比如点击事件React 应用中的权限管理：https://isamatov.com/react-permissions-and-roles/多使用解构，例如声明函数组件的 props 和 默认值export default ({ name = &#x27;小明&#x27;, sex = &#x27;男&#x27; }) =&gt; (  &lt;&gt;    我叫 {name}，性别 {sex}  &lt;/&gt;);组件属性命名保持统一，使兼容性良好，避免无意义前缀// 错误&lt;MyInput inputValue onInputChange wrapStyle wrapClassName /&gt;// 正确&lt;MyInput value onChange style className /&gt;避免在 render 里面动态创建对象 / 方法，否则会导致子组件每次都 render// 错误：render() {  const obj = {num: 1}  return (    &lt;Child obj={obj} onClick={()=&gt;{...}} /&gt;  );}避免在 JSX 中写复杂的三元表达式，应通过封装函数或组件实现// 错误：render() {  const a = 8;  return (    &lt;div&gt;      {        a &gt; 0 ? a &lt; 9 ? ... : ... : ...      }    &lt;/div&gt;  );}// 正确：f() {  // ...}render() {  const a = 8;  return (    &lt;div&gt;      {        this.f()      }    &lt;/div&gt;  );}使用运算符&amp;&amp;简化三元运算在 JavaScript 中，true &amp;&amp; expression 总是会返回 expression, 而 false &amp;&amp; expression 总是会返回 false，因此，如果条件是 true，&amp;&amp; 右侧的元素就会被渲染，如果是 false，React 会忽略并跳过它。例如：{  loading ? &lt;Loading /&gt; : null;}可简化为{  loading &amp;&amp; &lt;Loading /&gt;;}尽量避免使用展开运算符来展开 props变得难以理解和维护，容易出 bug遇到事件处理，可以使用一个返回新函数的方法例如：import React from &#x27;react&#x27;;export default function SampleComponent({ onValueChange }) {  const handleChange = (key) =&gt; {    return (e) =&gt; onValueChange(key, e.target.value);  };  return (    &lt;form&gt;      &lt;input onChange={handleChange(&#x27;name&#x27;)} /&gt;      &lt;input onChange={handleChange(&#x27;email&#x27;)} /&gt;      &lt;input onChange={handleChange(&#x27;phone&#x27;)} /&gt;    &lt;/form&gt;  );}使用 Hook components比如要封装一个弹窗组件：// 组件import React, { useCallback, useState } from &#x27;react&#x27;;import ConfirmationDialog from &#x27;components/global/ConfirmationDialog&#x27;;export default function useConfirmationDialog({ headerText, bodyText, confirmationButtonText, onConfirmClick }) {  const [isOpen, setIsOpen] = useState(false);  const onOpen = () =&gt; {    setIsOpen(true);  };  const Dialog = useCallback(    () =&gt; (      &lt;ConfirmationDialog        headerText={headerText}        bodyText={bodyText}        isOpen={isOpen}        onConfirmClick={onConfirmClick}        onCancelClick={() =&gt; setIsOpen(false)}        confirmationButtonText={confirmationButtonText}      /&gt;    ),    [isOpen]  );  return {    Dialog,    onOpen,  };}// 使用import React from &#x27;react&#x27;;import { useConfirmationDialog } from &#x27;./useConfirmationDialog&#x27;;function Client() {  const { Dialog, onOpen } = useConfirmationDialog({    headerText: &#x27;Delete this record?&#x27;,    bodyText: &#x27;Are you sure you want delete this record? This cannot be undone.&#x27;,    confirmationButtonText: &#x27;Delete&#x27;,    onConfirmClick: handleDeleteConfirm,  });  function handleDeleteConfirm() {}  const handleDeleteClick = () =&gt; {    onOpen();  };  return (    &lt;div&gt;      &lt;Dialog /&gt;      &lt;button onClick={handleDeleteClick} /&gt;    &lt;/div&gt;  );}export default Client;这种模式可以少写很多与组件相关的 state，比如弹窗的 visible、title 之类的将业务逻辑封装进 hooks，业务逻辑与 UI 分离（关注点分离）// 例如：import React from &#x27;react&#x27;;import ItemDisplay from &#x27;./ItemDisplay&#x27;;export default function SampleComponent() {  const { data, handleDelete, handleEdit, handleAdd } = useCustomHook();  return (    &lt;div&gt;      &lt;div&gt;        {data.map((item) =&gt; (          &lt;ItemDisplay item={item} /&gt;        ))}      &lt;/div&gt;      &lt;div&gt;        &lt;button onClick={handleDelete} /&gt;        &lt;button onClick={handleAdd} /&gt;        &lt;button onClick={handleEdit} /&gt;      &lt;/div&gt;    &lt;/div&gt;  );}不要把所有状态存放在 redux，redux 只用于存放用户登录信息、主题等信息不要任何变量都使用状态，可以使用 useRef 或成员属性（类组件）来储存与更新渲染无关的变量，可以通过已保存的状态来推断出的状态可使用 useMemo 来计算，而不要创建新状态尽量不要在组件中声明新的组件// 错误，不建议function A() {  const B = () =&gt; {    return &lt;p&gt;hello&lt;/p&gt;;  };  return (    &lt;div&gt;      &lt;B /&gt;    &lt;/div&gt;  );}原因：高耦合影响性能，A 每一次渲染都会重新声明一遍 B避免为了优化少量性能过度设计代码，牺牲代码的可维护性、易读性，浪费时间"},{"id":"d02c013ecd23b0f2469dc30db74d4108","isRootIndexFile":false,"isIndexFile":false,"filename":"git 实践.md","basename":"git 实践","path":"/home/runner/work/qxtang.github.io/qxtang.github.io/最佳实践","content":"git 实践git rebase可以直接理解为改变基底。feature 分支是基于 master 分支的 B 拉出来的分支，feature 的基底是 B。而 master 在 B 之后有新的提交，就相当于此时要用 master 上新的提交来作为 feature 分支的新基底。实际操作为把 B 之后 feature 的提交存下来，然后删掉原来这些提交，再找到 master 的最新提交位置，把存下来的提交再接上去（新节点新 commit id）如此 feature 分支的基底就相当于变成了 M 而不是原来的 B 了。注意，如果 master 上在 B 以后没有新提交，那么就还是用原来的 B 作为基，rebase 操作相当于无效，此时和 git merge 就基本没区别了，差异只在于 git merge 会多一条记录 Merge 操作的提交记录大部分公司其实会禁用 rebase，不管是拉代码还是 push 代码统一都使用 merge，虽然会多出无意义的一条提交记录“Merge … to …”，但至少能清楚地知道主线上谁合了的代码以及他们合代码的时间先后顺序GitFlow简单记录工作中使用 gitflow 模型管理代码版本、保证代码安全的方法。参考：A successful Git branching modelGit 工作流程Git 分支管理策略git flow 的使用GitFlow 原理浅析gitflow 现在被认为过于复杂，可能不适用于现代软件开发：如何看待 Git flow 发明人称其不适用于持续交付？Issues with git-flow在阿里，我们如何管理代码分支？分支类型master只有一条主分支只读，只能从分支 release 或 hotfix 合并进来所有发生在 master 分支的修改应该打 tag 做记录，方便追溯develop只有一条主开发分支，基于 master 分支克隆包含所有要发布到下一个 release 的代码只读，只能从 feature 或 release 合并进来feature 功能分支完成开发后，合并到 develop，合并到 develop 前，提交合并申请，与 develop 分支进行比较做代码审查，审查通过则允许合并从 develop 拉取 release 分支，提测release 或 hotfix 分支上线完毕，合并回 develop。feature功能开发分支，基于 develop 分支克隆，主要用于新需求新功能的开发有多条，按功能划分，如：/feature/20200712-新增用户、/feature/20200801-登陆注册可以几个人一起开发一条 feature，也可以一人负责一条 feature功能开发完毕后，提测前，合并到 develop 分支feature 类型的分支可同时存在多个，用于团队中多个功能同时开发，属于临时分支，功能完成后可选择删除release版本分支，用于测试与上线，基于 feature 分支合并到 develop 之后，从 develop 分支克隆有多条，按版本划分，如：/release/20200712-第一版v0.1、/release/20200713-第二版v0.2release 类型的分支主要用于测试和修改 bug，完成上线后合并回 develop 与 master 分支hotfix补丁分支，基于 master 分支克隆，主要用于对线上的版本进行 BUG 修复有多条，按版本划分，如：/hotfix/20200712-修复xss漏洞、/hotfix/20200713-修复新增用户失败bug修复完毕后合并回 develop 与 master 分支主要工作流程示例初始化项目，创建 master 分支，然后从 master 拉取 develop 分支根据需求划分功能，从 develop 拉取 feature 分支进行编码开发，如/feature/20200712-新增用户、/feature/20200801-登陆注册feature 分支完成后，合并到 develop 前，提交合并申请，与 develop 比较，进行代码审查，合并完成可以选择删除当前 feature需要发布时，从 develop 拉取 release 分支进行测试，例如/release/20200712-第一版，测试过程中在该条 release 分支上修改 BUG，测试通过后将该条 release 分支发布回归：任一 release 分支通过测试上线后，合并该 release 分支到 develop 与 master，master 分支打 tag，当前 release 不可修改，线上有问题须从 master 拉取 hotfix 分支进行修改通知所有进行中的 feature、release 把 master 合进来一次上线之后若发现 bug，从 master 拉取 hotfix 进行 bug 修改，如/hotfix/20200713-修复新增用户失败bughotfix 通过测试上线后，合并 hotfix 分支到 develop 与 master，master 分支打 tag版本回退：如果需进行版本回退，则选择上一版本号的 release 分支进行发布分支命名使用 YYYYMMDD-功能名称 格式，gui 工具或命令行打印时自动排序，找分支找比较方便参考https://ourai.ws/posts/working-with-git-in-team/https://www.cnblogs.com/irving/p/5146738.htmlhttps://mp.weixin.qq.com/s/0N3isbSZL4fM5HjZo1aafAhttps://ihower.tw/blog/archives/3843"},{"id":"5b64f73b8f42d8bb71575d11527c2b1a","isRootIndexFile":false,"isIndexFile":false,"filename":"其他.md","basename":"其他","path":"/home/runner/work/qxtang.github.io/qxtang.github.io/最佳实践","content":"通用业务代码分层习惯├─assets 静态资源├─service 业务逻辑封装├─components 组件  ├─business 业务组件  ├─common 通用组件├─constants 常量├─store 全局状态├─pages 页面├─types 通用类型├─utils 工具npm 脚本命名同一系列行为的脚本，命令行参数、环境变量有差异，用冒号区分，比如&quot;scripts&quot;: {  &quot;build:test&quot;: &quot;tsc &amp;&amp; vite build --mode test&quot;,  &quot;build:prod&quot;: &quot;tsc &amp;&amp; vite build --mode production&quot;,}前置操作的处理如登录、获取用户信息、权限检查等任务，放在根组件（App.tsx、App.vue）中执行，执行结束再渲染路由组件，保证业务接口能正确获取参数小程序小程序入口组件不会渲染任何内容，例如 Taro 框架，必须同步返回 props.children，所以对前置操作的处理，可以将首页设置为一个 loading 页，在 loading 页中显示加载中且进行前置操作后，再跳转到业务页面（为 loading 页设置如 redirectUrl 参数设置跳转页面）。不建议在本地构建部署代码应使用 devops 系统前端项目的一般部署流程获取代码：从代码仓库获取项目代码，并切换到待部署的分支或版本安装依赖：安装项目构建所需要的依赖包源码构建：使用构建工具对项目源代码进行构建，生成产物代码产物打包：将部署所需的代码（通常指的是构建后的产物代码，如果是部署 Node 服务则还需要其他目录与文件）打成压缩包推送代码：将待部署的文件或压缩包推送至目标服务器的特定目录下，如果是推送压缩包的情况，还需执行解压重启服务：在部署 Node 服务的情况下，在代码推送后需要进行服务重启本地部署的优势快速：不需要获取代码、安装依赖这几个步骤构建失败能更方便查找问题本地部署的劣势溯源难环境一致性：不同开发人员的本地依赖包版本可能存在差异，导致打包结果并不严格一致；本地环境和部署代码的目标服务器环境之间也可能存在差异；导致项目代码的稳定性无法得到保障例如对于一个 Node 项目而言，在一个 NodeJS 低版本环境下构建的产物，在 Node 高版本环境下就有可能启动异常其他动态 polyfill尽量不要污染全局 window 对象通过封装解决浏览器差异兼容性问题为项目配置代码引用路径别名 alias项目不要添加任何与开发环境强耦合的设置（比如某个地方必须借助 vscode 的某个插件才能运行）禁止安装私人依赖包使用 Webpack Bundle Analyzer 分析包大小组成函数遵循单一职责原则只导入类型，使用 import typeimport type { DependencyList, useEffect, useLayoutEffect } from &#x27;react&#x27;;想要在 chrome 移动设备模拟器上添加某个自定义设备型号，需要知道该设备的分辨率console.log(document.body.clientWidth, document.body.clientHeight);通过判断环境变量的方式，区分执行环境差异代码，借助 DefinePlugin 将环境变量静态嵌入客户端代码开发环境 node 和 npm 版本需要一致，因为不同版本 node、npm 行为不一样第三方库按需加载小程序环境判断https://developers.weixin.qq.com/community/develop/doc/000e466b2c84d057b178e339d5b000https://developers.weixin.qq.com/community/develop/article/doc/000e6606ab4ac0edb4791eb4951013"}]},{"id":"e3db49d633625ac1552e7dca23fb879e","isRootIndexFile":false,"isIndexFile":false,"filename":"AST抽象语法树.md","basename":"AST抽象语法树","path":"/home/runner/work/qxtang.github.io/qxtang.github.io","content":"AST 抽象语法树参考https://segmentfault.com/a/1190000016231512https://juejin.cn/post/6844903725228621832解析器 Parser把 js 源码转化为抽象语法树（AST）常用解析器https://github.com/babel/babel/tree/master/packages/babel-parserhttps://github.com/acornjs/acorn解析步骤两步：词法分析、语法分析词法分析把字符串形式的代码转换为 令牌（tokens）流，可以把令牌看作是一个扁平的语法片段数组例如：// 源n * n;// 词法分析结果[  { type: { ... }, value: &quot;n&quot;, start: 0, end: 1, loc: { ... } },  { type: { ... }, value: &quot;*&quot;, start: 2, end: 3, loc: { ... } },  { type: { ... }, value: &quot;n&quot;, start: 4, end: 5, loc: { ... } },]每一个 type 有一组属性来描述该令牌：const token = {  type: {    label: &#x27;name&#x27;,    keyword: undefined,    beforeExpr: false,    startsExpr: true,    rightAssociative: false,    isLoop: false,    isAssign: false,    prefix: false,    postfix: false,    binop: null,    updateContext: null,  },};语法分析根据词法分析的结果，也就是令牌 tokens，将其转换成 AST// 源function square(n) {  return n * n;}// ATSconst ast = {  type: &#x27;FunctionDeclaration&#x27;,  id: {    type: &#x27;Identifier&#x27;,    name: &#x27;square&#x27;,  },  params: [    {      type: &#x27;Identifier&#x27;,      name: &#x27;n&#x27;,    },  ],  body: {    type: &#x27;BlockStatement&#x27;,    body: [      {        type: &#x27;ReturnStatement&#x27;,        argument: {          type: &#x27;BinaryExpression&#x27;,          operator: &#x27;*&#x27;,          left: {            type: &#x27;Identifier&#x27;,            name: &#x27;n&#x27;,          },          right: {            type: &#x27;Identifier&#x27;,            name: &#x27;n&#x27;,          },        },      },    ],  },};应用IDE 使用，如代码风格检测(eslint 等)、代码的格式化，代码高亮，代码错误等等代码的混淆压缩转换代码工具，如 babelvue 模板编译过程prettierbabel-plugin-import将 antd 组件 import 语句转换成按需引入写法的 babel 插件"},{"id":"fcd42fc1afe1592eb752d49cc60a4157","isRootIndexFile":false,"isIndexFile":false,"filename":"Babel.md","basename":"Babel","path":"/home/runner/work/qxtang.github.io/qxtang.github.io","content":"Babel概念一个 JavaScript 翻译器将 ECMAScript 2015+ 语法编写的代码转换为向后兼容的 JavaScript 语法，以便能够运行在各种环境中通过 Polyfill 方式在目标环境中添加缺失的特性 （通过引入第三方 polyfill 模块，例如 core-js）基本工作原理第 1 步 解析（Parse）通过解析器 babylon 将代码解析成抽象语法树，包括词法分析和语法分析，词法分析主要把字符流源代码（Char Stream）转换成令牌流（ Token Stream），语法分析主要是将令牌流转换成抽象语法树第 2 步 转换（TransForm）通过 babel-traverse plugin 对抽象语法树进行深度优先遍历，遇到需要转换的，就直接在 AST 对象上对节点进行添加、更新及移除操作，比如遇到箭头函数，就转换成普通函数，最后得到新的 AST 树第 3 步 生成（Generate）通过 babel-generator 将 AST 树生成 es5 代码，同时也能创建 Source Map 映射配置主要分为 presets 和 plugins.babelrc._ 和 babel.config._ 区别.babelrc._ 仅适用于项目的某个部分babel.config._ 会影响整个项目中的代码，包含 node_modules 中的代码推荐使用 babel.config._，Babel 自身使用的就是这种格式presets逆序处理，从后往前，这主要是为了确保向后兼容，由于大多数用户将 &quot;es2015&quot; 放在 &quot;stage-0&quot; 之前，可以是数组、对象、字符串{  &quot;presets&quot;: [    &quot;presetA&quot;, // bare string    [&quot;presetA&quot;], // wrapped in array    [&quot;presetA&quot;, {}] // 2nd argument is an empty options object  ]}useBuiltIns{  &quot;presets&quot;: [    [      &quot;@babel/preset-env&quot;,      {        &quot;useBuiltIns&quot;: &quot;usage&quot;,        &quot;debug&quot;: true,        &quot;corejs&quot;: 3 // 建议使用 3，core-js@2 分支中已经不会再添加新特性，新特性都会添加到 core-js@3      }    ]  ]}babel 在转译的时候，会将源代码分成 syntax（语法） 和 api 两部分来处理，语法处理通过配置 presets，babel 使用 polyfill 来处理 api，@babel/preset-env 中有一个配置选项 useBuiltIns，用来告诉 babel 如何处理 api，由于这个选项默认值为 false，即不处理 api，所以代码转译后默认没有处理 api，可以通过手动引入 polyfill，但是 polyfill 没有动态引入会增加包的体积设置 useBuiltIns 的值为 &quot;entry&quot;，同时在源代码的最上方手动引入 @babel/polyfill 这个库（该库一共分为两部分，第一部分是 core-js，第二部分是 regenerator-runtime。其中 core-js 为其他团队开源的另一个独立项目），此时 babel 根据项目 browserslist，引入浏览器不兼容的 polyfill。需要在入口文件手动添加 import '@babel/polyfill'，会自动根据 browserslist 替换成浏览器不兼容的所有 polyfill将 useBuiltIns 改为 &quot;usage&quot;，babel 就可以按需加载 polyfill，并且不需要手动引入 @babel/polyfill存在的问题polyfill 会直接在全局对象上定义方法，比如 Array.include，众所周知前端开发不鼓励污染全局变量，babel 会向翻译后的每一个文件原地定义许多帮助函数，用于转义语法，比如 __spreadArray、__generator,plugins本质是一个 JS 程序, 指示 Babel 如何对代码进行转换排列顺序很重要plugins 在 presets 之前运行plugins 顺序从前往后排列，与 presets 相反核心与其周边@babel/corebabel 使用了微内核的架构风格，也就是说它们的核心非常小，大部分功能都是通过插件扩展实现的，@babel/core 就是这个内核，包含核心功能作用：加载和处理配置(config)加载插件调用 Parser 进行语法解析，生成 AST调用 Traverser 遍历 AST，并使用访问者模式应用'插件'对 AST 进行转换生成代码，包括 SourceMap 转换和源代码生成@babel/cli命令行工具@babel/plugin-transform-runtime、@babel/runtime这个插件就是为了解决 useBuiltIns polyfill 污染全局的问题和每一个文件都有辅助函数问题，将 babel 转译时添加到文件中的内联辅助函数统一隔离到 babel-runtime 提供的 helper 模块中编译时，直接从 helper 模块加载，不在每个文件中重复的定义辅助函数，从而减少包的尺寸其中 @babel/plugin-transform-runtime 的作用是转译代码，转译后的代码中可能会引入 @babel/runtime-corejs3 里面的模块。前者运行在编译时，后者运行在运行时。类似 polyfill，后者需要被打包到最终产物里在浏览器中运行@babel/plugin-transform-runtime 通常仅在开发时使用，但是运行时最终代码需要依赖 @babel/runtime，所以 @babel/runtime 必须要作为生产依赖被安装typescript 的 importHelpers 配置和 tslib 也是类似的原理安装：$ yarn add @babel/plugin-transform-runtime -D$ yarn add @babel/runtime-corejs3修改配置如下：{  &quot;presets&quot;: [    [      &quot;@babel/preset-env&quot;      // 移除，否则和下面重复了      // {      //   &quot;useBuiltIns&quot;: &quot;usage&quot;,      //   &quot;debug&quot;: true      // }    ]  ],  &quot;plugins&quot;: [    [      &quot;@babel/plugin-transform-runtime&quot;,      {        &quot;corejs&quot;: 3 // 指定 runtime-corejs 的版本，目前有 2 3 两个版本      }    ]  ]}引入了这个插件后：api 从之前的直接修改原型改为了从一个统一的模块中引入，避免了对全局变量及其原型的污染helpers 从之前的原地定义改为了从一个统一的模块中引入，使得打包的结果中每个 helper 只会存在一个@babel/parser将源代码解析为 AST已经内置支持很多语法. 例如 JSX、Typescript、Flow、以及最新的 ECMAScript 规范@babel/traverse实现了访问者模式，对 AST 进行遍历，转换插件会通过它获取感兴趣的 AST 节点，对节点继续操作@babel/generator将 AST 转换为源代码，支持 SourceMap@babel/preset-env语法转换插件的集合可以根据目标浏览器运行环境配置（browserslist、targets），将 ES2015+ 的语法转换为 es5 语法，不需要一个个语法插件去安装（比如@babel/plugin-transform-arrow-functions）core.js新 api 集合@babel/polyfill@babel/polyfill 融合了 core-js 和 regenerator-runtime，因此 babel-polyfill 本质就是 corejs引入 @bable/polyfill 就相当于在代码中引入下面两个库import &#x27;core-js/stable&#x27;;import &#x27;regenerator-runtime/runtime&#x27;;官方提示已经 deprecated，推荐使用 core-js@3 + @babel/preset-env 即可🚨 As of Babel 7.4.0, this package has been deprecated in favor of directly including core-js/stable (to polyfill ECMAScript features) and regenerator-runtime/runtime (needed to use transpiled generator functions)regenerator-runtime生成器函数、async、await 函数经 babel 编译后，regenerator-runtime 模块用于提供功能实现，运行时依赖，需要打包进产物"},{"id":"14168fa339500eb086fd9bc8c3f8933c","isRootIndexFile":false,"isIndexFile":false,"filename":"Nginx 笔记.md","basename":"Nginx 笔记","path":"/home/runner/work/qxtang.github.io/qxtang.github.io","content":"Nginx 笔记工作中经常用的，简单记录一下。实用跨域# 这里约定代理请求url path是以/apis/开头location ^~/apis/ {    # 这里重写了请求，将正则匹配中的第一个()中$1的path，拼接到真正的请求后面，并用break停止后续匹配    rewrite ^/apis/(.*)$ /$1 break;    ...    proxy_pass https://www.tianqiapi.com/;}处理前端单页应用的 history 路由模式location / {    try_files $uri $uri/ /index.html;}适配 PC 和移动环境location / {    # 移动、pc设备适配    if ($http_user_agent ~* &#x27;(Android|webOS|iPhone|iPod|BlackBerry)&#x27;) {        set $mobile_request &#x27;1&#x27;;    }    if ($mobile_request = &#x27;1&#x27;) {        rewrite ^.+ http://mysite-base-H5.com;    }}端口转发http {    ...    upstream dmp8001 {        server 127.0.0.1:8001;    }    server {        listen       80;        server_name  abc.com;        location / {            ...            proxy_pass http://dmp8001;        }    }    ...}善用正则# 动态校验企业微信 h5 应用可信域名location ~ WW_verify_(.*).txt {    return 200 $1;}虚拟主机server {    listen 12332;    server_name 127.0.0.1;    location / {        root D:/Desktop/test;        index index.html index.htm;    }}防媒体文件盗链location ~* \\.(gif|jpg|png|jpeg|mp4)$ {    expires 30d;    valid_referers *.hugao8.com www.hugao8.com m.hugao8.com *.baidu.com *.google.com;    if ($invalid_referer) {        rewrite ^/ http://ww4.sinaimg.cn/bmiddle/051bbed1gw1egjc4xl7srj20cm08aaa6.jpg;        # return 404;    }}简单实现负载均衡轮询（默认），请求过来后，Nginx 随机分配流量到任一服务器upstream backend {    server 127.0.0.1:3000;    server 127.0.0.1:3001;}weight=number 设置服务器的权重，默认为 1，权重大的会被优先分配upstream backend {    server 127.0.0.1:3000 weight=2;    server 127.0.0.1:3001 weight=1;}backup 标记为备份服务器。当主服务器不可用时，将传递与备份服务器的连接upstream backend {    server 127.0.0.1:3000 backup;    server 127.0.0.1:3001;}代理这个集群server {    listen      9000;    server_name localhost;    location / {        proxy_set_header Host $http_host;        proxy_set_header X-Real-IP $remote_addr;        proxy_set_header X-Scheme $scheme;        proxy_pass backend;    }}关于 location 的匹配location 的几种匹配方式普通匹配：location = URI { configuration } #精确匹配location ^~ URI { configuration } #非正则匹配location [空格] URI { configuration } #前缀匹配正则匹配：location ~ URI { configuration } #区分大小写location ~* URI { configuration } #不区分大小写几种匹配方式的说明与优先级整体规则按照先普通匹配，然后再正则匹配，如果正则不匹配，则回退至上一个普通匹配。其中普通匹配没有顺序之分，哪个匹配最精确，就使用哪个 location，正则匹配按照规则的书写顺序进行。= 精确匹配，匹配后停止后续匹配，直接执行该匹配后的 configuration。[空格] 前缀匹配，匹配后，继续更长前缀匹配和正则匹配。^~ 不属于正则匹配，匹配该规则后，停止继续正则匹配。~ 区分大小写的正则匹配，按顺序匹配，一旦匹配即停止后续匹配。~* 不区分大小写的正则匹配，按顺序匹配，一旦匹配即停止后续匹配。示例location = / {    [ configuration A ]}location / {    [ configuration B ]}location /user/ {    [ configuration C ]}location ^~ /images/ {    [ configuration D ]}location ~* \\.(gif|jpg|jpeg)$ {    [ configuration E ]}请求/精准匹配 A，不再往下查找。请求/index.html匹配 B。首先查找匹配的前缀字符，找到最长匹配是配置 B，接着又按照顺序查找匹配的正则。结果没有找到，因此使用先前标记的最长匹配，即配置 B。请求/user/index.html匹配 C。首先找到最长匹配 C，由于后面没有匹配的正则，所以使用最长匹配 C。请求/user/1.jpg匹配 E。首先进行前缀字符的查找，找到最长匹配项 C，继续进行正则查找，找到匹配项 E。因此使用 E。请求/images/1.jpg匹配 D。首先进行前缀字符的查找，找到最长匹配 D。但是，特殊的是它使用了^~修饰符，不再进行接下来的正则的匹配查找，因此使用 D。这里，如果没有前面的修饰符，其实最终的匹配是 E。大家可以想一想为什么。请求/documents/about.html匹配 B。因为 B 表示任何以/开头的 URL 都匹配。在上面的配置中，只有 B 能满足，所以匹配 B。总结location 的配置有两种形式，普通和正则。查找匹配的时候，先查找普通，选择最长匹配项，再查找正则。正则的优先级高于普通。正则查找是按照在配置文件中的顺序进行的，因此正则顺序很重要，建议越精细的放的越靠前。使用=精准匹配可以加快查找的效率，如果经常被访问建议使用精确匹配=。"},{"id":"index","isRootIndexFile":true,"isIndexFile":true,"filename":"index.md","basename":"index","path":"/home/runner/work/qxtang.github.io/qxtang.github.io","content":"✒ 工作与日常学习笔记via：doc-builder"}]